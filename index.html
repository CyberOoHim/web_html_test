<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Blog</title>
    <style>
        html.font-loading body {
            opacity: 0;
            visibility: hidden;
        }

        body {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease;
        }
    </style>
    <script>
        (function () {
            document.documentElement.classList.add('font-loading');

            if (document.fonts) {
                document.fonts.ready.then(function () {
                    document.documentElement.classList.remove('font-loading');
                }).catch(function () {
                    document.documentElement.classList.remove('font-loading');
                });

                setTimeout(function () {
                    document.documentElement.classList.remove('font-loading');
                }, 3000);
            } else {
                document.documentElement.classList.remove('font-loading');
            }
        })();
    </script>
    <link rel="icon" type="image/svg+xml" href="./logo.svg" />

    <!-- Preconnect to API for faster first request -->
    <link rel="preconnect" href="https://cr-next-blog-firestore-276616043493.asia-east1.run.app" crossorigin />
    <link rel="dns-prefetch" href="https://cr-next-blog-firestore-276616043493.asia-east1.run.app" />

    <style>
        @font-face {
            font-family: 'ChiayiCity';
            src: url('https://raw.githubusercontent.com/CyberOoHim/CyberOoHim.github.io/main/assets/fonts/ChiayiCity.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
    </style>

    <!-- CDN Libraries - React only (other libs bundled for reliability) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <!-- Loading skeleton styles - displays instantly before JS loads -->
    <style>
        .skeleton-loader {
            min-height: 100vh;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            display: flex;
            flex-direction: column;
        }

        .skeleton-nav {
            height: 64px;
            background: white;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            padding: 0 24px;
        }

        .skeleton-logo {
            width: 120px;
            height: 24px;
            background: linear-gradient(90deg, #e2e8f0 25%, #f1f5f9 50%, #e2e8f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 4px;
        }

        .skeleton-content {
            flex: 1;
            max-width: 1200px;
            margin: 48px auto;
            padding: 0 24px;
            width: 100%;
        }

        .skeleton-title {
            width: 60%;
            height: 32px;
            background: linear-gradient(90deg, #e2e8f0 25%, #f1f5f9 50%, #e2e8f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 6px;
            margin-bottom: 32px;
        }

        .skeleton-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 24px;
        }

        .skeleton-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .skeleton-image {
            aspect-ratio: 16/10;
            background: linear-gradient(90deg, #e2e8f0 25%, #f1f5f9 50%, #e2e8f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        .skeleton-text {
            padding: 16px;
        }

        .skeleton-line {
            height: 16px;
            background: linear-gradient(90deg, #e2e8f0 25%, #f1f5f9 50%, #e2e8f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .skeleton-line:last-child {
            width: 60%;
            margin-bottom: 0;
        }

        @keyframes shimmer {
            0% {
                background-position: 200% 0;
            }

            100% {
                background-position: -200% 0;
            }
        }
    </style>
    <script type="module"
        crossorigin>var e, t, n = Object.defineProperty, r = (e, t, r) => ((e, t, r) => t in e ? n(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r); !function () { const e = document.createElement("link").relList; if (!(e && e.supports && e.supports("modulepreload"))) { for (const e of document.querySelectorAll('link[rel="modulepreload"]')) t(e); new MutationObserver(e => { for (const n of e) if ("childList" === n.type) for (const e of n.addedNodes) "LINK" === e.tagName && "modulepreload" === e.rel && t(e) }).observe(document, { childList: !0, subtree: !0 }) } function t(e) { if (e.ep) return; e.ep = !0; const t = function (e) { const t = {}; return e.integrity && (t.integrity = e.integrity), e.referrerPolicy && (t.referrerPolicy = e.referrerPolicy), "use-credentials" === e.crossOrigin ? t.credentials = "include" : "anonymous" === e.crossOrigin ? t.credentials = "omit" : t.credentials = "same-origin", t }(e); fetch(e.href, t) } }(); var s = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; function i(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var o = { exports: {} }, a = {}, l = React, c = l, u = Symbol.for("react.element"), h = Symbol.for("react.fragment"), d = Object.prototype.hasOwnProperty, p = c.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, f = { key: !0, ref: !0, __self: !0, __source: !0 }; function m(e, t, n) { var r, s = {}, i = null, o = null; for (r in void 0 !== n && (i = "" + n), void 0 !== t.key && (i = "" + t.key), void 0 !== t.ref && (o = t.ref), t) d.call(t, r) && !f.hasOwnProperty(r) && (s[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps) void 0 === s[r] && (s[r] = t[r]); return { $$typeof: u, type: e, key: i, ref: o, props: s, _owner: p.current } } a.Fragment = h, a.jsx = m, a.jsxs = m, o.exports = a; var g, E, T = o.exports;
/**
 * @remix-run/router v1.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function A() { return A = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, A.apply(this, arguments) } (E = g || (g = {})).Pop = "POP", E.Push = "PUSH", E.Replace = "REPLACE"; const _ = "popstate"; function y(e) { return void 0 === e && (e = {}), function (e, t, n, r) { void 0 === r && (r = {}); let { window: s = document.defaultView, v5Compat: i = !1 } = r, o = s.history, a = g.Pop, l = null, c = u(); function u() { return (o.state || { idx: null }).idx } function h() { a = g.Pop; let e = u(), t = null == e ? null : e - c; c = e, l && l({ action: a, location: p.location, delta: t }) } function d(e) { let t = "null" !== s.location.origin ? s.location.origin : s.location.href, n = "string" == typeof e ? e : N(e); return n = n.replace(/ $/, "%20"), b(t, "No window.location.(origin|href) available to create URL for href: " + n), new URL(n, t) } null == c && (c = 0, o.replaceState(A({}, o.state, { idx: c }), "")); let p = { get action() { return a }, get location() { return function (e, t) { let { pathname: n = "/", search: r = "", hash: s = "" } = I(e.location.hash.substr(1)); return n.startsWith("/") || n.startsWith(".") || (n = "/" + n), C("", { pathname: n, search: r, hash: s }, t.state && t.state.usr || null, t.state && t.state.key || "default") }(s, o) }, listen(e) { if (l) throw new Error("A history only accepts one active listener"); return s.addEventListener(_, h), l = e, () => { s.removeEventListener(_, h), l = null } }, createHref: e => function (e, t) { let n = e.document.querySelector("base"), r = ""; if (n && n.getAttribute("href")) { let t = e.location.href, n = t.indexOf("#"); r = -1 === n ? t : t.slice(0, n) } return r + "#" + ("string" == typeof t ? t : N(t)) }(s, e), createURL: d, encodeLocation(e) { let t = d(e); return { pathname: t.pathname, search: t.search, hash: t.hash } }, push: function (e, t) { a = g.Push; let r = C(p.location, e, t); n && n(r, e), c = u() + 1; let h = k(r, c), d = p.createHref(r); try { o.pushState(h, "", d) } catch (f) { if (f instanceof DOMException && "DataCloneError" === f.name) throw f; s.location.assign(d) } i && l && l({ action: a, location: p.location, delta: 1 }) }, replace: function (e, t) { a = g.Replace; let r = C(p.location, e, t); n && n(r, e), c = u(); let s = k(r, c), h = p.createHref(r); o.replaceState(s, "", h), i && l && l({ action: a, location: p.location, delta: 0 }) }, go: e => o.go(e) }; return p }(0, 0, function (e, t) { S("/" === e.pathname.charAt(0), "relative pathnames are not supported in hash history.push(" + JSON.stringify(t) + ")") }, e) } function b(e, t) { if (!1 === e || null == e) throw new Error(t) } function S(e, t) { if (!e) try { throw new Error(t) } catch (n) { } } function k(e, t) { return { usr: e.state, key: e.key, idx: t } } function C(e, t, n, r) { return void 0 === n && (n = null), A({ pathname: "string" == typeof e ? e : e.pathname, search: "", hash: "" }, "string" == typeof t ? I(t) : t, { state: n, key: t && t.key || r || Math.random().toString(36).substr(2, 8) }) } function N(e) { let { pathname: t = "/", search: n = "", hash: r = "" } = e; return n && "?" !== n && (t += "?" === n.charAt(0) ? n : "?" + n), r && "#" !== r && (t += "#" === r.charAt(0) ? r : "#" + r), t } function I(e) { let t = {}; if (e) { let n = e.indexOf("#"); n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n)); let r = e.indexOf("?"); r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e) } return t } var O, x; function R(e, t, n) { return void 0 === n && (n = "/"), function (e, t, n) { let r = Y(("string" == typeof t ? I(t) : t).pathname || "/", n); if (null == r) return null; let s = v(e); !function (e) { e.sort((e, t) => e.score !== t.score ? t.score - e.score : function (e, t) { return e.length === t.length && e.slice(0, -1).every((e, n) => e === t[n]) ? e[e.length - 1] - t[t.length - 1] : 0 }(e.routesMeta.map(e => e.childrenIndex), t.routesMeta.map(e => e.childrenIndex))) }(s); let i = null; for (let o = 0; null == i && o < s.length; ++o) { let e = z(r); i = j(s[o], e) } return i }(e, t, n) } function v(e, t, n, r) { void 0 === t && (t = []), void 0 === n && (n = []), void 0 === r && (r = ""); let s = (e, s, i) => { let o = { relativePath: void 0 === i ? e.path || "" : i, caseSensitive: !0 === e.caseSensitive, childrenIndex: s, route: e }; o.relativePath.startsWith("/") && (b(o.relativePath.startsWith(r), 'Absolute route path "' + o.relativePath + '" nested under path "' + r + '" is not valid. An absolute child route path must start with the combined path of all its parent routes.'), o.relativePath = o.relativePath.slice(r.length)); let a = Q([r, o.relativePath]), l = n.concat(o); e.children && e.children.length > 0 && (b(!0 !== e.index, 'Index routes must not have child routes. Please remove all child routes from route path "' + a + '".'), v(e.children, t, l, a)), (null != e.path || e.index) && t.push({ path: a, score: H(a, e.index), routesMeta: l }) }; return e.forEach((e, t) => { var n; if ("" !== e.path && null != (n = e.path) && n.includes("?")) for (let r of D(e.path)) s(e, t, r); else s(e, t) }), t } function D(e) { let t = e.split("/"); if (0 === t.length) return []; let [n, ...r] = t, s = n.endsWith("?"), i = n.replace(/\?$/, ""); if (0 === r.length) return s ? [i, ""] : [i]; let o = D(r.join("/")), a = []; return a.push(...o.map(e => "" === e ? i : [i, e].join("/"))), s && a.push(...o), a.map(t => e.startsWith("/") && "" === t ? "/" : t) } (x = O || (O = {})).data = "data", x.deferred = "deferred", x.redirect = "redirect", x.error = "error"; const L = /^:[\w-]+$/, P = 3, w = 2, M = 1, F = 10, B = -2, U = e => "*" === e; function H(e, t) { let n = e.split("/"), r = n.length; return n.some(U) && (r += B), t && (r += w), n.filter(e => !U(e)).reduce((e, t) => e + (L.test(t) ? P : "" === t ? M : F), r) } function j(e, t, n) { let { routesMeta: r } = e, s = {}, i = "/", o = []; for (let a = 0; a < r.length; ++a) { let e = r[a], n = a === r.length - 1, l = "/" === i ? t : t.slice(i.length) || "/", c = G({ path: e.relativePath, caseSensitive: e.caseSensitive, end: n }, l), u = e.route; if (!c) return null; Object.assign(s, c.params), o.push({ params: s, pathname: Q([i, c.pathname]), pathnameBase: X(Q([i, c.pathnameBase])), route: u }), "/" !== c.pathnameBase && (i = Q([i, c.pathnameBase])) } return o } function G(e, t) { "string" == typeof e && (e = { path: e, caseSensitive: !1, end: !0 }); let [n, r] = function (e, t, n) { void 0 === t && (t = !1), void 0 === n && (n = !0), S("*" === e || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were "' + e.replace(/\*$/, "/*") + '" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "' + e.replace(/\*$/, "/*") + '".'); let r = [], s = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (e, t, n) => (r.push({ paramName: t, isOptional: null != n }), n ? "/?([^\\/]+)?" : "/([^\\/]+)")); return e.endsWith("*") ? (r.push({ paramName: "*" }), s += "*" === e || "/*" === e ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? s += "\\/*$" : "" !== e && "/" !== e && (s += "(?:(?=\\/|$))"), [new RegExp(s, t ? void 0 : "i"), r] }(e.path, e.caseSensitive, e.end), s = t.match(n); if (!s) return null; let i = s[0], o = i.replace(/(.)\/+$/, "$1"), a = s.slice(1); return { params: r.reduce((e, t, n) => { let { paramName: r, isOptional: s } = t; if ("*" === r) { let e = a[n] || ""; o = i.slice(0, i.length - e.length).replace(/(.)\/+$/, "$1") } const l = a[n]; return e[r] = s && !l ? void 0 : (l || "").replace(/%2F/g, "/"), e }, {}), pathname: i, pathnameBase: o, pattern: e } } function z(e) { try { return e.split("/").map(e => decodeURIComponent(e).replace(/\//g, "%2F")).join("/") } catch (t) { return S(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding (' + t + ")."), e } } function Y(e, t) { if ("/" === t) return e; if (!e.toLowerCase().startsWith(t.toLowerCase())) return null; let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n); return r && "/" !== r ? null : e.slice(n) || "/" } const q = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i; function V(e, t) { let n = t.replace(/\/+$/, "").split("/"); return e.split("/").forEach(e => { ".." === e ? n.length > 1 && n.pop() : "." !== e && n.push(e) }), n.length > 1 ? n.join("/") : "/" } function $(e, t, n, r) { return "Cannot include a '" + e + "' character in a manually specified `to." + t + "` field [" + JSON.stringify(r) + "].  Please separate it out to the `to." + n + '` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.' } function W(e, t) { let n = function (e) { return e.filter((e, t) => 0 === t || e.route.path && e.route.path.length > 0) }(e); return t ? n.map((e, t) => t === n.length - 1 ? e.pathname : e.pathnameBase) : n.map(e => e.pathnameBase) } function K(e, t, n, r) { let s; void 0 === r && (r = !1), "string" == typeof e ? s = I(e) : (s = A({}, e), b(!s.pathname || !s.pathname.includes("?"), $("?", "pathname", "search", s)), b(!s.pathname || !s.pathname.includes("#"), $("#", "pathname", "hash", s)), b(!s.search || !s.search.includes("#"), $("#", "search", "hash", s))); let i, o = "" === e || "" === s.pathname, a = o ? "/" : s.pathname; if (null == a) i = n; else { let e = t.length - 1; if (!r && a.startsWith("..")) { let t = a.split("/"); for (; ".." === t[0];)t.shift(), e -= 1; s.pathname = t.join("/") } i = e >= 0 ? t[e] : "/" } let l = function (e, t) { void 0 === t && (t = "/"); let n, { pathname: r, search: s = "", hash: i = "" } = "string" == typeof e ? I(e) : e; if (r) if (o = r, q.test(o)) n = r; else { if (r.includes("//")) { let e = r; r = r.replace(/\/\/+/g, "/"), S(!1, "Pathnames cannot have embedded double slashes - normalizing " + e + " -> " + r) } n = r.startsWith("/") ? V(r.substring(1), "/") : V(r, t) } else n = t; var o; return { pathname: n, search: J(s), hash: Z(i) } }(s, i), c = a && "/" !== a && a.endsWith("/"), u = (o || "." === a) && n.endsWith("/"); return l.pathname.endsWith("/") || !c && !u || (l.pathname += "/"), l } const Q = e => e.join("/").replace(/\/\/+/g, "/"), X = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"), J = e => e && "?" !== e ? e.startsWith("?") ? e : "?" + e : "", Z = e => e && "#" !== e ? e.startsWith("#") ? e : "#" + e : ""; Error; const ee = ["post", "put", "patch", "delete"]; new Set(ee); const te = ["get", ...ee];
            /**
             * React Router v6.30.2
             *
             * Copyright (c) Remix Software Inc.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE.md file in the root directory of this source tree.
             *
             * @license MIT
             */
            function ne() { return ne = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, ne.apply(this, arguments) } new Set(te); const re = React.createContext(null), se = React.createContext(null), ie = React.createContext(null), oe = React.createContext(null), ae = React.createContext({ outlet: null, matches: [], isDataRoute: !1 }), le = React.createContext(null); function ce() { return null != React.useContext(oe) } function ue() { return ce() || b(!1), React.useContext(oe).location } function he(e) { React.useContext(ie).static || React.useLayoutEffect(e) } function de() { let { isDataRoute: e } = React.useContext(ae); return e ? function () { let { router: e } = function () { let e = React.useContext(re); return e || b(!1), e }(Ae.UseNavigateStable), t = ye(_e.UseNavigateStable), n = React.useRef(!1); return he(() => { n.current = !0 }), React.useCallback(function (r, s) { void 0 === s && (s = {}), n.current && ("number" == typeof r ? e.navigate(r) : e.navigate(r, ne({ fromRouteId: t }, s))) }, [e, t]) }() : function () { ce() || b(!1); let e = React.useContext(re), { basename: t, future: n, navigator: r } = React.useContext(ie), { matches: s } = React.useContext(ae), { pathname: i } = ue(), o = JSON.stringify(W(s, n.v7_relativeSplatPath)), a = React.useRef(!1); return he(() => { a.current = !0 }), React.useCallback(function (n, s) { if (void 0 === s && (s = {}), !a.current) return; if ("number" == typeof n) return void r.go(n); let l = K(n, JSON.parse(o), i, "path" === s.relative); null == e && "/" !== t && (l.pathname = "/" === l.pathname ? t : Q([t, l.pathname])), (s.replace ? r.replace : r.push)(l, s.state, s) }, [t, r, o, i, e]) }() } function pe() { let { matches: e } = React.useContext(ae), t = e[e.length - 1]; return t ? t.params : {} } function fe(e, t) { let { relative: n } = void 0 === t ? {} : t, { future: r } = React.useContext(ie), { matches: s } = React.useContext(ae), { pathname: i } = ue(), o = JSON.stringify(W(s, r.v7_relativeSplatPath)); return React.useMemo(() => K(e, JSON.parse(o), i, "path" === n), [e, o, i, n]) } function me() { let e = function () { var e; let t = React.useContext(le), n = function () { let e = React.useContext(se); return e || b(!1), e }(), r = ye(); return void 0 !== t ? t : null == (e = n.errors) ? void 0 : e[r] }(), t = function (e) { return null != e && "number" == typeof e.status && "string" == typeof e.statusText && "boolean" == typeof e.internal && "data" in e }(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null; return React.createElement(React.Fragment, null, React.createElement("h2", null, "Unexpected Application Error!"), React.createElement("h3", { style: { fontStyle: "italic" } }, t), n ? React.createElement("pre", { style: { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" } }, n) : null, null) } const ge = React.createElement(me, null); class Ee extends React.Component { constructor(e) { super(e), this.state = { location: e.location, revalidation: e.revalidation, error: e.error } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, t) { return t.location !== e.location || "idle" !== t.revalidation && "idle" === e.revalidation ? { error: e.error, location: e.location, revalidation: e.revalidation } : { error: void 0 !== e.error ? e.error : t.error, location: t.location, revalidation: e.revalidation || t.revalidation } } componentDidCatch(e, t) { } render() { return void 0 !== this.state.error ? React.createElement(ae.Provider, { value: this.props.routeContext }, React.createElement(le.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function Te(e) { let { routeContext: t, match: n, children: r } = e, s = React.useContext(re); return s && s.static && s.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (s.staticContext._deepestRenderedBoundaryId = n.route.id), React.createElement(ae.Provider, { value: t }, r) } var Ae = function (e) { return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e }(Ae || {}), _e = function (e) { return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e }(_e || {}); function ye(e) { let t = function () { let e = React.useContext(ae); return e || b(!1), e }(), n = t.matches[t.matches.length - 1]; return n.route.id || b(!1), n.route.id } const be = {}; function Se(e) { let { to: t, replace: n, state: r, relative: s } = e; ce() || b(!1); let { future: i, static: o } = React.useContext(ie), { matches: a } = React.useContext(ae), { pathname: l } = ue(), c = de(), u = K(t, W(a, i.v7_relativeSplatPath), l, "path" === s), h = JSON.stringify(u); return React.useEffect(() => c(JSON.parse(h), { replace: n, state: r, relative: s }), [c, h, s, n, r]), null } function ke(e) { b(!1) } function Ce(e) { let { basename: t = "/", children: n = null, location: r, navigationType: s = g.Pop, navigator: i, static: o = !1, future: a } = e; ce() && b(!1); let l = t.replace(/^\/*/, "/"), c = React.useMemo(() => ({ basename: l, navigator: i, static: o, future: ne({ v7_relativeSplatPath: !1 }, a) }), [l, a, i, o]); "string" == typeof r && (r = I(r)); let { pathname: u = "/", search: h = "", hash: d = "", state: p = null, key: f = "default" } = r, m = React.useMemo(() => { let e = Y(u, l); return null == e ? null : { location: { pathname: e, search: h, hash: d, state: p, key: f }, navigationType: s } }, [l, u, h, d, p, f, s]); return null == m ? null : React.createElement(ie.Provider, { value: c }, React.createElement(oe.Provider, { children: n, value: m })) } function Ne(e) { let { children: t, location: n } = e; return function (e, t) { ce() || b(!1); let { navigator: n } = React.useContext(ie), { matches: r } = React.useContext(ae), s = r[r.length - 1], i = s ? s.params : {}; !s || s.pathname; let o = s ? s.pathnameBase : "/"; s && s.route; let a, l = ue(); if (t) { var c; let e = "string" == typeof t ? I(t) : t; "/" === o || (null == (c = e.pathname) ? void 0 : c.startsWith(o)) || b(!1), a = e } else a = l; let u = a.pathname || "/", h = u; if ("/" !== o) { let e = o.replace(/^\//, "").split("/"); h = "/" + u.replace(/^\//, "").split("/").slice(e.length).join("/") } let d = R(e, { pathname: h }), p = function (e, t, n, r) { var s; if (void 0 === t && (t = []), void 0 === n && (n = null), void 0 === r && (r = null), null == e) { var i; if (!n) return null; if (n.errors) e = n.matches; else { if (!(null != (i = r) && i.v7_partialHydration && 0 === t.length && !n.initialized && n.matches.length > 0)) return null; e = n.matches } } let o = e, a = null == (s = n) ? void 0 : s.errors; if (null != a) { let e = o.findIndex(e => e.route.id && void 0 !== (null == a ? void 0 : a[e.route.id])); e >= 0 || b(!1), o = o.slice(0, Math.min(o.length, e + 1)) } let l = !1, c = -1; if (n && r && r.v7_partialHydration) for (let u = 0; u < o.length; u++) { let e = o[u]; if ((e.route.HydrateFallback || e.route.hydrateFallbackElement) && (c = u), e.route.id) { let { loaderData: t, errors: r } = n, s = e.route.loader && void 0 === t[e.route.id] && (!r || void 0 === r[e.route.id]); if (e.route.lazy || s) { l = !0, o = c >= 0 ? o.slice(0, c + 1) : [o[0]]; break } } } return o.reduceRight((e, r, s) => { let i, u = !1, h = null, d = null; n && (i = a && r.route.id ? a[r.route.id] : void 0, h = r.route.errorElement || ge, l && (c < 0 && 0 === s ? (be["route-fallback"] || (be["route-fallback"] = !0), u = !0, d = null) : c === s && (u = !0, d = r.route.hydrateFallbackElement || null))); let p = t.concat(o.slice(0, s + 1)), f = () => { let t; return t = i ? h : u ? d : r.route.Component ? React.createElement(r.route.Component, null) : r.route.element ? r.route.element : e, React.createElement(Te, { match: r, routeContext: { outlet: e, matches: p, isDataRoute: null != n }, children: t }) }; return n && (r.route.ErrorBoundary || r.route.errorElement || 0 === s) ? React.createElement(Ee, { location: n.location, revalidation: n.revalidation, component: h, error: i, children: f(), routeContext: { outlet: null, matches: p, isDataRoute: !0 } }) : f() }, null) }(d && d.map(e => Object.assign({}, e, { params: Object.assign({}, i, e.params), pathname: Q([o, n.encodeLocation ? n.encodeLocation(e.pathname).pathname : e.pathname]), pathnameBase: "/" === e.pathnameBase ? o : Q([o, n.encodeLocation ? n.encodeLocation(e.pathnameBase).pathname : e.pathnameBase]) })), r, void 0, void 0); return t && p ? React.createElement(oe.Provider, { value: { location: ne({ pathname: "/", search: "", hash: "", state: null, key: "default" }, a), navigationType: g.Pop } }, p) : p }(Ie(t), n) } function Ie(e, t) { void 0 === t && (t = []); let n = []; return React.Children.forEach(e, (e, r) => { if (!React.isValidElement(e)) return; let s = [...t, r]; if (e.type === React.Fragment) return void n.push.apply(n, Ie(e.props.children, s)); e.type !== ke && b(!1), e.props.index && e.props.children && b(!1); let i = { id: e.props.id || s.join("-"), caseSensitive: e.props.caseSensitive, element: e.props.element, Component: e.props.Component, index: e.props.index, path: e.props.path, loader: e.props.loader, action: e.props.action, errorElement: e.props.errorElement, ErrorBoundary: e.props.ErrorBoundary, hasErrorBoundary: null != e.props.ErrorBoundary || null != e.props.errorElement, shouldRevalidate: e.props.shouldRevalidate, handle: e.props.handle, lazy: e.props.lazy }; e.props.children && (i.children = Ie(e.props.children, s)), n.push(i) }), n }
/**
 * React Router DOM v6.30.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Oe() { return Oe = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, Oe.apply(this, arguments) } React.startTransition, new Promise(() => { }), React.Component; const xe = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"]; try { window.__reactRouterVersion = "6" } catch (fg) { } const Re = React.startTransition; function ve(e) { let { basename: t, children: n, future: r, window: s } = e, i = React.useRef(); null == i.current && (i.current = y({ window: s, v5Compat: !0 })); let o = i.current, [a, l] = React.useState({ action: o.action, location: o.location }), { v7_startTransition: c } = r || {}, u = React.useCallback(e => { c && Re ? Re(() => l(e)) : l(e) }, [l, c]); return React.useLayoutEffect(() => o.listen(u), [o, u]), React.useEffect(() => { return null == (e = r) || e.v7_startTransition, void (null == e || e.v7_relativeSplatPath); var e }, [r]), React.createElement(Ce, { basename: t, children: n, location: a.location, navigationType: a.action, navigator: o, future: r }) } ReactDOM.flushSync, React.useId; const De = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement, Le = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Pe = React.forwardRef(function (e, t) { let n, { onClick: r, relative: s, reloadDocument: i, replace: o, state: a, target: l, to: c, preventScrollReset: u, viewTransition: h } = e, d = function (e, t) { if (null == e) return {}; var n, r, s = {}, i = Object.keys(e); for (r = 0; r < i.length; r++)n = i[r], t.indexOf(n) >= 0 || (s[n] = e[n]); return s }(e, xe), { basename: p } = React.useContext(ie), f = !1; if ("string" == typeof c && Le.test(c) && (n = c, De)) try { let e = new URL(window.location.href), t = c.startsWith("//") ? new URL(e.protocol + c) : new URL(c), n = Y(t.pathname, p); t.origin === e.origin && null != n ? c = n + t.search + t.hash : f = !0 } catch (fg) { } let m = function (e, t) { let { relative: n } = void 0 === t ? {} : t; ce() || b(!1); let { basename: r, navigator: s } = React.useContext(ie), { hash: i, pathname: o, search: a } = fe(e, { relative: n }), l = o; return "/" !== r && (l = "/" === o ? r : Q([r, o])), s.createHref({ pathname: l, search: a, hash: i }) }(c, { relative: s }), g = function (e, t) { let { target: n, replace: r, state: s, preventScrollReset: i, relative: o, viewTransition: a } = void 0 === t ? {} : t, l = de(), c = ue(), u = fe(e, { relative: o }); return React.useCallback(t => { if (function (e, t) { return !(0 !== e.button || t && "_self" !== t || function (e) { return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) }(e)) }(t, n)) { t.preventDefault(); let n = void 0 !== r ? r : N(c) === N(u); l(e, { replace: n, state: s, preventScrollReset: i, relative: o, viewTransition: a }) } }, [c, l, u, r, s, n, e, i, o, a]) }(c, { replace: o, state: a, target: l, preventScrollReset: u, relative: s, viewTransition: h }); return React.createElement("a", Oe({}, d, { href: n || m, onClick: f || i ? r : function (e) { r && r(e), e.defaultPrevented || g(e) }, ref: t, target: l })) }); var we, Me, Fe, Be; (Me = we || (we = {})).UseScrollRestoration = "useScrollRestoration", Me.UseSubmit = "useSubmit", Me.UseSubmitFetcher = "useSubmitFetcher", Me.UseFetcher = "useFetcher", Me.useViewTransitionState = "useViewTransitionState", (Be = Fe || (Fe = {})).UseFetcher = "useFetcher", Be.UseFetchers = "useFetchers", Be.UseScrollRestoration = "useScrollRestoration"; var Ue = "undefined" != typeof Element, He = "function" == typeof Map, je = "function" == typeof Set, Ge = "function" == typeof ArrayBuffer && !!ArrayBuffer.isView; function ze(e, t) { if (e === t) return !0; if (e && t && "object" == typeof e && "object" == typeof t) { if (e.constructor !== t.constructor) return !1; var n, r, s, i; if (Array.isArray(e)) { if ((n = e.length) != t.length) return !1; for (r = n; 0 !== r--;)if (!ze(e[r], t[r])) return !1; return !0 } if (He && e instanceof Map && t instanceof Map) { if (e.size !== t.size) return !1; for (i = e.entries(); !(r = i.next()).done;)if (!t.has(r.value[0])) return !1; for (i = e.entries(); !(r = i.next()).done;)if (!ze(r.value[1], t.get(r.value[0]))) return !1; return !0 } if (je && e instanceof Set && t instanceof Set) { if (e.size !== t.size) return !1; for (i = e.entries(); !(r = i.next()).done;)if (!t.has(r.value[0])) return !1; return !0 } if (Ge && ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) { if ((n = e.length) != t.length) return !1; for (r = n; 0 !== r--;)if (e[r] !== t[r]) return !1; return !0 } if (e.constructor === RegExp) return e.source === t.source && e.flags === t.flags; if (e.valueOf !== Object.prototype.valueOf && "function" == typeof e.valueOf && "function" == typeof t.valueOf) return e.valueOf() === t.valueOf(); if (e.toString !== Object.prototype.toString && "function" == typeof e.toString && "function" == typeof t.toString) return e.toString() === t.toString(); if ((n = (s = Object.keys(e)).length) !== Object.keys(t).length) return !1; for (r = n; 0 !== r--;)if (!Object.prototype.hasOwnProperty.call(t, s[r])) return !1; if (Ue && e instanceof Element) return !1; for (r = n; 0 !== r--;)if (("_owner" !== s[r] && "__v" !== s[r] && "__o" !== s[r] || !e.$$typeof) && !ze(e[s[r]], t[s[r]])) return !1; return !0 } return e != e && t != t } const Ye = i(function (e, t) { try { return ze(e, t) } catch (n) { if ((n.message || "").match(/stack|recursion/i)) return !1; throw n } }), qe = i(function (e, t, n, r, s, i, o, a) { if (!e) { var l; if (void 0 === t) l = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else { var c = [n, r, s, i, o, a], u = 0; (l = new Error(t.replace(/%s/g, function () { return c[u++] }))).name = "Invariant Violation" } throw l.framesToPop = 1, l } }), Ve = i(function (e, t, n, r) { var s = n ? n.call(r, e, t) : void 0; if (void 0 !== s) return !!s; if (e === t) return !0; if ("object" != typeof e || !e || "object" != typeof t || !t) return !1; var i = Object.keys(e), o = Object.keys(t); if (i.length !== o.length) return !1; for (var a = Object.prototype.hasOwnProperty.bind(t), l = 0; l < i.length; l++) { var c = i[l]; if (!a(c)) return !1; var u = e[c], h = t[c]; if (!1 === (s = n ? n.call(r, u, h, c) : void 0) || void 0 === s && u !== h) return !1 } return !0 }); var $e = (e => (e.BASE = "base", e.BODY = "body", e.HEAD = "head", e.HTML = "html", e.LINK = "link", e.META = "meta", e.NOSCRIPT = "noscript", e.SCRIPT = "script", e.STYLE = "style", e.TITLE = "title", e.FRAGMENT = "Symbol(react.fragment)", e))($e || {}), We = { rel: ["amphtml", "canonical", "alternate"] }, Ke = { type: ["application/ld+json"] }, Qe = { charset: "", name: ["generator", "robots", "description"], property: ["og:type", "og:title", "og:url", "og:image", "og:image:alt", "og:description", "twitter:url", "twitter:title", "twitter:description", "twitter:image", "twitter:image:alt", "twitter:card", "twitter:site"] }, Xe = Object.values($e), Je = { accesskey: "accessKey", charset: "charSet", class: "className", contenteditable: "contentEditable", contextmenu: "contextMenu", "http-equiv": "httpEquiv", itemprop: "itemProp", tabindex: "tabIndex" }, Ze = Object.entries(Je).reduce((e, [t, n]) => (e[n] = t, e), {}), et = "data-rh", tt = (e, t) => { for (let n = e.length - 1; n >= 0; n -= 1) { const r = e[n]; if (Object.prototype.hasOwnProperty.call(r, t)) return r[t] } return null }, nt = e => { let t = tt(e, "title"); const n = tt(e, "titleTemplate"); if (Array.isArray(t) && (t = t.join("")), n && t) return n.replace(/%s/g, () => t); const r = tt(e, "defaultTitle"); return t || r || void 0 }, rt = e => tt(e, "onChangeClientState") || (() => { }), st = (e, t) => t.filter(t => void 0 !== t[e]).map(t => t[e]).reduce((e, t) => ({ ...e, ...t }), {}), it = (e, t) => t.filter(e => void 0 !== e.base).map(e => e.base).reverse().reduce((t, n) => { if (!t.length) { const r = Object.keys(n); for (let s = 0; s < r.length; s += 1) { const i = r[s].toLowerCase(); if (-1 !== e.indexOf(i) && n[i]) return t.concat(n) } } return t }, []), ot = (e, t, n) => { const r = {}; return n.filter(t => !!Array.isArray(t[e]) || (void 0 !== t[e] && (t[e], console && console.warn), !1)).map(t => t[e]).reverse().reduce((e, n) => { const s = {}; n.filter(e => { let n; const i = Object.keys(e); for (let r = 0; r < i.length; r += 1) { const s = i[r], o = s.toLowerCase(); -1 === t.indexOf(o) || "rel" === n && "canonical" === e[n].toLowerCase() || "rel" === o && "stylesheet" === e[o].toLowerCase() || (n = o), -1 === t.indexOf(s) || "innerHTML" !== s && "cssText" !== s && "itemprop" !== s || (n = s) } if (!n || !e[n]) return !1; const o = e[n].toLowerCase(); return r[n] || (r[n] = {}), s[n] || (s[n] = {}), !r[n][o] && (s[n][o] = !0, !0) }).reverse().forEach(t => e.push(t)); const i = Object.keys(s); for (let t = 0; t < i.length; t += 1) { const e = i[t], n = { ...r[e], ...s[e] }; r[e] = n } return e }, []).reverse() }, at = (e, t) => { if (Array.isArray(e) && e.length) for (let n = 0; n < e.length; n += 1)if (e[n][t]) return !0; return !1 }, lt = e => Array.isArray(e) ? e.join("") : e, ct = (e, t) => Array.isArray(e) ? e.reduce((e, n) => (((e, t) => { const n = Object.keys(e); for (let r = 0; r < n.length; r += 1)if (t[n[r]] && t[n[r]].includes(e[n[r]])) return !0; return !1 })(n, t) ? e.priority.push(n) : e.default.push(n), e), { priority: [], default: [] }) : { default: e, priority: [] }, ut = (e, t) => ({ ...e, [t]: void 0 }), ht = ["noscript", "script", "style"], dt = (e, t = !0) => !1 === t ? String(e) : String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;"), pt = e => Object.keys(e).reduce((t, n) => { const r = void 0 !== e[n] ? `${n}="${e[n]}"` : `${n}`; return t ? `${t} ${r}` : r }, ""), ft = (e, t = {}) => Object.keys(e).reduce((t, n) => (t[Je[n] || n] = e[n], t), t), mt = (e, t) => t.map((t, n) => { const r = { key: n, [et]: !0 }; return Object.keys(t).forEach(e => { const n = Je[e] || e; if ("innerHTML" === n || "cssText" === n) { const e = t.innerHTML || t.cssText; r.dangerouslySetInnerHTML = { __html: e } } else r[n] = t[e] }), React.createElement(e, r) }), gt = (e, t, n = !0) => { switch (e) { case "title": return { toComponent: () => ((e, t, n) => { const r = ft(n, { key: t, [et]: !0 }); return [React.createElement("title", r, t)] })(0, t.title, t.titleAttributes), toString: () => ((e, t, n, r) => { const s = pt(n), i = lt(t); return s ? `<${e} ${et}="true" ${s}>${dt(i, r)}</${e}>` : `<${e} ${et}="true">${dt(i, r)}</${e}>` })(e, t.title, t.titleAttributes, n) }; case "bodyAttributes": case "htmlAttributes": return { toComponent: () => ft(t), toString: () => pt(t) }; default: return { toComponent: () => mt(e, t), toString: () => ((e, t, n = !0) => t.reduce((t, r) => { const s = r, i = Object.keys(s).filter(e => !("innerHTML" === e || "cssText" === e)).reduce((e, t) => { const r = void 0 === s[t] ? t : `${t}="${dt(s[t], n)}"`; return e ? `${e} ${r}` : r }, ""), o = s.innerHTML || s.cssText || "", a = -1 === ht.indexOf(e); return `${t}<${e} ${et}="true" ${i}${a ? "/>" : `>${o}</${e}>`}` }, ""))(e, t, n) } } }, Et = e => { const { baseTag: t, bodyAttributes: n, encode: r = !0, htmlAttributes: s, noscriptTags: i, styleTags: o, title: a = "", titleAttributes: l, prioritizeSeoTags: c } = e; let { linkTags: u, metaTags: h, scriptTags: d } = e, p = { toComponent: () => { }, toString: () => "" }; return c && ({ priorityMethods: p, linkTags: u, metaTags: h, scriptTags: d } = (({ metaTags: e, linkTags: t, scriptTags: n, encode: r }) => { const s = ct(e, Qe), i = ct(t, We), o = ct(n, Ke); return { priorityMethods: { toComponent: () => [...mt("meta", s.priority), ...mt("link", i.priority), ...mt("script", o.priority)], toString: () => `${gt("meta", s.priority, r)} ${gt("link", i.priority, r)} ${gt("script", o.priority, r)}` }, metaTags: s.default, linkTags: i.default, scriptTags: o.default } })(e)), { priority: p, base: gt("base", t, r), bodyAttributes: gt("bodyAttributes", n, r), htmlAttributes: gt("htmlAttributes", s, r), link: gt("link", u, r), meta: gt("meta", h, r), noscript: gt("noscript", i, r), script: gt("script", d, r), style: gt("style", o, r), title: gt("title", { title: a, titleAttributes: l }, r) } }, Tt = [], At = !("undefined" == typeof window || !window.document || !window.document.createElement), _t = class { constructor(e, t) { r(this, "instances", []), r(this, "canUseDOM", At), r(this, "context"), r(this, "value", { setHelmet: e => { this.context.helmet = e }, helmetInstances: { get: () => this.canUseDOM ? Tt : this.instances, add: e => { (this.canUseDOM ? Tt : this.instances).push(e) }, remove: e => { const t = (this.canUseDOM ? Tt : this.instances).indexOf(e); (this.canUseDOM ? Tt : this.instances).splice(t, 1) } } }), this.context = e, this.canUseDOM = t || !1, t || (e.helmet = Et({ baseTag: [], bodyAttributes: {}, htmlAttributes: {}, linkTags: [], metaTags: [], noscriptTags: [], scriptTags: [], styleTags: [], title: "", titleAttributes: {} })) } }, yt = React.createContext({}), bt = (e = class extends React.Component { constructor(t) { super(t), r(this, "helmetData"), this.helmetData = new _t(this.props.context || {}, e.canUseDOM) } render() { return React.createElement(yt.Provider, { value: this.helmetData.value }, this.props.children) } }, r(e, "canUseDOM", At), e), St = (e, t) => { const n = document.head || document.querySelector("head"), r = n.querySelectorAll(`${e}[${et}]`), s = [].slice.call(r), i = []; let o; return t && t.length && t.forEach(t => { const n = document.createElement(e); for (const e in t) if (Object.prototype.hasOwnProperty.call(t, e)) if ("innerHTML" === e) n.innerHTML = t.innerHTML; else if ("cssText" === e) n.styleSheet ? n.styleSheet.cssText = t.cssText : n.appendChild(document.createTextNode(t.cssText)); else { const r = e, s = void 0 === t[r] ? "" : t[r]; n.setAttribute(e, s) } n.setAttribute(et, "true"), s.some((e, t) => (o = t, n.isEqualNode(e))) ? s.splice(o, 1) : i.push(n) }), s.forEach(e => { var t; return null == (t = e.parentNode) ? void 0 : t.removeChild(e) }), i.forEach(e => n.appendChild(e)), { oldTags: s, newTags: i } }, kt = (e, t) => { const n = document.getElementsByTagName(e)[0]; if (!n) return; const r = n.getAttribute(et), s = r ? r.split(",") : [], i = [...s], o = Object.keys(t); for (const a of o) { const e = t[a] || ""; n.getAttribute(a) !== e && n.setAttribute(a, e), -1 === s.indexOf(a) && s.push(a); const r = i.indexOf(a); -1 !== r && i.splice(r, 1) } for (let a = i.length - 1; a >= 0; a -= 1)n.removeAttribute(i[a]); s.length === i.length ? n.removeAttribute(et) : n.getAttribute(et) !== o.join(",") && n.setAttribute(et, o.join(",")) }, Ct = (e, t) => { const { baseTag: n, bodyAttributes: r, htmlAttributes: s, linkTags: i, metaTags: o, noscriptTags: a, onChangeClientState: l, scriptTags: c, styleTags: u, title: h, titleAttributes: d } = e; kt("body", r), kt("html", s), ((e, t) => { void 0 !== e && document.title !== e && (document.title = lt(e)), kt("title", t) })(h, d); const p = { baseTag: St("base", n), linkTags: St("link", i), metaTags: St("meta", o), noscriptTags: St("noscript", a), scriptTags: St("script", c), styleTags: St("style", u) }, f = {}, m = {}; Object.keys(p).forEach(e => { const { newTags: t, oldTags: n } = p[e]; t.length && (f[e] = t), n.length && (m[e] = p[e].oldTags) }), t && t(), l(e, f, m) }, Nt = null, It = class extends React.Component { constructor() { super(...arguments), r(this, "rendered", !1) } shouldComponentUpdate(e) { return !Ve(e, this.props) } componentDidUpdate() { this.emitChange() } componentWillUnmount() { const { helmetInstances: e } = this.props.context; e.remove(this), this.emitChange() } emitChange() { const { helmetInstances: e, setHelmet: t } = this.props.context; let n = null; const r = (s = e.get().map(e => { const t = { ...e.props }; return delete t.context, t }), { baseTag: it(["href"], s), bodyAttributes: st("bodyAttributes", s), defer: tt(s, "defer"), encode: tt(s, "encodeSpecialCharacters"), htmlAttributes: st("htmlAttributes", s), linkTags: ot("link", ["rel", "href"], s), metaTags: ot("meta", ["name", "charset", "http-equiv", "property", "itemprop"], s), noscriptTags: ot("noscript", ["innerHTML"], s), onChangeClientState: rt(s), scriptTags: ot("script", ["src", "innerHTML"], s), styleTags: ot("style", ["cssText"], s), title: nt(s), titleAttributes: st("titleAttributes", s), prioritizeSeoTags: at(s, "prioritizeSeoTags") }); var s, i; bt.canUseDOM ? (i = r, Nt && cancelAnimationFrame(Nt), i.defer ? Nt = requestAnimationFrame(() => { Ct(i, () => { Nt = null }) }) : (Ct(i), Nt = null)) : Et && (n = Et(r)), t(n) } init() { if (this.rendered) return; this.rendered = !0; const { helmetInstances: e } = this.props.context; e.add(this), this.emitChange() } render() { return this.init(), null } }, Ot = (t = class extends React.Component { shouldComponentUpdate(e) { return !Ye(ut(this.props, "helmetData"), ut(e, "helmetData")) } mapNestedChildrenToProps(e, t) { if (!t) return null; switch (e.type) { case "script": case "noscript": return { innerHTML: t }; case "style": return { cssText: t }; default: throw new Error(`<${e.type} /> elements are self-closing and can not contain children. Refer to our API for more information.`) } } flattenArrayTypeChildren(e, t, n, r) { return { ...t, [e.type]: [...t[e.type] || [], { ...n, ...this.mapNestedChildrenToProps(e, r) }] } } mapObjectTypeChildren(e, t, n, r) { switch (e.type) { case "title": return { ...t, [e.type]: r, titleAttributes: { ...n } }; case "body": return { ...t, bodyAttributes: { ...n } }; case "html": return { ...t, htmlAttributes: { ...n } }; default: return { ...t, [e.type]: { ...n } } } } mapArrayTypeChildrenToProps(e, t) { let n = { ...t }; return Object.keys(e).forEach(t => { n = { ...n, [t]: e[t] } }), n } warnOnInvalidChildren(e, t) { return qe(Xe.some(t => e.type === t), "function" == typeof e.type ? "You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information." : `Only elements types ${Xe.join(", ")} are allowed. Helmet does not support rendering <${e.type}> elements. Refer to our API for more information.`), qe(!t || "string" == typeof t || Array.isArray(t) && !t.some(e => "string" != typeof e), `Helmet expects a string as a child of <${e.type}>. Did you forget to wrap your children in braces? ( <${e.type}>{\`\`}</${e.type}> ) Refer to our API for more information.`), !0 } mapChildrenToProps(e, t) { let n = {}; return React.Children.forEach(e, e => { if (!e || !e.props) return; const { children: r, ...s } = e.props, i = Object.keys(s).reduce((e, t) => (e[Ze[t] || t] = s[t], e), {}); let { type: o } = e; switch ("symbol" == typeof o ? o = o.toString() : this.warnOnInvalidChildren(e, r), o) { case "Symbol(react.fragment)": t = this.mapChildrenToProps(r, t); break; case "link": case "meta": case "noscript": case "script": case "style": n = this.flattenArrayTypeChildren(e, n, i, r); break; default: t = this.mapObjectTypeChildren(e, t, i, r) } }), this.mapArrayTypeChildrenToProps(n, t) } render() { const { children: e, ...t } = this.props; let n = { ...t }, { helmetData: r } = t; return e && (n = this.mapChildrenToProps(e, n)), !r || r instanceof _t || (r = new _t(r.context, !0), delete n.helmetData), r ? React.createElement(It, { ...n, context: r.value }) : React.createElement(yt.Consumer, null, e => React.createElement(It, { ...n, context: e })) } }, r(t, "defaultProps", { defer: !0, encodeSpecialCharacters: !0, prioritizeSeoTags: !1 }), t); const xt = React.createContext(void 0); function Rt({ children: e }) { const [t, n] = React.useState(() => { try { const e = localStorage.getItem("cr-blog-theme") || localStorage.getItem("theme"); if ("dark" === e || "light" === e) return e } catch (fg) { } return "light" }), [r, s] = React.useState(() => { try { const e = localStorage.getItem("cr-blog-text-size") || localStorage.getItem("textSize"); if ("small" === e || "medium" === e || "large" === e || "xlarge" === e || "xxlarge" === e || "xxxlarge" === e) return e } catch (fg) { } return "medium" }); return React.useEffect(() => { const e = document.documentElement; e.classList.remove("light", "dark"), e.classList.add(t); try { localStorage.setItem("cr-blog-theme", t), localStorage.removeItem("theme") } catch (fg) { } }, [t]), React.useEffect(() => { document.documentElement.setAttribute("data-text-size", r); try { localStorage.setItem("cr-blog-text-size", r), localStorage.removeItem("textSize") } catch (fg) { } }, [r]), React.useEffect(() => { const e = document.documentElement; e.style.setProperty("--prose-body-line-height", String(1.8)), e.style.setProperty("--prose-list-line-height", String(1.65)), e.style.setProperty("--prose-blockquote-line-height", String(1.65)) }, []), T.jsx(xt.Provider, { value: { theme: t, textSize: r, toggleTheme: () => { n(e => "light" === e ? "dark" : "light") }, setTextSize: e => { s(e) } }, children: e }) } const vt = e => "string" == typeof e, Dt = () => { let e, t; const n = new Promise((n, r) => { e = n, t = r }); return n.resolve = e, n.reject = t, n }, Lt = e => null == e ? "" : "" + e, Pt = /###/g, wt = e => e && e.indexOf("###") > -1 ? e.replace(Pt, ".") : e, Mt = e => !e || vt(e), Ft = (e, t, n) => { const r = vt(t) ? t.split(".") : t; let s = 0; for (; s < r.length - 1;) { if (Mt(e)) return {}; const t = wt(r[s]); !e[t] && n && (e[t] = new n), e = Object.prototype.hasOwnProperty.call(e, t) ? e[t] : {}, ++s } return Mt(e) ? {} : { obj: e, k: wt(r[s]) } }, Bt = (e, t, n) => { const { obj: r, k: s } = Ft(e, t, Object); if (void 0 !== r || 1 === t.length) return void (r[s] = n); let i = t[t.length - 1], o = t.slice(0, t.length - 1), a = Ft(e, o, Object); for (; void 0 === a.obj && o.length;)i = `${o[o.length - 1]}.${i}`, o = o.slice(0, o.length - 1), a = Ft(e, o, Object), (null == a ? void 0 : a.obj) && void 0 !== a.obj[`${a.k}.${i}`] && (a.obj = void 0); a.obj[`${a.k}.${i}`] = n }, Ut = (e, t) => { const { obj: n, k: r } = Ft(e, t); if (n && Object.prototype.hasOwnProperty.call(n, r)) return n[r] }, Ht = (e, t, n) => { for (const r in t) "__proto__" !== r && "constructor" !== r && (r in e ? vt(e[r]) || e[r] instanceof String || vt(t[r]) || t[r] instanceof String ? n && (e[r] = t[r]) : Ht(e[r], t[r], n) : e[r] = t[r]); return e }, jt = e => e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"); var Gt = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;", "/": "&#x2F;" }; const zt = e => vt(e) ? e.replace(/[&<>"'\/]/g, e => Gt[e]) : e, Yt = [" ", ",", "?", "!", ";"], qt = new class { constructor(e) { this.capacity = e, this.regExpMap = new Map, this.regExpQueue = [] } getRegExp(e) { const t = this.regExpMap.get(e); if (void 0 !== t) return t; const n = new RegExp(e); return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(e, n), this.regExpQueue.push(e), n } }(20), Vt = (e, t, n = ".") => { if (!e) return; if (e[t]) { if (!Object.prototype.hasOwnProperty.call(e, t)) return; return e[t] } const r = t.split(n); let s = e; for (let i = 0; i < r.length;) { if (!s || "object" != typeof s) return; let e, t = ""; for (let o = i; o < r.length; ++o)if (o !== i && (t += n), t += r[o], e = s[t], void 0 !== e) { if (["string", "number", "boolean"].indexOf(typeof e) > -1 && o < r.length - 1) continue; i += o - i + 1; break } s = e } return s }, $t = e => null == e ? void 0 : e.replace("_", "-"), Wt = { type: "logger", log(e) { this.output("log", e) }, warn(e) { this.output("warn", e) }, error(e) { this.output("error", e) }, output(e, t) { var n, r; null == (r = null == (n = null == console ? void 0 : console[e]) ? void 0 : n.apply) || r.call(n, console, t) } }; class Kt { constructor(e, t = {}) { this.init(e, t) } init(e, t = {}) { this.prefix = t.prefix || "i18next:", this.logger = e || Wt, this.options = t, this.debug = t.debug } log(...e) { return this.forward(e, "log", "", !0) } warn(...e) { return this.forward(e, "warn", "", !0) } error(...e) { return this.forward(e, "error", "") } deprecate(...e) { return this.forward(e, "warn", "WARNING DEPRECATED: ", !0) } forward(e, t, n, r) { return r && !this.debug ? null : (vt(e[0]) && (e[0] = `${n}${this.prefix} ${e[0]}`), this.logger[t](e)) } create(e) { return new Kt(this.logger, { prefix: `${this.prefix}:${e}:`, ...this.options }) } clone(e) { return (e = e || this.options).prefix = e.prefix || this.prefix, new Kt(this.logger, e) } } var Qt = new Kt; class Xt { constructor() { this.observers = {} } on(e, t) { return e.split(" ").forEach(e => { this.observers[e] || (this.observers[e] = new Map); const n = this.observers[e].get(t) || 0; this.observers[e].set(t, n + 1) }), this } off(e, t) { this.observers[e] && (t ? this.observers[e].delete(t) : delete this.observers[e]) } emit(e, ...t) { this.observers[e] && Array.from(this.observers[e].entries()).forEach(([e, n]) => { for (let r = 0; r < n; r++)e(...t) }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach(([n, r]) => { for (let s = 0; s < r; s++)n.apply(n, [e, ...t]) }) } } class Jt extends Xt { constructor(e, t = { ns: ["translation"], defaultNS: "translation" }) { super(), this.data = e || {}, this.options = t, void 0 === this.options.keySeparator && (this.options.keySeparator = "."), void 0 === this.options.ignoreJSONStructure && (this.options.ignoreJSONStructure = !0) } addNamespaces(e) { this.options.ns.indexOf(e) < 0 && this.options.ns.push(e) } removeNamespaces(e) { const t = this.options.ns.indexOf(e); t > -1 && this.options.ns.splice(t, 1) } getResource(e, t, n, r = {}) { var s, i; const o = void 0 !== r.keySeparator ? r.keySeparator : this.options.keySeparator, a = void 0 !== r.ignoreJSONStructure ? r.ignoreJSONStructure : this.options.ignoreJSONStructure; let l; e.indexOf(".") > -1 ? l = e.split(".") : (l = [e, t], n && (Array.isArray(n) ? l.push(...n) : vt(n) && o ? l.push(...n.split(o)) : l.push(n))); const c = Ut(this.data, l); return !c && !t && !n && e.indexOf(".") > -1 && (e = l[0], t = l[1], n = l.slice(2).join(".")), !c && a && vt(n) ? Vt(null == (i = null == (s = this.data) ? void 0 : s[e]) ? void 0 : i[t], n, o) : c } addResource(e, t, n, r, s = { silent: !1 }) { const i = void 0 !== s.keySeparator ? s.keySeparator : this.options.keySeparator; let o = [e, t]; n && (o = o.concat(i ? n.split(i) : n)), e.indexOf(".") > -1 && (o = e.split("."), r = t, t = o[1]), this.addNamespaces(t), Bt(this.data, o, r), s.silent || this.emit("added", e, t, n, r) } addResources(e, t, n, r = { silent: !1 }) { for (const s in n) (vt(n[s]) || Array.isArray(n[s])) && this.addResource(e, t, s, n[s], { silent: !0 }); r.silent || this.emit("added", e, t, n) } addResourceBundle(e, t, n, r, s, i = { silent: !1, skipCopy: !1 }) { let o = [e, t]; e.indexOf(".") > -1 && (o = e.split("."), r = n, n = t, t = o[1]), this.addNamespaces(t); let a = Ut(this.data, o) || {}; i.skipCopy || (n = JSON.parse(JSON.stringify(n))), r ? Ht(a, n, s) : a = { ...a, ...n }, Bt(this.data, o, a), i.silent || this.emit("added", e, t, n) } removeResourceBundle(e, t) { this.hasResourceBundle(e, t) && delete this.data[e][t], this.removeNamespaces(t), this.emit("removed", e, t) } hasResourceBundle(e, t) { return void 0 !== this.getResource(e, t) } getResourceBundle(e, t) { return t || (t = this.options.defaultNS), this.getResource(e, t) } getDataByLanguage(e) { return this.data[e] } hasLanguageSomeTranslations(e) { const t = this.getDataByLanguage(e); return !!(t && Object.keys(t) || []).find(e => t[e] && Object.keys(t[e]).length > 0) } toJSON() { return this.data } } var Zt = { processors: {}, addPostProcessor(e) { this.processors[e.name] = e }, handle(e, t, n, r, s) { return e.forEach(e => { var i; t = (null == (i = this.processors[e]) ? void 0 : i.process(t, n, r, s)) ?? t }), t } }; const en = Symbol("i18next/PATH_KEY"); function tn(e, t) { const { [en]: n } = e(function () { const e = [], t = Object.create(null); let n; return t.get = (r, s) => { var i; return null == (i = null == n ? void 0 : n.revoke) || i.call(n), s === en ? e : (e.push(s), n = Proxy.revocable(r, t), n.proxy) }, Proxy.revocable(Object.create(null), t).proxy }()); return n.join((null == t ? void 0 : t.keySeparator) ?? ".") } const nn = {}, rn = e => !vt(e) && "boolean" != typeof e && "number" != typeof e; class sn extends Xt { constructor(e, t = {}) { var n, r; super(), n = e, r = this, ["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"].forEach(e => { n[e] && (r[e] = n[e]) }), this.options = t, void 0 === this.options.keySeparator && (this.options.keySeparator = "."), this.logger = Qt.create("translator") } changeLanguage(e) { e && (this.language = e) } exists(e, t = { interpolation: {} }) { const n = { ...t }; if (null == e) return !1; const r = this.resolve(e, n); if (void 0 === (null == r ? void 0 : r.res)) return !1; const s = rn(r.res); return !1 !== n.returnObjects || !s } extractFromKey(e, t) { let n = void 0 !== t.nsSeparator ? t.nsSeparator : this.options.nsSeparator; void 0 === n && (n = ":"); const r = void 0 !== t.keySeparator ? t.keySeparator : this.options.keySeparator; let s = t.ns || this.options.defaultNS || []; const i = n && e.indexOf(n) > -1, o = !(this.options.userDefinedKeySeparator || t.keySeparator || this.options.userDefinedNsSeparator || t.nsSeparator || ((e, t, n) => { t = t || "", n = n || ""; const r = Yt.filter(e => t.indexOf(e) < 0 && n.indexOf(e) < 0); if (0 === r.length) return !0; const s = qt.getRegExp(`(${r.map(e => "?" === e ? "\\?" : e).join("|")})`); let i = !s.test(e); if (!i) { const t = e.indexOf(n); t > 0 && !s.test(e.substring(0, t)) && (i = !0) } return i })(e, n, r)); if (i && !o) { const t = e.match(this.interpolator.nestingRegexp); if (t && t.length > 0) return { key: e, namespaces: vt(s) ? [s] : s }; const i = e.split(n); (n !== r || n === r && this.options.ns.indexOf(i[0]) > -1) && (s = i.shift()), e = i.join(r) } return { key: e, namespaces: vt(s) ? [s] : s } } translate(e, t, n) { let r = "object" == typeof t ? { ...t } : t; if ("object" != typeof r && this.options.overloadTranslationOptionHandler && (r = this.options.overloadTranslationOptionHandler(arguments)), "object" == typeof r && (r = { ...r }), r || (r = {}), null == e) return ""; "function" == typeof e && (e = tn(e, { ...this.options, ...r })), Array.isArray(e) || (e = [String(e)]); const s = void 0 !== r.returnDetails ? r.returnDetails : this.options.returnDetails, i = void 0 !== r.keySeparator ? r.keySeparator : this.options.keySeparator, { key: o, namespaces: a } = this.extractFromKey(e[e.length - 1], r), l = a[a.length - 1]; let c = void 0 !== r.nsSeparator ? r.nsSeparator : this.options.nsSeparator; void 0 === c && (c = ":"); const u = r.lng || this.language, h = r.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode; if ("cimode" === (null == u ? void 0 : u.toLowerCase())) return h ? s ? { res: `${l}${c}${o}`, usedKey: o, exactUsedKey: o, usedLng: u, usedNS: l, usedParams: this.getUsedParamsDetails(r) } : `${l}${c}${o}` : s ? { res: o, usedKey: o, exactUsedKey: o, usedLng: u, usedNS: l, usedParams: this.getUsedParamsDetails(r) } : o; const d = this.resolve(e, r); let p = null == d ? void 0 : d.res; const f = (null == d ? void 0 : d.usedKey) || o, m = (null == d ? void 0 : d.exactUsedKey) || o, g = void 0 !== r.joinArrays ? r.joinArrays : this.options.joinArrays, E = !this.i18nFormat || this.i18nFormat.handleAsObject, T = void 0 !== r.count && !vt(r.count), A = sn.hasDefaultValue(r), _ = T ? this.pluralResolver.getSuffix(u, r.count, r) : "", y = r.ordinal && T ? this.pluralResolver.getSuffix(u, r.count, { ordinal: !1 }) : "", b = T && !r.ordinal && 0 === r.count, S = b && r[`defaultValue${this.options.pluralSeparator}zero`] || r[`defaultValue${_}`] || r[`defaultValue${y}`] || r.defaultValue; let k = p; E && !p && A && (k = S); const C = rn(k), N = Object.prototype.toString.apply(k); if (!(E && k && C && ["[object Number]", "[object Function]", "[object RegExp]"].indexOf(N) < 0) || vt(g) && Array.isArray(k)) if (E && vt(g) && Array.isArray(p)) p = p.join(g), p && (p = this.extendTranslation(p, e, r, n)); else { let t = !1, s = !1; !this.isValidLookup(p) && A && (t = !0, p = S), this.isValidLookup(p) || (s = !0, p = o); const a = (r.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && s ? void 0 : p, h = A && S !== p && this.options.updateMissing; if (s || t || h) { if (this.logger.log(h ? "updateKey" : "missingKey", u, l, o, h ? S : p), i) { const e = this.resolve(o, { ...r, keySeparator: !1 }); e && e.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.") } let e = []; const t = this.languageUtils.getFallbackCodes(this.options.fallbackLng, r.lng || this.language); if ("fallback" === this.options.saveMissingTo && t && t[0]) for (let r = 0; r < t.length; r++)e.push(t[r]); else "all" === this.options.saveMissingTo ? e = this.languageUtils.toResolveHierarchy(r.lng || this.language) : e.push(r.lng || this.language); const n = (e, t, n) => { var s; const i = A && n !== p ? n : a; this.options.missingKeyHandler ? this.options.missingKeyHandler(e, l, t, i, h, r) : (null == (s = this.backendConnector) ? void 0 : s.saveMissing) && this.backendConnector.saveMissing(e, l, t, i, h, r), this.emit("missingKey", e, l, t, p) }; this.options.saveMissing && (this.options.saveMissingPlurals && T ? e.forEach(e => { const t = this.pluralResolver.getSuffixes(e, r); b && r[`defaultValue${this.options.pluralSeparator}zero`] && t.indexOf(`${this.options.pluralSeparator}zero`) < 0 && t.push(`${this.options.pluralSeparator}zero`), t.forEach(t => { n([e], o + t, r[`defaultValue${t}`] || S) }) }) : n(e, o, S)) } p = this.extendTranslation(p, e, r, d, n), s && p === o && this.options.appendNamespaceToMissingKey && (p = `${l}${c}${o}`), (s || t) && this.options.parseMissingKeyHandler && (p = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${l}${c}${o}` : o, t ? p : void 0, r)) } else { if (!r.returnObjects && !this.options.returnObjects) { this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!"); const e = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(f, k, { ...r, ns: a }) : `key '${o} (${this.language})' returned an object instead of string.`; return s ? (d.res = e, d.usedParams = this.getUsedParamsDetails(r), d) : e } if (i) { const e = Array.isArray(k), t = e ? [] : {}, n = e ? m : f; for (const s in k) if (Object.prototype.hasOwnProperty.call(k, s)) { const e = `${n}${i}${s}`; t[s] = A && !p ? this.translate(e, { ...r, defaultValue: rn(S) ? S[s] : void 0, joinArrays: !1, ns: a }) : this.translate(e, { ...r, joinArrays: !1, ns: a }), t[s] === e && (t[s] = k[s]) } p = t } } return s ? (d.res = p, d.usedParams = this.getUsedParamsDetails(r), d) : p } extendTranslation(e, t, n, r, s) { var i, o; if (null == (i = this.i18nFormat) ? void 0 : i.parse) e = this.i18nFormat.parse(e, { ...this.options.interpolation.defaultVariables, ...n }, n.lng || this.language || r.usedLng, r.usedNS, r.usedKey, { resolved: r }); else if (!n.skipInterpolation) { n.interpolation && this.interpolator.init({ ...n, interpolation: { ...this.options.interpolation, ...n.interpolation } }); const i = vt(e) && (void 0 !== (null == (o = null == n ? void 0 : n.interpolation) ? void 0 : o.skipOnVariables) ? n.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables); let a; if (i) { const t = e.match(this.interpolator.nestingRegexp); a = t && t.length } let l = n.replace && !vt(n.replace) ? n.replace : n; if (this.options.interpolation.defaultVariables && (l = { ...this.options.interpolation.defaultVariables, ...l }), e = this.interpolator.interpolate(e, l, n.lng || this.language || r.usedLng, n), i) { const t = e.match(this.interpolator.nestingRegexp); a < (t && t.length) && (n.nest = !1) } !n.lng && r && r.res && (n.lng = this.language || r.usedLng), !1 !== n.nest && (e = this.interpolator.nest(e, (...e) => (null == s ? void 0 : s[0]) !== e[0] || n.context ? this.translate(...e, t) : (this.logger.warn(`It seems you are nesting recursively key: ${e[0]} in key: ${t[0]}`), null), n)), n.interpolation && this.interpolator.reset() } const a = n.postProcess || this.options.postProcess, l = vt(a) ? [a] : a; return null != e && (null == l ? void 0 : l.length) && !1 !== n.applyPostProcessor && (e = Zt.handle(l, e, t, this.options && this.options.postProcessPassResolved ? { i18nResolved: { ...r, usedParams: this.getUsedParamsDetails(n) }, ...n } : n, this)), e } resolve(e, t = {}) { let n, r, s, i, o; return vt(e) && (e = [e]), e.forEach(e => { if (this.isValidLookup(n)) return; const a = this.extractFromKey(e, t), l = a.key; r = l; let c = a.namespaces; this.options.fallbackNS && (c = c.concat(this.options.fallbackNS)); const u = void 0 !== t.count && !vt(t.count), h = u && !t.ordinal && 0 === t.count, d = void 0 !== t.context && (vt(t.context) || "number" == typeof t.context) && "" !== t.context, p = t.lngs ? t.lngs : this.languageUtils.toResolveHierarchy(t.lng || this.language, t.fallbackLng); c.forEach(e => { var a, c; this.isValidLookup(n) || (o = e, nn[`${p[0]}-${e}`] || !(null == (a = this.utils) ? void 0 : a.hasLoadedNamespace) || (null == (c = this.utils) ? void 0 : c.hasLoadedNamespace(o)) || (nn[`${p[0]}-${e}`] = !0, this.logger.warn(`key "${r}" for languages "${p.join(", ")}" won't get resolved as namespace "${o}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), p.forEach(r => { var o; if (this.isValidLookup(n)) return; i = r; const a = [l]; if (null == (o = this.i18nFormat) ? void 0 : o.addLookupKeys) this.i18nFormat.addLookupKeys(a, l, r, e, t); else { let e; u && (e = this.pluralResolver.getSuffix(r, t.count, t)); const n = `${this.options.pluralSeparator}zero`, s = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`; if (u && (t.ordinal && 0 === e.indexOf(s) && a.push(l + e.replace(s, this.options.pluralSeparator)), a.push(l + e), h && a.push(l + n)), d) { const r = `${l}${this.options.contextSeparator || "_"}${t.context}`; a.push(r), u && (t.ordinal && 0 === e.indexOf(s) && a.push(r + e.replace(s, this.options.pluralSeparator)), a.push(r + e), h && a.push(r + n)) } } let c; for (; c = a.pop();)this.isValidLookup(n) || (s = c, n = this.getResource(r, e, c, t)) })) }) }), { res: n, usedKey: r, exactUsedKey: s, usedLng: i, usedNS: o } } isValidLookup(e) { return !(void 0 === e || !this.options.returnNull && null === e || !this.options.returnEmptyString && "" === e) } getResource(e, t, n, r = {}) { var s; return (null == (s = this.i18nFormat) ? void 0 : s.getResource) ? this.i18nFormat.getResource(e, t, n, r) : this.resourceStore.getResource(e, t, n, r) } getUsedParamsDetails(e = {}) { const t = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], n = e.replace && !vt(e.replace); let r = n ? e.replace : e; if (n && void 0 !== e.count && (r.count = e.count), this.options.interpolation.defaultVariables && (r = { ...this.options.interpolation.defaultVariables, ...r }), !n) { r = { ...r }; for (const e of t) delete r[e] } return r } static hasDefaultValue(e) { for (const t in e) if (Object.prototype.hasOwnProperty.call(e, t) && "defaultValue" === t.substring(0, 12) && void 0 !== e[t]) return !0; return !1 } } class on { constructor(e) { this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Qt.create("languageUtils") } getScriptPartFromCode(e) { if (!(e = $t(e)) || e.indexOf("-") < 0) return null; const t = e.split("-"); return 2 === t.length ? null : (t.pop(), "x" === t[t.length - 1].toLowerCase() ? null : this.formatLanguageCode(t.join("-"))) } getLanguagePartFromCode(e) { if (!(e = $t(e)) || e.indexOf("-") < 0) return e; const t = e.split("-"); return this.formatLanguageCode(t[0]) } formatLanguageCode(e) { if (vt(e) && e.indexOf("-") > -1) { let t; try { t = Intl.getCanonicalLocales(e)[0] } catch (fg) { } return t && this.options.lowerCaseLng && (t = t.toLowerCase()), t || (this.options.lowerCaseLng ? e.toLowerCase() : e) } return this.options.cleanCode || this.options.lowerCaseLng ? e.toLowerCase() : e } isSupportedCode(e) { return ("languageOnly" === this.options.load || this.options.nonExplicitSupportedLngs) && (e = this.getLanguagePartFromCode(e)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e) > -1 } getBestMatchFromCodes(e) { if (!e) return null; let t; return e.forEach(e => { if (t) return; const n = this.formatLanguageCode(e); this.options.supportedLngs && !this.isSupportedCode(n) || (t = n) }), !t && this.options.supportedLngs && e.forEach(e => { if (t) return; const n = this.getScriptPartFromCode(e); if (this.isSupportedCode(n)) return t = n; const r = this.getLanguagePartFromCode(e); if (this.isSupportedCode(r)) return t = r; t = this.options.supportedLngs.find(e => e === r ? e : e.indexOf("-") < 0 && r.indexOf("-") < 0 ? void 0 : e.indexOf("-") > 0 && r.indexOf("-") < 0 && e.substring(0, e.indexOf("-")) === r || 0 === e.indexOf(r) && r.length > 1 ? e : void 0) }), t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]), t } getFallbackCodes(e, t) { if (!e) return []; if ("function" == typeof e && (e = e(t)), vt(e) && (e = [e]), Array.isArray(e)) return e; if (!t) return e.default || []; let n = e[t]; return n || (n = e[this.getScriptPartFromCode(t)]), n || (n = e[this.formatLanguageCode(t)]), n || (n = e[this.getLanguagePartFromCode(t)]), n || (n = e.default), n || [] } toResolveHierarchy(e, t) { const n = this.getFallbackCodes((!1 === t ? [] : t) || this.options.fallbackLng || [], e), r = [], s = e => { e && (this.isSupportedCode(e) ? r.push(e) : this.logger.warn(`rejecting language code not found in supportedLngs: ${e}`)) }; return vt(e) && (e.indexOf("-") > -1 || e.indexOf("_") > -1) ? ("languageOnly" !== this.options.load && s(this.formatLanguageCode(e)), "languageOnly" !== this.options.load && "currentOnly" !== this.options.load && s(this.getScriptPartFromCode(e)), "currentOnly" !== this.options.load && s(this.getLanguagePartFromCode(e))) : vt(e) && s(this.formatLanguageCode(e)), n.forEach(e => { r.indexOf(e) < 0 && s(this.formatLanguageCode(e)) }), r } } const an = { zero: 0, one: 1, two: 2, few: 3, many: 4, other: 5 }, ln = { select: e => 1 === e ? "one" : "other", resolvedOptions: () => ({ pluralCategories: ["one", "other"] }) }; class cn { constructor(e, t = {}) { this.languageUtils = e, this.options = t, this.logger = Qt.create("pluralResolver"), this.pluralRulesCache = {} } addRule(e, t) { this.rules[e] = t } clearCache() { this.pluralRulesCache = {} } getRule(e, t = {}) { const n = $t("dev" === e ? "en" : e), r = t.ordinal ? "ordinal" : "cardinal", s = JSON.stringify({ cleanedCode: n, type: r }); if (s in this.pluralRulesCache) return this.pluralRulesCache[s]; let i; try { i = new Intl.PluralRules(n, { type: r }) } catch (o) { if (!Intl) return this.logger.error("No Intl support, please use an Intl polyfill!"), ln; if (!e.match(/-|_/)) return ln; const n = this.languageUtils.getLanguagePartFromCode(e); i = this.getRule(n, t) } return this.pluralRulesCache[s] = i, i } needsPlural(e, t = {}) { let n = this.getRule(e, t); return n || (n = this.getRule("dev", t)), (null == n ? void 0 : n.resolvedOptions().pluralCategories.length) > 1 } getPluralFormsOfKey(e, t, n = {}) { return this.getSuffixes(e, n).map(e => `${t}${e}`) } getSuffixes(e, t = {}) { let n = this.getRule(e, t); return n || (n = this.getRule("dev", t)), n ? n.resolvedOptions().pluralCategories.sort((e, t) => an[e] - an[t]).map(e => `${this.options.prepend}${t.ordinal ? `ordinal${this.options.prepend}` : ""}${e}`) : [] } getSuffix(e, t, n = {}) { const r = this.getRule(e, n); return r ? `${this.options.prepend}${n.ordinal ? `ordinal${this.options.prepend}` : ""}${r.select(t)}` : (this.logger.warn(`no plural rule found for: ${e}`), this.getSuffix("dev", t, n)) } } const un = (e, t, n, r = ".", s = !0) => { let i = ((e, t, n) => { const r = Ut(e, n); return void 0 !== r ? r : Ut(t, n) })(e, t, n); return !i && s && vt(n) && (i = Vt(e, n, r), void 0 === i && (i = Vt(t, n, r))), i }, hn = e => e.replace(/\$/g, "$$$$"); class dn { constructor(e = {}) { var t; this.logger = Qt.create("interpolator"), this.options = e, this.format = (null == (t = null == e ? void 0 : e.interpolation) ? void 0 : t.format) || (e => e), this.init(e) } init(e = {}) { e.interpolation || (e.interpolation = { escapeValue: !0 }); const { escape: t, escapeValue: n, useRawValueToEscape: r, prefix: s, prefixEscaped: i, suffix: o, suffixEscaped: a, formatSeparator: l, unescapeSuffix: c, unescapePrefix: u, nestingPrefix: h, nestingPrefixEscaped: d, nestingSuffix: p, nestingSuffixEscaped: f, nestingOptionsSeparator: m, maxReplaces: g, alwaysFormat: E } = e.interpolation; this.escape = void 0 !== t ? t : zt, this.escapeValue = void 0 === n || n, this.useRawValueToEscape = void 0 !== r && r, this.prefix = s ? jt(s) : i || "{{", this.suffix = o ? jt(o) : a || "}}", this.formatSeparator = l || ",", this.unescapePrefix = c ? "" : u || "-", this.unescapeSuffix = this.unescapePrefix ? "" : c || "", this.nestingPrefix = h ? jt(h) : d || jt("$t("), this.nestingSuffix = p ? jt(p) : f || jt(")"), this.nestingOptionsSeparator = m || ",", this.maxReplaces = g || 1e3, this.alwaysFormat = void 0 !== E && E, this.resetRegExp() } reset() { this.options && this.init(this.options) } resetRegExp() { const e = (e, t) => (null == e ? void 0 : e.source) === t ? (e.lastIndex = 0, e) : new RegExp(t, "g"); this.regexp = e(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = e(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = e(this.nestingRegexp, `${this.nestingPrefix}((?:[^()"']+|"[^"]*"|'[^']*'|\\((?:[^()]|"[^"]*"|'[^']*')*\\))*?)${this.nestingSuffix}`) } interpolate(e, t, n, r) { var s; let i, o, a; const l = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}, c = e => { if (e.indexOf(this.formatSeparator) < 0) { const s = un(t, l, e, this.options.keySeparator, this.options.ignoreJSONStructure); return this.alwaysFormat ? this.format(s, void 0, n, { ...r, ...t, interpolationkey: e }) : s } const s = e.split(this.formatSeparator), i = s.shift().trim(), o = s.join(this.formatSeparator).trim(); return this.format(un(t, l, i, this.options.keySeparator, this.options.ignoreJSONStructure), o, n, { ...r, ...t, interpolationkey: i }) }; this.resetRegExp(); const u = (null == r ? void 0 : r.missingInterpolationHandler) || this.options.missingInterpolationHandler, h = void 0 !== (null == (s = null == r ? void 0 : r.interpolation) ? void 0 : s.skipOnVariables) ? r.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables; return [{ regex: this.regexpUnescape, safeValue: e => hn(e) }, { regex: this.regexp, safeValue: e => this.escapeValue ? hn(this.escape(e)) : hn(e) }].forEach(t => { for (a = 0; i = t.regex.exec(e);) { const n = i[1].trim(); if (o = c(n), void 0 === o) if ("function" == typeof u) { const t = u(e, i, r); o = vt(t) ? t : "" } else if (r && Object.prototype.hasOwnProperty.call(r, n)) o = ""; else { if (h) { o = i[0]; continue } this.logger.warn(`missed to pass in variable ${n} for interpolating ${e}`), o = "" } else vt(o) || this.useRawValueToEscape || (o = Lt(o)); const s = t.safeValue(o); if (e = e.replace(i[0], s), h ? (t.regex.lastIndex += o.length, t.regex.lastIndex -= i[0].length) : t.regex.lastIndex = 0, a++, a >= this.maxReplaces) break } }), e } nest(e, t, n = {}) { let r, s, i; const o = (e, t) => { const n = this.nestingOptionsSeparator; if (e.indexOf(n) < 0) return e; const r = e.split(new RegExp(`${n}[ ]*{`)); let s = `{${r[1]}`; e = r[0], s = this.interpolate(s, i); const o = s.match(/'/g), a = s.match(/"/g); (((null == o ? void 0 : o.length) ?? 0) % 2 == 0 && !a || a.length % 2 != 0) && (s = s.replace(/'/g, '"')); try { i = JSON.parse(s), t && (i = { ...t, ...i }) } catch (fg) { return this.logger.warn(`failed parsing options string in nesting for key ${e}`, fg), `${e}${n}${s}` } return i.defaultValue && i.defaultValue.indexOf(this.prefix) > -1 && delete i.defaultValue, e }; for (; r = this.nestingRegexp.exec(e);) { let a = []; i = { ...n }, i = i.replace && !vt(i.replace) ? i.replace : i, i.applyPostProcessor = !1, delete i.defaultValue; const l = /{.*}/.test(r[1]) ? r[1].lastIndexOf("}") + 1 : r[1].indexOf(this.formatSeparator); if (-1 !== l && (a = r[1].slice(l).split(this.formatSeparator).map(e => e.trim()).filter(Boolean), r[1] = r[1].slice(0, l)), s = t(o.call(this, r[1].trim(), i), i), s && r[0] === e && !vt(s)) return s; vt(s) || (s = Lt(s)), s || (this.logger.warn(`missed to resolve ${r[1]} for nesting ${e}`), s = ""), a.length && (s = a.reduce((e, t) => this.format(e, t, n.lng, { ...n, interpolationkey: r[1].trim() }), s.trim())), e = e.replace(r[0], s), this.regexp.lastIndex = 0 } return e } } const pn = e => { const t = {}; return (n, r, s) => { let i = s; s && s.interpolationkey && s.formatParams && s.formatParams[s.interpolationkey] && s[s.interpolationkey] && (i = { ...i, [s.interpolationkey]: void 0 }); const o = r + JSON.stringify(i); let a = t[o]; return a || (a = e($t(r), s), t[o] = a), a(n) } }, fn = e => (t, n, r) => e($t(n), r)(t); class mn { constructor(e = {}) { this.logger = Qt.create("formatter"), this.options = e, this.init(e) } init(e, t = { interpolation: {} }) { this.formatSeparator = t.interpolation.formatSeparator || ","; const n = t.cacheInBuiltFormats ? pn : fn; this.formats = { number: n((e, t) => { const n = new Intl.NumberFormat(e, { ...t }); return e => n.format(e) }), currency: n((e, t) => { const n = new Intl.NumberFormat(e, { ...t, style: "currency" }); return e => n.format(e) }), datetime: n((e, t) => { const n = new Intl.DateTimeFormat(e, { ...t }); return e => n.format(e) }), relativetime: n((e, t) => { const n = new Intl.RelativeTimeFormat(e, { ...t }); return e => n.format(e, t.range || "day") }), list: n((e, t) => { const n = new Intl.ListFormat(e, { ...t }); return e => n.format(e) }) } } add(e, t) { this.formats[e.toLowerCase().trim()] = t } addCached(e, t) { this.formats[e.toLowerCase().trim()] = pn(t) } format(e, t, n, r = {}) { const s = t.split(this.formatSeparator); if (s.length > 1 && s[0].indexOf("(") > 1 && s[0].indexOf(")") < 0 && s.find(e => e.indexOf(")") > -1)) { const e = s.findIndex(e => e.indexOf(")") > -1); s[0] = [s[0], ...s.splice(1, e)].join(this.formatSeparator) } return s.reduce((e, t) => { var s; const { formatName: i, formatOptions: o } = (e => { let t = e.toLowerCase().trim(); const n = {}; if (e.indexOf("(") > -1) { const r = e.split("("); t = r[0].toLowerCase().trim(); const s = r[1].substring(0, r[1].length - 1); "currency" === t && s.indexOf(":") < 0 ? n.currency || (n.currency = s.trim()) : "relativetime" === t && s.indexOf(":") < 0 ? n.range || (n.range = s.trim()) : s.split(";").forEach(e => { if (e) { const [t, ...r] = e.split(":"), s = r.join(":").trim().replace(/^'+|'+$/g, ""), i = t.trim(); n[i] || (n[i] = s), "false" === s && (n[i] = !1), "true" === s && (n[i] = !0), isNaN(s) || (n[i] = parseInt(s, 10)) } }) } return { formatName: t, formatOptions: n } })(t); if (this.formats[i]) { let t = e; try { const a = (null == (s = null == r ? void 0 : r.formatParams) ? void 0 : s[r.interpolationkey]) || {}, l = a.locale || a.lng || r.locale || r.lng || n; t = this.formats[i](e, l, { ...o, ...r, ...a }) } catch (a) { this.logger.warn(a) } return t } return this.logger.warn(`there was no format function for ${i}`), e }, e) } } class gn extends Xt { constructor(e, t, n, r = {}) { var s, i; super(), this.backend = e, this.store = t, this.services = n, this.languageUtils = n.languageUtils, this.options = r, this.logger = Qt.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = r.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = r.maxRetries >= 0 ? r.maxRetries : 5, this.retryTimeout = r.retryTimeout >= 1 ? r.retryTimeout : 350, this.state = {}, this.queue = [], null == (i = null == (s = this.backend) ? void 0 : s.init) || i.call(s, n, r.backend, r) } queueLoad(e, t, n, r) { const s = {}, i = {}, o = {}, a = {}; return e.forEach(e => { let r = !0; t.forEach(t => { const o = `${e}|${t}`; !n.reload && this.store.hasResourceBundle(e, t) ? this.state[o] = 2 : this.state[o] < 0 || (1 === this.state[o] ? void 0 === i[o] && (i[o] = !0) : (this.state[o] = 1, r = !1, void 0 === i[o] && (i[o] = !0), void 0 === s[o] && (s[o] = !0), void 0 === a[t] && (a[t] = !0))) }), r || (o[e] = !0) }), (Object.keys(s).length || Object.keys(i).length) && this.queue.push({ pending: i, pendingCount: Object.keys(i).length, loaded: {}, errors: [], callback: r }), { toLoad: Object.keys(s), pending: Object.keys(i), toLoadLanguages: Object.keys(o), toLoadNamespaces: Object.keys(a) } } loaded(e, t, n) { const r = e.split("|"), s = r[0], i = r[1]; t && this.emit("failedLoading", s, i, t), !t && n && this.store.addResourceBundle(s, i, n, void 0, void 0, { skipCopy: !0 }), this.state[e] = t ? -1 : 2, t && n && (this.state[e] = 0); const o = {}; this.queue.forEach(n => { ((e, t, n) => { const { obj: r, k: s } = Ft(e, t, Object); r[s] = r[s] || [], r[s].push(n) })(n.loaded, [s], i), ((e, t) => { void 0 !== e.pending[t] && (delete e.pending[t], e.pendingCount--) })(n, e), t && n.errors.push(t), 0 !== n.pendingCount || n.done || (Object.keys(n.loaded).forEach(e => { o[e] || (o[e] = {}); const t = n.loaded[e]; t.length && t.forEach(t => { void 0 === o[e][t] && (o[e][t] = !0) }) }), n.done = !0, n.errors.length ? n.callback(n.errors) : n.callback()) }), this.emit("loaded", o), this.queue = this.queue.filter(e => !e.done) } read(e, t, n, r = 0, s = this.retryTimeout, i) { if (!e.length) return i(null, {}); if (this.readingCalls >= this.maxParallelReads) return void this.waitingReads.push({ lng: e, ns: t, fcName: n, tried: r, wait: s, callback: i }); this.readingCalls++; const o = (o, a) => { if (this.readingCalls--, this.waitingReads.length > 0) { const e = this.waitingReads.shift(); this.read(e.lng, e.ns, e.fcName, e.tried, e.wait, e.callback) } o && a && r < this.maxRetries ? setTimeout(() => { this.read.call(this, e, t, n, r + 1, 2 * s, i) }, s) : i(o, a) }, a = this.backend[n].bind(this.backend); if (2 !== a.length) return a(e, t, o); try { const n = a(e, t); n && "function" == typeof n.then ? n.then(e => o(null, e)).catch(o) : o(null, n) } catch (l) { o(l) } } prepareLoading(e, t, n = {}, r) { if (!this.backend) return this.logger.warn("No backend was added via i18next.use. Will not load resources."), r && r(); vt(e) && (e = this.languageUtils.toResolveHierarchy(e)), vt(t) && (t = [t]); const s = this.queueLoad(e, t, n, r); if (!s.toLoad.length) return s.pending.length || r(), null; s.toLoad.forEach(e => { this.loadOne(e) }) } load(e, t, n) { this.prepareLoading(e, t, {}, n) } reload(e, t, n) { this.prepareLoading(e, t, { reload: !0 }, n) } loadOne(e, t = "") { const n = e.split("|"), r = n[0], s = n[1]; this.read(r, s, "read", void 0, void 0, (n, i) => { n && this.logger.warn(`${t}loading namespace ${s} for language ${r} failed`, n), !n && i && this.logger.log(`${t}loaded namespace ${s} for language ${r}`, i), this.loaded(e, n, i) }) } saveMissing(e, t, n, r, s, i = {}, o = () => { }) { var a, l, c, u, h; if (!(null == (l = null == (a = this.services) ? void 0 : a.utils) ? void 0 : l.hasLoadedNamespace) || (null == (u = null == (c = this.services) ? void 0 : c.utils) ? void 0 : u.hasLoadedNamespace(t))) { if (null != n && "" !== n) { if (null == (h = this.backend) ? void 0 : h.create) { const a = { ...i, isUpdate: s }, l = this.backend.create.bind(this.backend); if (l.length < 6) try { let s; s = 5 === l.length ? l(e, t, n, r, a) : l(e, t, n, r), s && "function" == typeof s.then ? s.then(e => o(null, e)).catch(o) : o(null, s) } catch (d) { o(d) } else l(e, t, n, r, o, a) } e && e[0] && this.store.addResource(e[0], t, n, r) } } else this.logger.warn(`did not save key "${n}" as the namespace "${t}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!") } } const En = () => ({ debug: !1, initAsync: !0, ns: ["translation"], defaultNS: ["translation"], fallbackLng: ["dev"], fallbackNS: !1, supportedLngs: !1, nonExplicitSupportedLngs: !1, load: "all", preload: !1, simplifyPluralSuffix: !0, keySeparator: ".", nsSeparator: ":", pluralSeparator: "_", contextSeparator: "_", partialBundledLanguages: !1, saveMissing: !1, updateMissing: !1, saveMissingTo: "fallback", saveMissingPlurals: !0, missingKeyHandler: !1, missingInterpolationHandler: !1, postProcess: !1, postProcessPassResolved: !1, returnNull: !1, returnEmptyString: !0, returnObjects: !1, joinArrays: !1, returnedObjectHandler: !1, parseMissingKeyHandler: !1, appendNamespaceToMissingKey: !1, appendNamespaceToCIMode: !1, overloadTranslationOptionHandler: e => { let t = {}; if ("object" == typeof e[1] && (t = e[1]), vt(e[1]) && (t.defaultValue = e[1]), vt(e[2]) && (t.tDescription = e[2]), "object" == typeof e[2] || "object" == typeof e[3]) { const n = e[3] || e[2]; Object.keys(n).forEach(e => { t[e] = n[e] }) } return t }, interpolation: { escapeValue: !0, format: e => e, prefix: "{{", suffix: "}}", formatSeparator: ",", unescapePrefix: "-", nestingPrefix: "$t(", nestingSuffix: ")", nestingOptionsSeparator: ",", maxReplaces: 1e3, skipOnVariables: !0 }, cacheInBuiltFormats: !0 }), Tn = e => { var t, n; return vt(e.ns) && (e.ns = [e.ns]), vt(e.fallbackLng) && (e.fallbackLng = [e.fallbackLng]), vt(e.fallbackNS) && (e.fallbackNS = [e.fallbackNS]), (null == (n = null == (t = e.supportedLngs) ? void 0 : t.indexOf) ? void 0 : n.call(t, "cimode")) < 0 && (e.supportedLngs = e.supportedLngs.concat(["cimode"])), "boolean" == typeof e.initImmediate && (e.initAsync = e.initImmediate), e }, An = () => { }; class _n extends Xt { constructor(e = {}, t) { var n; if (super(), this.options = Tn(e), this.services = {}, this.logger = Qt, this.modules = { external: [] }, n = this, Object.getOwnPropertyNames(Object.getPrototypeOf(n)).forEach(e => { "function" == typeof n[e] && (n[e] = n[e].bind(n)) }), t && !this.isInitialized && !e.isClone) { if (!this.options.initAsync) return this.init(e, t), this; setTimeout(() => { this.init(e, t) }, 0) } } init(e = {}, t) { this.isInitializing = !0, "function" == typeof e && (t = e, e = {}), null == e.defaultNS && e.ns && (vt(e.ns) ? e.defaultNS = e.ns : e.ns.indexOf("translation") < 0 && (e.defaultNS = e.ns[0])); const n = En(); this.options = { ...n, ...this.options, ...Tn(e) }, this.options.interpolation = { ...n.interpolation, ...this.options.interpolation }, void 0 !== e.keySeparator && (this.options.userDefinedKeySeparator = e.keySeparator), void 0 !== e.nsSeparator && (this.options.userDefinedNsSeparator = e.nsSeparator), "function" != typeof this.options.overloadTranslationOptionHandler && (this.options.overloadTranslationOptionHandler = n.overloadTranslationOptionHandler); const r = e => e ? "function" == typeof e ? new e : e : null; if (!this.options.isClone) { let e; this.modules.logger ? Qt.init(r(this.modules.logger), this.options) : Qt.init(null, this.options), e = this.modules.formatter ? this.modules.formatter : mn; const t = new on(this.options); this.store = new Jt(this.options.resources, this.options); const s = this.services; s.logger = Qt, s.resourceStore = this.store, s.languageUtils = t, s.pluralResolver = new cn(t, { prepend: this.options.pluralSeparator, simplifyPluralSuffix: this.options.simplifyPluralSuffix }), this.options.interpolation.format && this.options.interpolation.format !== n.interpolation.format && this.logger.deprecate("init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting"), !e || this.options.interpolation.format && this.options.interpolation.format !== n.interpolation.format || (s.formatter = r(e), s.formatter.init && s.formatter.init(s, this.options), this.options.interpolation.format = s.formatter.format.bind(s.formatter)), s.interpolator = new dn(this.options), s.utils = { hasLoadedNamespace: this.hasLoadedNamespace.bind(this) }, s.backendConnector = new gn(r(this.modules.backend), s.resourceStore, s, this.options), s.backendConnector.on("*", (e, ...t) => { this.emit(e, ...t) }), this.modules.languageDetector && (s.languageDetector = r(this.modules.languageDetector), s.languageDetector.init && s.languageDetector.init(s, this.options.detection, this.options)), this.modules.i18nFormat && (s.i18nFormat = r(this.modules.i18nFormat), s.i18nFormat.init && s.i18nFormat.init(this)), this.translator = new sn(this.services, this.options), this.translator.on("*", (e, ...t) => { this.emit(e, ...t) }), this.modules.external.forEach(e => { e.init && e.init(this) }) } if (this.format = this.options.interpolation.format, t || (t = An), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) { const e = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng); e.length > 0 && "dev" !== e[0] && (this.options.lng = e[0]) } this.services.languageDetector || this.options.lng || this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach(e => { this[e] = (...t) => this.store[e](...t) }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach(e => { this[e] = (...t) => (this.store[e](...t), this) }); const s = Dt(), i = () => { const e = (e, n) => { this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), s.resolve(n), t(e, n) }; if (this.languages && !this.isInitialized) return e(null, this.t.bind(this)); this.changeLanguage(this.options.lng, e) }; return this.options.resources || !this.options.initAsync ? i() : setTimeout(i, 0), s } loadResources(e, t = An) { var n, r; let s = t; const i = vt(e) ? e : this.language; if ("function" == typeof e && (s = e), !this.options.resources || this.options.partialBundledLanguages) { if ("cimode" === (null == i ? void 0 : i.toLowerCase()) && (!this.options.preload || 0 === this.options.preload.length)) return s(); const e = [], t = t => { t && "cimode" !== t && this.services.languageUtils.toResolveHierarchy(t).forEach(t => { "cimode" !== t && e.indexOf(t) < 0 && e.push(t) }) }; i ? t(i) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(e => t(e)), null == (r = null == (n = this.options.preload) ? void 0 : n.forEach) || r.call(n, e => t(e)), this.services.backendConnector.load(e, this.options.ns, e => { e || this.resolvedLanguage || !this.language || this.setResolvedLanguage(this.language), s(e) }) } else s(null) } reloadResources(e, t, n) { const r = Dt(); return "function" == typeof e && (n = e, e = void 0), "function" == typeof t && (n = t, t = void 0), e || (e = this.languages), t || (t = this.options.ns), n || (n = An), this.services.backendConnector.reload(e, t, e => { r.resolve(), n(e) }), r } use(e) { if (!e) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()"); if (!e.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()"); return "backend" === e.type && (this.modules.backend = e), ("logger" === e.type || e.log && e.warn && e.error) && (this.modules.logger = e), "languageDetector" === e.type && (this.modules.languageDetector = e), "i18nFormat" === e.type && (this.modules.i18nFormat = e), "postProcessor" === e.type && Zt.addPostProcessor(e), "formatter" === e.type && (this.modules.formatter = e), "3rdParty" === e.type && this.modules.external.push(e), this } setResolvedLanguage(e) { if (e && this.languages && !(["cimode", "dev"].indexOf(e) > -1)) { for (let e = 0; e < this.languages.length; e++) { const t = this.languages[e]; if (!(["cimode", "dev"].indexOf(t) > -1) && this.store.hasLanguageSomeTranslations(t)) { this.resolvedLanguage = t; break } } !this.resolvedLanguage && this.languages.indexOf(e) < 0 && this.store.hasLanguageSomeTranslations(e) && (this.resolvedLanguage = e, this.languages.unshift(e)) } } changeLanguage(e, t) { this.isLanguageChangingTo = e; const n = Dt(); this.emit("languageChanging", e); const r = e => { this.language = e, this.languages = this.services.languageUtils.toResolveHierarchy(e), this.resolvedLanguage = void 0, this.setResolvedLanguage(e) }, s = (s, i) => { i ? this.isLanguageChangingTo === e && (r(i), this.translator.changeLanguage(i), this.isLanguageChangingTo = void 0, this.emit("languageChanged", i), this.logger.log("languageChanged", i)) : this.isLanguageChangingTo = void 0, n.resolve((...e) => this.t(...e)), t && t(s, (...e) => this.t(...e)) }, i = t => { var n, i; e || t || !this.services.languageDetector || (t = []); const o = vt(t) ? t : t && t[0], a = this.store.hasLanguageSomeTranslations(o) ? o : this.services.languageUtils.getBestMatchFromCodes(vt(t) ? [t] : t); a && (this.language || r(a), this.translator.language || this.translator.changeLanguage(a), null == (i = null == (n = this.services.languageDetector) ? void 0 : n.cacheUserLanguage) || i.call(n, a)), this.loadResources(a, e => { s(e, a) }) }; return e || !this.services.languageDetector || this.services.languageDetector.async ? !e && this.services.languageDetector && this.services.languageDetector.async ? 0 === this.services.languageDetector.detect.length ? this.services.languageDetector.detect().then(i) : this.services.languageDetector.detect(i) : i(e) : i(this.services.languageDetector.detect()), n } getFixedT(e, t, n) { const r = (e, t, ...s) => { let i; i = "object" != typeof t ? this.options.overloadTranslationOptionHandler([e, t].concat(s)) : { ...t }, i.lng = i.lng || r.lng, i.lngs = i.lngs || r.lngs, i.ns = i.ns || r.ns, "" !== i.keyPrefix && (i.keyPrefix = i.keyPrefix || n || r.keyPrefix); const o = this.options.keySeparator || "."; let a; return i.keyPrefix && Array.isArray(e) ? a = e.map(e => ("function" == typeof e && (e = tn(e, { ...this.options, ...t })), `${i.keyPrefix}${o}${e}`)) : ("function" == typeof e && (e = tn(e, { ...this.options, ...t })), a = i.keyPrefix ? `${i.keyPrefix}${o}${e}` : e), this.t(a, i) }; return vt(e) ? r.lng = e : r.lngs = e, r.ns = t, r.keyPrefix = n, r } t(...e) { var t; return null == (t = this.translator) ? void 0 : t.translate(...e) } exists(...e) { var t; return null == (t = this.translator) ? void 0 : t.exists(...e) } setDefaultNamespace(e) { this.options.defaultNS = e } hasLoadedNamespace(e, t = {}) { if (!this.isInitialized) return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1; if (!this.languages || !this.languages.length) return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1; const n = t.lng || this.resolvedLanguage || this.languages[0], r = !!this.options && this.options.fallbackLng, s = this.languages[this.languages.length - 1]; if ("cimode" === n.toLowerCase()) return !0; const i = (e, t) => { const n = this.services.backendConnector.state[`${e}|${t}`]; return -1 === n || 0 === n || 2 === n }; if (t.precheck) { const e = t.precheck(this, i); if (void 0 !== e) return e } return !(!this.hasResourceBundle(n, e) && this.services.backendConnector.backend && (!this.options.resources || this.options.partialBundledLanguages) && (!i(n, e) || r && !i(s, e))) } loadNamespaces(e, t) { const n = Dt(); return this.options.ns ? (vt(e) && (e = [e]), e.forEach(e => { this.options.ns.indexOf(e) < 0 && this.options.ns.push(e) }), this.loadResources(e => { n.resolve(), t && t(e) }), n) : (t && t(), Promise.resolve()) } loadLanguages(e, t) { const n = Dt(); vt(e) && (e = [e]); const r = this.options.preload || [], s = e.filter(e => r.indexOf(e) < 0 && this.services.languageUtils.isSupportedCode(e)); return s.length ? (this.options.preload = r.concat(s), this.loadResources(e => { n.resolve(), t && t(e) }), n) : (t && t(), Promise.resolve()) } dir(e) { var t, n; if (e || (e = this.resolvedLanguage || ((null == (t = this.languages) ? void 0 : t.length) > 0 ? this.languages[0] : this.language)), !e) return "rtl"; try { const t = new Intl.Locale(e); if (t && t.getTextInfo) { const e = t.getTextInfo(); if (e && e.direction) return e.direction } } catch (fg) { } const r = (null == (n = this.services) ? void 0 : n.languageUtils) || new on(En()); return e.toLowerCase().indexOf("-latn") > 1 ? "ltr" : ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"].indexOf(r.getLanguagePartFromCode(e)) > -1 || e.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr" } static createInstance(e = {}, t) { const n = new _n(e, t); return n.createInstance = _n.createInstance, n } cloneInstance(e = {}, t = An) { const n = e.forkResourceStore; n && delete e.forkResourceStore; const r = { ...this.options, ...e, isClone: !0 }, s = new _n(r); if (void 0 === e.debug && void 0 === e.prefix || (s.logger = s.logger.clone(e)), ["store", "services", "language"].forEach(e => { s[e] = this[e] }), s.services = { ...this.services }, s.services.utils = { hasLoadedNamespace: s.hasLoadedNamespace.bind(s) }, n) { const e = Object.keys(this.store.data).reduce((e, t) => (e[t] = { ...this.store.data[t] }, e[t] = Object.keys(e[t]).reduce((n, r) => (n[r] = { ...e[t][r] }, n), e[t]), e), {}); s.store = new Jt(e, r), s.services.resourceStore = s.store } return e.interpolation && (s.services.interpolator = new dn(r)), s.translator = new sn(s.services, r), s.translator.on("*", (e, ...t) => { s.emit(e, ...t) }), s.init(r, t), s.translator.options = r, s.translator.backendConnector.services.utils = { hasLoadedNamespace: s.hasLoadedNamespace.bind(s) }, s } toJSON() { return { options: this.options, store: this.store, language: this.language, languages: this.languages, resolvedLanguage: this.resolvedLanguage } } } const yn = _n.createInstance(); yn.createInstance, yn.dir, yn.init, yn.loadResources, yn.reloadResources, yn.use, yn.changeLanguage, yn.getFixedT, yn.t, yn.exists, yn.setDefaultNamespace, yn.hasLoadedNamespace, yn.loadNamespaces, yn.loadLanguages; const bn = {}, Sn = (e, t, n, r) => { In(n) && bn[n] || (In(n) && (bn[n] = new Date), ((e, t, n, r) => { var s, i, o, a; const l = [n, { code: t, ...r || {} }]; if (null == (i = null == (s = null == e ? void 0 : e.services) ? void 0 : s.logger) ? void 0 : i.forward) return e.services.logger.forward(l, "warn", "react-i18next::", !0); In(l[0]) && (l[0] = `react-i18next:: ${l[0]}`), (null == (a = null == (o = null == e ? void 0 : e.services) ? void 0 : o.logger) ? void 0 : a.warn) ? e.services.logger.warn(...l) : null == console || console.warn })(e, t, n, r)) }, kn = (e, t) => () => { if (e.isInitialized) t(); else { const n = () => { setTimeout(() => { e.off("initialized", n) }, 0), t() }; e.on("initialized", n) } }, Cn = (e, t, n) => { e.loadNamespaces(t, kn(e, n)) }, Nn = (e, t, n, r) => { if (In(n) && (n = [n]), e.options.preload && e.options.preload.indexOf(t) > -1) return Cn(e, n, r); n.forEach(t => { e.options.ns.indexOf(t) < 0 && e.options.ns.push(t) }), e.loadLanguages(t, kn(e, r)) }, In = e => "string" == typeof e, On = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g, xn = { "&amp;": "&", "&#38;": "&", "&lt;": "<", "&#60;": "<", "&gt;": ">", "&#62;": ">", "&apos;": "'", "&#39;": "'", "&quot;": '"', "&#34;": '"', "&nbsp;": " ", "&#160;": " ", "&copy;": "", "&#169;": "", "&reg;": "", "&#174;": "", "&hellip;": "", "&#8230;": "", "&#x2F;": "/", "&#47;": "/" }, Rn = e => xn[e]; let vn, Dn = { bindI18n: "languageChanged", bindI18nStore: "", transEmptyNodeValue: "", transSupportBasicHtmlNodes: !0, transWrapTextNodes: "", transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"], useSuspense: !0, unescape: e => e.replace(On, Rn), transDefaultProps: void 0 }; const Ln = { type: "3rdParty", init(e) { ((e = {}) => { Dn = { ...Dn, ...e } })(e.options.react), (e => { vn = e })(e) } }, Pn = React.createContext(); class wn { constructor() { this.usedNamespaces = {} } addUsedNamespaces(e) { e.forEach(e => { this.usedNamespaces[e] || (this.usedNamespaces[e] = !0) }) } getUsedNamespaces() { return Object.keys(this.usedNamespaces) } } var Mn = { exports: {} }, Fn = {}, Bn = l, Un = "function" == typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t }, Hn = Bn.useState, jn = Bn.useEffect, Gn = Bn.useLayoutEffect, zn = Bn.useDebugValue; function Yn(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !Un(e, n) } catch (r) { return !0 } } var qn = "undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement ? function (e, t) { return t() } : function (e, t) { var n = t(), r = Hn({ inst: { value: n, getSnapshot: t } }), s = r[0].inst, i = r[1]; return Gn(function () { s.value = n, s.getSnapshot = t, Yn(s) && i({ inst: s }) }, [e, n, t]), jn(function () { return Yn(s) && i({ inst: s }), e(function () { Yn(s) && i({ inst: s }) }) }, [e]), zn(n), n }; Fn.useSyncExternalStore = void 0 !== Bn.useSyncExternalStore ? Bn.useSyncExternalStore : qn, Mn.exports = Fn; var Vn = Mn.exports; const $n = { t: (e, t) => { return In(t) ? t : "object" == typeof (n = t) && null !== n && In(t.defaultValue) ? t.defaultValue : Array.isArray(e) ? e[e.length - 1] : e; var n }, ready: !1 }, Wn = () => () => { }, Kn = (e, t = {}) => { var n, r, s; const { i18n: i } = t, { i18n: o, defaultNS: a } = React.useContext(Pn) || {}, l = i || o || vn; l && !l.reportNamespaces && (l.reportNamespaces = new wn), l || Sn(l, "NO_I18NEXT_INSTANCE", "useTranslation: You will need to pass in an i18next instance by using initReactI18next"); const c = React.useMemo(() => { var e; return { ...Dn, ...null == (e = null == l ? void 0 : l.options) ? void 0 : e.react, ...t } }, [l, t]), { useSuspense: u, keyPrefix: h } = c, d = a || (null == (n = null == l ? void 0 : l.options) ? void 0 : n.defaultNS), p = In(d) ? [d] : d || ["translation"], f = React.useMemo(() => p, p); null == (s = null == (r = null == l ? void 0 : l.reportNamespaces) ? void 0 : r.addUsedNamespaces) || s.call(r, f); const m = React.useRef(0), g = React.useCallback(e => { if (!l) return Wn; const { bindI18n: t, bindI18nStore: n } = c, r = () => { m.current += 1, e() }; return t && l.on(t, r), n && l.store.on(n, r), () => { t && t.split(" ").forEach(e => l.off(e, r)), n && n.split(" ").forEach(e => l.store.off(e, r)) } }, [l, c]), E = React.useRef(), T = React.useCallback(() => { if (!l) return $n; const e = !(!l.isInitialized && !l.initializedStoreOnce) && f.every(e => ((e, t, n = {}) => t.languages && t.languages.length ? t.hasLoadedNamespace(e, { lng: n.lng, precheck: (t, r) => { if (n.bindI18n && n.bindI18n.indexOf("languageChanging") > -1 && t.services.backendConnector.backend && t.isLanguageChangingTo && !r(t.isLanguageChangingTo, e)) return !1 } }) : (Sn(t, "NO_LANGUAGES", "i18n.languages were undefined or empty", { languages: t.languages }), !0))(e, l, c)), n = t.lng || l.language, r = m.current, s = E.current; if (s && s.ready === e && s.lng === n && s.keyPrefix === h && s.revision === r) return s; const i = { t: l.getFixedT(n, "fallback" === c.nsMode ? f : f[0], h), ready: e, lng: n, keyPrefix: h, revision: r }; return E.current = i, i }, [l, f, h, c, t.lng]), [A, _] = React.useState(0), { t: y, ready: b } = Vn.useSyncExternalStore(g, T, T); React.useEffect(() => { if (l && !b && !u) { const e = () => _(e => e + 1); t.lng ? Nn(l, t.lng, f, e) : Cn(l, f, e) } }, [l, t.lng, f, b, u, A]); const S = l || {}, k = React.useRef(null), C = React.useRef(), N = e => { const t = Object.getOwnPropertyDescriptors(e); t.__original && delete t.__original; const n = Object.create(Object.getPrototypeOf(e), t); if (!Object.prototype.hasOwnProperty.call(n, "__original")) try { Object.defineProperty(n, "__original", { value: e, writable: !1, enumerable: !1, configurable: !1 }) } catch (r) { } return n }, I = React.useMemo(() => { const e = S, t = null == e ? void 0 : e.language; let n = e; e && (k.current && k.current.__original === e ? C.current !== t ? (n = N(e), k.current = n, C.current = t) : n = k.current : (n = N(e), k.current = n, C.current = t)); const r = [y, n, b]; return r.t = y, r.i18n = n, r.ready = b, r }, [y, S, b, S.resolvedLanguage, S.language, S.languages]); if (l && u && !b) throw new Promise(e => { const n = () => e(); t.lng ? Nn(l, t.lng, f, n) : Cn(l, f, n) }); return I }; function Qn(e, t) { return function () { return e.apply(t, arguments) } } const { toString: Xn } = Object.prototype, { getPrototypeOf: Jn } = Object, { iterator: Zn, toStringTag: er } = Symbol, tr = (e => t => { const n = Xn.call(t); return e[n] || (e[n] = n.slice(8, -1).toLowerCase()) })(Object.create(null)), nr = e => (e = e.toLowerCase(), t => tr(t) === e), rr = e => t => typeof t === e, { isArray: sr } = Array, ir = rr("undefined"); function or(e) { return null !== e && !ir(e) && null !== e.constructor && !ir(e.constructor) && cr(e.constructor.isBuffer) && e.constructor.isBuffer(e) } const ar = nr("ArrayBuffer"), lr = rr("string"), cr = rr("function"), ur = rr("number"), hr = e => null !== e && "object" == typeof e, dr = e => { if ("object" !== tr(e)) return !1; const t = Jn(e); return !(null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t) || er in e || Zn in e) }, pr = nr("Date"), fr = nr("File"), mr = nr("Blob"), gr = nr("FileList"), Er = nr("URLSearchParams"), [Tr, Ar, _r, yr] = ["ReadableStream", "Request", "Response", "Headers"].map(nr); function br(e, t, { allOwnKeys: n = !1 } = {}) { if (null == e) return; let r, s; if ("object" != typeof e && (e = [e]), sr(e)) for (r = 0, s = e.length; r < s; r++)t.call(null, e[r], r, e); else { if (or(e)) return; const s = n ? Object.getOwnPropertyNames(e) : Object.keys(e), i = s.length; let o; for (r = 0; r < i; r++)o = s[r], t.call(null, e[o], o, e) } } function Sr(e, t) { if (or(e)) return null; t = t.toLowerCase(); const n = Object.keys(e); let r, s = n.length; for (; s-- > 0;)if (r = n[s], t === r.toLowerCase()) return r; return null } const kr = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global, Cr = e => !ir(e) && e !== kr, Nr = (e => t => e && t instanceof e)("undefined" != typeof Uint8Array && Jn(Uint8Array)), Ir = nr("HTMLFormElement"), Or = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), xr = nr("RegExp"), Rr = (e, t) => { const n = Object.getOwnPropertyDescriptors(e), r = {}; br(n, (n, s) => { let i; !1 !== (i = t(n, s, e)) && (r[s] = i || n) }), Object.defineProperties(e, r) }, vr = nr("AsyncFunction"), Dr = (Lr = "function" == typeof setImmediate, Pr = cr(kr.postMessage), Lr ? setImmediate : Pr ? (wr = `axios@${Math.random()}`, Mr = [], kr.addEventListener("message", ({ source: e, data: t }) => { e === kr && t === wr && Mr.length && Mr.shift()() }, !1), e => { Mr.push(e), kr.postMessage(wr, "*") }) : e => setTimeout(e)); var Lr, Pr, wr, Mr; const Fr = "undefined" != typeof queueMicrotask ? queueMicrotask.bind(kr) : "undefined" != typeof process && process.nextTick || Dr, Br = { isArray: sr, isArrayBuffer: ar, isBuffer: or, isFormData: e => { let t; return e && ("function" == typeof FormData && e instanceof FormData || cr(e.append) && ("formdata" === (t = tr(e)) || "object" === t && cr(e.toString) && "[object FormData]" === e.toString())) }, isArrayBufferView: function (e) { let t; return t = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && ar(e.buffer), t }, isString: lr, isNumber: ur, isBoolean: e => !0 === e || !1 === e, isObject: hr, isPlainObject: dr, isEmptyObject: e => { if (!hr(e) || or(e)) return !1; try { return 0 === Object.keys(e).length && Object.getPrototypeOf(e) === Object.prototype } catch (fg) { return !1 } }, isReadableStream: Tr, isRequest: Ar, isResponse: _r, isHeaders: yr, isUndefined: ir, isDate: pr, isFile: fr, isBlob: mr, isRegExp: xr, isFunction: cr, isStream: e => hr(e) && cr(e.pipe), isURLSearchParams: Er, isTypedArray: Nr, isFileList: gr, forEach: br, merge: function e() { const { caseless: t, skipUndefined: n } = Cr(this) && this || {}, r = {}, s = (s, i) => { const o = t && Sr(r, i) || i; dr(r[o]) && dr(s) ? r[o] = e(r[o], s) : dr(s) ? r[o] = e({}, s) : sr(s) ? r[o] = s.slice() : n && ir(s) || (r[o] = s) }; for (let i = 0, o = arguments.length; i < o; i++)arguments[i] && br(arguments[i], s); return r }, extend: (e, t, n, { allOwnKeys: r } = {}) => (br(t, (t, r) => { n && cr(t) ? e[r] = Qn(t, n) : e[r] = t }, { allOwnKeys: r }), e), trim: e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM: e => (65279 === e.charCodeAt(0) && (e = e.slice(1)), e), inherits: (e, t, n, r) => { e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", { value: t.prototype }), n && Object.assign(e.prototype, n) }, toFlatObject: (e, t, n, r) => { let s, i, o; const a = {}; if (t = t || {}, null == e) return t; do { for (s = Object.getOwnPropertyNames(e), i = s.length; i-- > 0;)o = s[i], r && !r(o, e, t) || a[o] || (t[o] = e[o], a[o] = !0); e = !1 !== n && Jn(e) } while (e && (!n || n(e, t)) && e !== Object.prototype); return t }, kindOf: tr, kindOfTest: nr, endsWith: (e, t, n) => { e = String(e), (void 0 === n || n > e.length) && (n = e.length), n -= t.length; const r = e.indexOf(t, n); return -1 !== r && r === n }, toArray: e => { if (!e) return null; if (sr(e)) return e; let t = e.length; if (!ur(t)) return null; const n = new Array(t); for (; t-- > 0;)n[t] = e[t]; return n }, forEachEntry: (e, t) => { const n = (e && e[Zn]).call(e); let r; for (; (r = n.next()) && !r.done;) { const n = r.value; t.call(e, n[0], n[1]) } }, matchAll: (e, t) => { let n; const r = []; for (; null !== (n = e.exec(t));)r.push(n); return r }, isHTMLForm: Ir, hasOwnProperty: Or, hasOwnProp: Or, reduceDescriptors: Rr, freezeMethods: e => { Rr(e, (t, n) => { if (cr(e) && -1 !== ["arguments", "caller", "callee"].indexOf(n)) return !1; const r = e[n]; cr(r) && (t.enumerable = !1, "writable" in t ? t.writable = !1 : t.set || (t.set = () => { throw Error("Can not rewrite read-only method '" + n + "'") })) }) }, toObjectSet: (e, t) => { const n = {}, r = e => { e.forEach(e => { n[e] = !0 }) }; return sr(e) ? r(e) : r(String(e).split(t)), n }, toCamelCase: e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (e, t, n) { return t.toUpperCase() + n }), noop: () => { }, toFiniteNumber: (e, t) => null != e && Number.isFinite(e = +e) ? e : t, findKey: Sr, global: kr, isContextDefined: Cr, isSpecCompliantForm: function (e) { return !!(e && cr(e.append) && "FormData" === e[er] && e[Zn]) }, toJSONObject: e => { const t = new Array(10), n = (e, r) => { if (hr(e)) { if (t.indexOf(e) >= 0) return; if (or(e)) return e; if (!("toJSON" in e)) { t[r] = e; const s = sr(e) ? [] : {}; return br(e, (e, t) => { const i = n(e, r + 1); !ir(i) && (s[t] = i) }), t[r] = void 0, s } } return e }; return n(e, 0) }, isAsyncFn: vr, isThenable: e => e && (hr(e) || cr(e)) && cr(e.then) && cr(e.catch), setImmediate: Dr, asap: Fr, isIterable: e => null != e && cr(e[Zn]) }; function Ur(e, t, n, r, s) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), s && (this.response = s, this.status = s.status ? s.status : null) } Br.inherits(Ur, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: Br.toJSONObject(this.config), code: this.code, status: this.status } } }); const Hr = Ur.prototype, jr = {}; function Gr(e) { return Br.isPlainObject(e) || Br.isArray(e) } function zr(e) { return Br.endsWith(e, "[]") ? e.slice(0, -2) : e } function Yr(e, t, n) { return e ? e.concat(t).map(function (e, t) { return e = zr(e), !n && t ? "[" + e + "]" : e }).join(n ? "." : "") : t } ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e => { jr[e] = { value: e } }), Object.defineProperties(Ur, jr), Object.defineProperty(Hr, "isAxiosError", { value: !0 }), Ur.from = (e, t, n, r, s, i) => { const o = Object.create(Hr); Br.toFlatObject(e, o, function (e) { return e !== Error.prototype }, e => "isAxiosError" !== e); const a = e && e.message ? e.message : "Error", l = null == t && e ? e.code : t; return Ur.call(o, a, l, n, r, s), e && null == o.cause && Object.defineProperty(o, "cause", { value: e, configurable: !0 }), o.name = e && e.name || "Error", i && Object.assign(o, i), o }; const qr = Br.toFlatObject(Br, {}, null, function (e) { return /^is[A-Z]/.test(e) }); function Vr(e, t, n) { if (!Br.isObject(e)) throw new TypeError("target must be an object"); t = t || new FormData; const r = (n = Br.toFlatObject(n, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (e, t) { return !Br.isUndefined(t[e]) })).metaTokens, s = n.visitor || c, i = n.dots, o = n.indexes, a = (n.Blob || "undefined" != typeof Blob && Blob) && Br.isSpecCompliantForm(t); if (!Br.isFunction(s)) throw new TypeError("visitor must be a function"); function l(e) { if (null === e) return ""; if (Br.isDate(e)) return e.toISOString(); if (Br.isBoolean(e)) return e.toString(); if (!a && Br.isBlob(e)) throw new Ur("Blob is not supported. Use a Buffer instead."); return Br.isArrayBuffer(e) || Br.isTypedArray(e) ? a && "function" == typeof Blob ? new Blob([e]) : Buffer.from(e) : e } function c(e, n, s) { let a = e; if (e && !s && "object" == typeof e) if (Br.endsWith(n, "{}")) n = r ? n : n.slice(0, -2), e = JSON.stringify(e); else if (Br.isArray(e) && function (e) { return Br.isArray(e) && !e.some(Gr) }(e) || (Br.isFileList(e) || Br.endsWith(n, "[]")) && (a = Br.toArray(e))) return n = zr(n), a.forEach(function (e, r) { !Br.isUndefined(e) && null !== e && t.append(!0 === o ? Yr([n], r, i) : null === o ? n : n + "[]", l(e)) }), !1; return !!Gr(e) || (t.append(Yr(s, n, i), l(e)), !1) } const u = [], h = Object.assign(qr, { defaultVisitor: c, convertValue: l, isVisitable: Gr }); if (!Br.isObject(e)) throw new TypeError("data must be an object"); return function e(n, r) { if (!Br.isUndefined(n)) { if (-1 !== u.indexOf(n)) throw Error("Circular reference detected in " + r.join(".")); u.push(n), Br.forEach(n, function (n, i) { !0 === (!(Br.isUndefined(n) || null === n) && s.call(t, n, Br.isString(i) ? i.trim() : i, r, h)) && e(n, r ? r.concat(i) : [i]) }), u.pop() } }(e), t } function $r(e) { const t = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function (e) { return t[e] }) } function Wr(e, t) { this._pairs = [], e && Vr(e, this, t) } const Kr = Wr.prototype; function Qr(e) { return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+") } function Xr(e, t, n) { if (!t) return e; const r = n && n.encode || Qr; Br.isFunction(n) && (n = { serialize: n }); const s = n && n.serialize; let i; if (i = s ? s(t, n) : Br.isURLSearchParams(t) ? t.toString() : new Wr(t, n).toString(r), i) { const t = e.indexOf("#"); -1 !== t && (e = e.slice(0, t)), e += (-1 === e.indexOf("?") ? "?" : "&") + i } return e } Kr.append = function (e, t) { this._pairs.push([e, t]) }, Kr.toString = function (e) { const t = e ? function (t) { return e.call(this, t, $r) } : $r; return this._pairs.map(function (e) { return t(e[0]) + "=" + t(e[1]) }, "").join("&") }; class Jr { constructor() { this.handlers = [] } use(e, t, n) { return this.handlers.push({ fulfilled: e, rejected: t, synchronous: !!n && n.synchronous, runWhen: n ? n.runWhen : null }), this.handlers.length - 1 } eject(e) { this.handlers[e] && (this.handlers[e] = null) } clear() { this.handlers && (this.handlers = []) } forEach(e) { Br.forEach(this.handlers, function (t) { null !== t && e(t) }) } } const Zr = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, es = { isBrowser: !0, classes: { URLSearchParams: "undefined" != typeof URLSearchParams ? URLSearchParams : Wr, FormData: "undefined" != typeof FormData ? FormData : null, Blob: "undefined" != typeof Blob ? Blob : null }, protocols: ["http", "https", "file", "blob", "url", "data"] }, ts = "undefined" != typeof window && "undefined" != typeof document, ns = "object" == typeof navigator && navigator || void 0, rs = ts && (!ns || ["ReactNative", "NativeScript", "NS"].indexOf(ns.product) < 0), ss = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts, is = ts && window.location.href || "http://localhost", os = { ...Object.freeze(Object.defineProperty({ __proto__: null, hasBrowserEnv: ts, hasStandardBrowserEnv: rs, hasStandardBrowserWebWorkerEnv: ss, navigator: ns, origin: is }, Symbol.toStringTag, { value: "Module" })), ...es }; function as(e) { function t(e, n, r, s) { let i = e[s++]; if ("__proto__" === i) return !0; const o = Number.isFinite(+i), a = s >= e.length; return i = !i && Br.isArray(r) ? r.length : i, a ? (Br.hasOwnProp(r, i) ? r[i] = [r[i], n] : r[i] = n, !o) : (r[i] && Br.isObject(r[i]) || (r[i] = []), t(e, n, r[i], s) && Br.isArray(r[i]) && (r[i] = function (e) { const t = {}, n = Object.keys(e); let r; const s = n.length; let i; for (r = 0; r < s; r++)i = n[r], t[i] = e[i]; return t }(r[i])), !o) } if (Br.isFormData(e) && Br.isFunction(e.entries)) { const n = {}; return Br.forEachEntry(e, (e, r) => { t(function (e) { return Br.matchAll(/\w+|\[(\w*)]/g, e).map(e => "[]" === e[0] ? "" : e[1] || e[0]) }(e), r, n, 0) }), n } return null } const ls = { transitional: Zr, adapter: ["xhr", "http", "fetch"], transformRequest: [function (e, t) { const n = t.getContentType() || "", r = n.indexOf("application/json") > -1, s = Br.isObject(e); if (s && Br.isHTMLForm(e) && (e = new FormData(e)), Br.isFormData(e)) return r ? JSON.stringify(as(e)) : e; if (Br.isArrayBuffer(e) || Br.isBuffer(e) || Br.isStream(e) || Br.isFile(e) || Br.isBlob(e) || Br.isReadableStream(e)) return e; if (Br.isArrayBufferView(e)) return e.buffer; if (Br.isURLSearchParams(e)) return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString(); let i; if (s) { if (n.indexOf("application/x-www-form-urlencoded") > -1) return function (e, t) { return Vr(e, new os.classes.URLSearchParams, { visitor: function (e, t, n, r) { return os.isNode && Br.isBuffer(e) ? (this.append(t, e.toString("base64")), !1) : r.defaultVisitor.apply(this, arguments) }, ...t }) }(e, this.formSerializer).toString(); if ((i = Br.isFileList(e)) || n.indexOf("multipart/form-data") > -1) { const t = this.env && this.env.FormData; return Vr(i ? { "files[]": e } : e, t && new t, this.formSerializer) } } return s || r ? (t.setContentType("application/json", !1), function (e) { if (Br.isString(e)) try { return (0, JSON.parse)(e), Br.trim(e) } catch (fg) { if ("SyntaxError" !== fg.name) throw fg } return (0, JSON.stringify)(e) }(e)) : e }], transformResponse: [function (e) { const t = this.transitional || ls.transitional, n = t && t.forcedJSONParsing, r = "json" === this.responseType; if (Br.isResponse(e) || Br.isReadableStream(e)) return e; if (e && Br.isString(e) && (n && !this.responseType || r)) { const n = !(t && t.silentJSONParsing) && r; try { return JSON.parse(e, this.parseReviver) } catch (fg) { if (n) { if ("SyntaxError" === fg.name) throw Ur.from(fg, Ur.ERR_BAD_RESPONSE, this, null, this.response); throw fg } } } return e }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: os.classes.FormData, Blob: os.classes.Blob }, validateStatus: function (e) { return e >= 200 && e < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; Br.forEach(["delete", "get", "head", "post", "put", "patch"], e => { ls.headers[e] = {} }); const cs = Br.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), us = Symbol("internals"); function hs(e) { return e && String(e).trim().toLowerCase() } function ds(e) { return !1 === e || null == e ? e : Br.isArray(e) ? e.map(ds) : String(e) } function ps(e, t, n, r, s) { return Br.isFunction(r) ? r.call(this, t, n) : (s && (t = n), Br.isString(t) ? Br.isString(r) ? -1 !== t.indexOf(r) : Br.isRegExp(r) ? r.test(t) : void 0 : void 0) } let fs = class { constructor(e) { e && this.set(e) } set(e, t, n) { const r = this; function s(e, t, n) { const s = hs(t); if (!s) throw new Error("header name must be a non-empty string"); const i = Br.findKey(r, s); (!i || void 0 === r[i] || !0 === n || void 0 === n && !1 !== r[i]) && (r[i || t] = ds(e)) } const i = (e, t) => Br.forEach(e, (e, n) => s(e, n, t)); if (Br.isPlainObject(e) || e instanceof this.constructor) i(e, t); else if (Br.isString(e) && (e = e.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim())) i((e => { const t = {}; let n, r, s; return e && e.split("\n").forEach(function (e) { s = e.indexOf(":"), n = e.substring(0, s).trim().toLowerCase(), r = e.substring(s + 1).trim(), !n || t[n] && cs[n] || ("set-cookie" === n ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r) }), t })(e), t); else if (Br.isObject(e) && Br.isIterable(e)) { let n, r, s = {}; for (const t of e) { if (!Br.isArray(t)) throw TypeError("Object iterator must return a key-value pair"); s[r = t[0]] = (n = s[r]) ? Br.isArray(n) ? [...n, t[1]] : [n, t[1]] : t[1] } i(s, t) } else null != e && s(t, e, n); return this } get(e, t) { if (e = hs(e)) { const n = Br.findKey(this, e); if (n) { const e = this[n]; if (!t) return e; if (!0 === t) return function (e) { const t = Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let r; for (; r = n.exec(e);)t[r[1]] = r[2]; return t }(e); if (Br.isFunction(t)) return t.call(this, e, n); if (Br.isRegExp(t)) return t.exec(e); throw new TypeError("parser must be boolean|regexp|function") } } } has(e, t) { if (e = hs(e)) { const n = Br.findKey(this, e); return !(!n || void 0 === this[n] || t && !ps(0, this[n], n, t)) } return !1 } delete(e, t) { const n = this; let r = !1; function s(e) { if (e = hs(e)) { const s = Br.findKey(n, e); !s || t && !ps(0, n[s], s, t) || (delete n[s], r = !0) } } return Br.isArray(e) ? e.forEach(s) : s(e), r } clear(e) { const t = Object.keys(this); let n = t.length, r = !1; for (; n--;) { const s = t[n]; e && !ps(0, this[s], s, e, !0) || (delete this[s], r = !0) } return r } normalize(e) { const t = this, n = {}; return Br.forEach(this, (r, s) => { const i = Br.findKey(n, s); if (i) return t[i] = ds(r), void delete t[s]; const o = e ? function (e) { return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, n) => t.toUpperCase() + n) }(s) : String(s).trim(); o !== s && delete t[s], t[o] = ds(r), n[o] = !0 }), this } concat(...e) { return this.constructor.concat(this, ...e) } toJSON(e) { const t = Object.create(null); return Br.forEach(this, (n, r) => { null != n && !1 !== n && (t[r] = e && Br.isArray(n) ? n.join(", ") : n) }), t } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() { return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join("\n") } getSetCookie() { return this.get("set-cookie") || [] } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(e) { return e instanceof this ? e : new this(e) } static concat(e, ...t) { const n = new this(e); return t.forEach(e => n.set(e)), n } static accessor(e) { const t = (this[us] = this[us] = { accessors: {} }).accessors, n = this.prototype; function r(e) { const r = hs(e); t[r] || (function (e, t) { const n = Br.toCamelCase(" " + t);["get", "set", "has"].forEach(r => { Object.defineProperty(e, r + n, { value: function (e, n, s) { return this[r].call(this, t, e, n, s) }, configurable: !0 }) }) }(n, e), t[r] = !0) } return Br.isArray(e) ? e.forEach(r) : r(e), this } }; function ms(e, t) { const n = this || ls, r = t || n, s = fs.from(r.headers); let i = r.data; return Br.forEach(e, function (e) { i = e.call(n, i, s.normalize(), t ? t.status : void 0) }), s.normalize(), i } function gs(e) { return !(!e || !e.__CANCEL__) } function Es(e, t, n) { Ur.call(this, null == e ? "canceled" : e, Ur.ERR_CANCELED, t, n), this.name = "CanceledError" } function Ts(e, t, n) { const r = n.config.validateStatus; n.status && r && !r(n.status) ? t(new Ur("Request failed with status code " + n.status, [Ur.ERR_BAD_REQUEST, Ur.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n)) : e(n) } fs.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), Br.reduceDescriptors(fs.prototype, ({ value: e }, t) => { let n = t[0].toUpperCase() + t.slice(1); return { get: () => e, set(e) { this[n] = e } } }), Br.freezeMethods(fs), Br.inherits(Es, Ur, { __CANCEL__: !0 }); const As = (e, t, n = 3) => { let r = 0; const s = function (e, t) { e = e || 10; const n = new Array(e), r = new Array(e); let s, i = 0, o = 0; return t = void 0 !== t ? t : 1e3, function (a) { const l = Date.now(), c = r[o]; s || (s = l), n[i] = a, r[i] = l; let u = o, h = 0; for (; u !== i;)h += n[u++], u %= e; if (i = (i + 1) % e, i === o && (o = (o + 1) % e), l - s < t) return; const d = c && l - c; return d ? Math.round(1e3 * h / d) : void 0 } }(50, 250); return function (n, i) { let o, a, l = 0, c = 1e3 / i; const u = (n, i = Date.now()) => { l = i, o = null, a && (clearTimeout(a), a = null), (n => { const i = n.loaded, o = n.lengthComputable ? n.total : void 0, a = i - r, l = s(a); r = i, e({ loaded: i, total: o, progress: o ? i / o : void 0, bytes: a, rate: l || void 0, estimated: l && o && i <= o ? (o - i) / l : void 0, event: n, lengthComputable: null != o, [t ? "download" : "upload"]: !0 }) })(...n) }; return [(...e) => { const t = Date.now(), n = t - l; n >= c ? u(e, t) : (o = e, a || (a = setTimeout(() => { a = null, u(o) }, c - n))) }, () => o && u(o)] }(0, n) }, _s = (e, t) => { const n = null != e; return [r => t[0]({ lengthComputable: n, total: e, loaded: r }), t[1]] }, ys = e => (...t) => Br.asap(() => e(...t)), bs = os.hasStandardBrowserEnv ? ((e, t) => n => (n = new URL(n, os.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(new URL(os.origin), os.navigator && /(msie|trident)/i.test(os.navigator.userAgent)) : () => !0, Ss = os.hasStandardBrowserEnv ? { write(e, t, n, r, s, i, o) { if ("undefined" == typeof document) return; const a = [`${e}=${encodeURIComponent(t)}`]; Br.isNumber(n) && a.push(`expires=${new Date(n).toUTCString()}`), Br.isString(r) && a.push(`path=${r}`), Br.isString(s) && a.push(`domain=${s}`), !0 === i && a.push("secure"), Br.isString(o) && a.push(`SameSite=${o}`), document.cookie = a.join("; ") }, read(e) { if ("undefined" == typeof document) return null; const t = document.cookie.match(new RegExp("(?:^|; )" + e + "=([^;]*)")); return t ? decodeURIComponent(t[1]) : null }, remove(e) { this.write(e, "", Date.now() - 864e5, "/") } } : { write() { }, read: () => null, remove() { } }; function ks(e, t, n) { let r = !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t); return e && (r || 0 == n) ? function (e, t) { return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e }(e, t) : t } const Cs = e => e instanceof fs ? { ...e } : e; function Ns(e, t) { t = t || {}; const n = {}; function r(e, t, n, r) { return Br.isPlainObject(e) && Br.isPlainObject(t) ? Br.merge.call({ caseless: r }, e, t) : Br.isPlainObject(t) ? Br.merge({}, t) : Br.isArray(t) ? t.slice() : t } function s(e, t, n, s) { return Br.isUndefined(t) ? Br.isUndefined(e) ? void 0 : r(void 0, e, 0, s) : r(e, t, 0, s) } function i(e, t) { if (!Br.isUndefined(t)) return r(void 0, t) } function o(e, t) { return Br.isUndefined(t) ? Br.isUndefined(e) ? void 0 : r(void 0, e) : r(void 0, t) } function a(n, s, i) { return i in t ? r(n, s) : i in e ? r(void 0, n) : void 0 } const l = { url: i, method: i, data: i, baseURL: o, transformRequest: o, transformResponse: o, paramsSerializer: o, timeout: o, timeoutMessage: o, withCredentials: o, withXSRFToken: o, adapter: o, responseType: o, xsrfCookieName: o, xsrfHeaderName: o, onUploadProgress: o, onDownloadProgress: o, decompress: o, maxContentLength: o, maxBodyLength: o, beforeRedirect: o, transport: o, httpAgent: o, httpsAgent: o, cancelToken: o, socketPath: o, responseEncoding: o, validateStatus: a, headers: (e, t, n) => s(Cs(e), Cs(t), 0, !0) }; return Br.forEach(Object.keys({ ...e, ...t }), function (r) { const i = l[r] || s, o = i(e[r], t[r], r); Br.isUndefined(o) && i !== a || (n[r] = o) }), n } const Is = e => { const t = Ns({}, e); let { data: n, withXSRFToken: r, xsrfHeaderName: s, xsrfCookieName: i, headers: o, auth: a } = t; if (t.headers = o = fs.from(o), t.url = Xr(ks(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), a && o.set("Authorization", "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))), Br.isFormData(n)) if (os.hasStandardBrowserEnv || os.hasStandardBrowserWebWorkerEnv) o.setContentType(void 0); else if (Br.isFunction(n.getHeaders)) { const e = n.getHeaders(), t = ["content-type", "content-length"]; Object.entries(e).forEach(([e, n]) => { t.includes(e.toLowerCase()) && o.set(e, n) }) } if (os.hasStandardBrowserEnv && (r && Br.isFunction(r) && (r = r(t)), r || !1 !== r && bs(t.url))) { const e = s && i && Ss.read(i); e && o.set(s, e) } return t }, Os = "undefined" != typeof XMLHttpRequest && function (e) { return new Promise(function (t, n) { const r = Is(e); let s = r.data; const i = fs.from(r.headers).normalize(); let o, a, l, c, u, { responseType: h, onUploadProgress: d, onDownloadProgress: p } = r; function f() { c && c(), u && u(), r.cancelToken && r.cancelToken.unsubscribe(o), r.signal && r.signal.removeEventListener("abort", o) } let m = new XMLHttpRequest; function g() { if (!m) return; const r = fs.from("getAllResponseHeaders" in m && m.getAllResponseHeaders()); Ts(function (e) { t(e), f() }, function (e) { n(e), f() }, { data: h && "text" !== h && "json" !== h ? m.response : m.responseText, status: m.status, statusText: m.statusText, headers: r, config: e, request: m }), m = null } m.open(r.method.toUpperCase(), r.url, !0), m.timeout = r.timeout, "onloadend" in m ? m.onloadend = g : m.onreadystatechange = function () { m && 4 === m.readyState && (0 !== m.status || m.responseURL && 0 === m.responseURL.indexOf("file:")) && setTimeout(g) }, m.onabort = function () { m && (n(new Ur("Request aborted", Ur.ECONNABORTED, e, m)), m = null) }, m.onerror = function (t) { const r = new Ur(t && t.message ? t.message : "Network Error", Ur.ERR_NETWORK, e, m); r.event = t || null, n(r), m = null }, m.ontimeout = function () { let t = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded"; const s = r.transitional || Zr; r.timeoutErrorMessage && (t = r.timeoutErrorMessage), n(new Ur(t, s.clarifyTimeoutError ? Ur.ETIMEDOUT : Ur.ECONNABORTED, e, m)), m = null }, void 0 === s && i.setContentType(null), "setRequestHeader" in m && Br.forEach(i.toJSON(), function (e, t) { m.setRequestHeader(t, e) }), Br.isUndefined(r.withCredentials) || (m.withCredentials = !!r.withCredentials), h && "json" !== h && (m.responseType = r.responseType), p && ([l, u] = As(p, !0), m.addEventListener("progress", l)), d && m.upload && ([a, c] = As(d), m.upload.addEventListener("progress", a), m.upload.addEventListener("loadend", c)), (r.cancelToken || r.signal) && (o = t => { m && (n(!t || t.type ? new Es(null, e, m) : t), m.abort(), m = null) }, r.cancelToken && r.cancelToken.subscribe(o), r.signal && (r.signal.aborted ? o() : r.signal.addEventListener("abort", o))); const E = function (e) { const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e); return t && t[1] || "" }(r.url); E && -1 === os.protocols.indexOf(E) ? n(new Ur("Unsupported protocol " + E + ":", Ur.ERR_BAD_REQUEST, e)) : m.send(s || null) }) }, xs = (e, t) => { const { length: n } = e = e ? e.filter(Boolean) : []; if (t || n) { let n, r = new AbortController; const s = function (e) { if (!n) { n = !0, o(); const t = e instanceof Error ? e : this.reason; r.abort(t instanceof Ur ? t : new Es(t instanceof Error ? t.message : t)) } }; let i = t && setTimeout(() => { i = null, s(new Ur(`timeout ${t} of ms exceeded`, Ur.ETIMEDOUT)) }, t); const o = () => { e && (i && clearTimeout(i), i = null, e.forEach(e => { e.unsubscribe ? e.unsubscribe(s) : e.removeEventListener("abort", s) }), e = null) }; e.forEach(e => e.addEventListener("abort", s)); const { signal: a } = r; return a.unsubscribe = () => Br.asap(o), a } }, Rs = function* (e, t) { let n = e.byteLength; if (n < t) return void (yield e); let r, s = 0; for (; s < n;)r = s + t, yield e.slice(s, r), s = r }, vs = (e, t, n, r) => { const s = async function* (e, t) { for await (const n of async function* (e) { if (e[Symbol.asyncIterator]) return void (yield* e); const t = e.getReader(); try { for (; ;) { const { done: e, value: n } = await t.read(); if (e) break; yield n } } finally { await t.cancel() } }(e)) yield* Rs(n, t) }(e, t); let i, o = 0, a = e => { i || (i = !0, r && r(e)) }; return new ReadableStream({ async pull(e) { try { const { done: t, value: r } = await s.next(); if (t) return a(), void e.close(); let i = r.byteLength; if (n) { let e = o += i; n(e) } e.enqueue(new Uint8Array(r)) } catch (t) { throw a(t), t } }, cancel: e => (a(e), s.return()) }, { highWaterMark: 2 }) }, { isFunction: Ds } = Br, Ls = (({ Request: e, Response: t }) => ({ Request: e, Response: t }))(Br.global), { ReadableStream: Ps, TextEncoder: ws } = Br.global, Ms = (e, ...t) => { try { return !!e(...t) } catch (fg) { return !1 } }, Fs = e => { e = Br.merge.call({ skipUndefined: !0 }, Ls, e); const { fetch: t, Request: n, Response: r } = e, s = t ? Ds(t) : "function" == typeof fetch, i = Ds(n), o = Ds(r); if (!s) return !1; const a = s && Ds(Ps), l = s && ("function" == typeof ws ? (e => t => e.encode(t))(new ws) : async e => new Uint8Array(await new n(e).arrayBuffer())), c = i && a && Ms(() => { let e = !1; const t = new n(os.origin, { body: new Ps, method: "POST", get duplex() { return e = !0, "half" } }).headers.has("Content-Type"); return e && !t }), u = o && a && Ms(() => Br.isReadableStream(new r("").body)), h = { stream: u && (e => e.body) }; s && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(e => { !h[e] && (h[e] = (t, n) => { let r = t && t[e]; if (r) return r.call(t); throw new Ur(`Response type '${e}' is not supported`, Ur.ERR_NOT_SUPPORT, n) }) }); return async e => { let { url: s, method: o, data: a, signal: d, cancelToken: p, timeout: f, onDownloadProgress: m, onUploadProgress: g, responseType: E, headers: T, withCredentials: A = "same-origin", fetchOptions: _ } = Is(e), y = t || fetch; E = E ? (E + "").toLowerCase() : "text"; let b = xs([d, p && p.toAbortSignal()], f), S = null; const k = b && b.unsubscribe && (() => { b.unsubscribe() }); let C; try { if (g && c && "get" !== o && "head" !== o && 0 !== (C = await (async (e, t) => { const r = Br.toFiniteNumber(e.getContentLength()); return null == r ? (async e => { if (null == e) return 0; if (Br.isBlob(e)) return e.size; if (Br.isSpecCompliantForm(e)) { const t = new n(os.origin, { method: "POST", body: e }); return (await t.arrayBuffer()).byteLength } return Br.isArrayBufferView(e) || Br.isArrayBuffer(e) ? e.byteLength : (Br.isURLSearchParams(e) && (e += ""), Br.isString(e) ? (await l(e)).byteLength : void 0) })(t) : r })(T, a))) { let e, t = new n(s, { method: "POST", body: a, duplex: "half" }); if (Br.isFormData(a) && (e = t.headers.get("content-type")) && T.setContentType(e), t.body) { const [e, n] = _s(C, As(ys(g))); a = vs(t.body, 65536, e, n) } } Br.isString(A) || (A = A ? "include" : "omit"); const t = i && "credentials" in n.prototype, d = { ..._, signal: b, method: o.toUpperCase(), headers: T.normalize().toJSON(), body: a, duplex: "half", credentials: t ? A : void 0 }; S = i && new n(s, d); let p = await (i ? y(S, _) : y(s, d)); const f = u && ("stream" === E || "response" === E); if (u && (m || f && k)) { const e = {};["status", "statusText", "headers"].forEach(t => { e[t] = p[t] }); const t = Br.toFiniteNumber(p.headers.get("content-length")), [n, s] = m && _s(t, As(ys(m), !0)) || []; p = new r(vs(p.body, 65536, n, () => { s && s(), k && k() }), e) } E = E || "text"; let N = await h[Br.findKey(h, E) || "text"](p, e); return !f && k && k(), await new Promise((t, n) => { Ts(t, n, { data: N, headers: fs.from(p.headers), status: p.status, statusText: p.statusText, config: e, request: S }) }) } catch (N) { if (k && k(), N && "TypeError" === N.name && /Load failed|fetch/i.test(N.message)) throw Object.assign(new Ur("Network Error", Ur.ERR_NETWORK, e, S), { cause: N.cause || N }); throw Ur.from(N, N && N.code, e, S) } } }, Bs = new Map, Us = e => { let t = e && e.env || {}; const { fetch: n, Request: r, Response: s } = t, i = [r, s, n]; let o, a, l = i.length, c = Bs; for (; l--;)o = i[l], a = c.get(o), void 0 === a && c.set(o, a = l ? new Map : Fs(t)), c = a; return a }; Us(); const Hs = { http: null, xhr: Os, fetch: { get: Us } }; Br.forEach(Hs, (e, t) => { if (e) { try { Object.defineProperty(e, "name", { value: t }) } catch (fg) { } Object.defineProperty(e, "adapterName", { value: t }) } }); const js = e => `- ${e}`, Gs = e => Br.isFunction(e) || null === e || !1 === e, zs = function (e, t) { e = Br.isArray(e) ? e : [e]; const { length: n } = e; let r, s; const i = {}; for (let o = 0; o < n; o++) { let n; if (r = e[o], s = r, !Gs(r) && (s = Hs[(n = String(r)).toLowerCase()], void 0 === s)) throw new Ur(`Unknown adapter '${n}'`); if (s && (Br.isFunction(s) || (s = s.get(t)))) break; i[n || "#" + o] = s } if (!s) { const e = Object.entries(i).map(([e, t]) => `adapter ${e} ` + (!1 === t ? "is not supported by the environment" : "is not available in the build")); throw new Ur("There is no suitable adapter to dispatch the request " + (n ? e.length > 1 ? "since :\n" + e.map(js).join("\n") : " " + js(e[0]) : "as no adapter specified"), "ERR_NOT_SUPPORT") } return s }; function Ys(e) { if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new Es(null, e) } function qs(e) { return Ys(e), e.headers = fs.from(e.headers), e.data = ms.call(e, e.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e.method) && e.headers.setContentType("application/x-www-form-urlencoded", !1), zs(e.adapter || ls.adapter, e)(e).then(function (t) { return Ys(e), t.data = ms.call(e, e.transformResponse, t), t.headers = fs.from(t.headers), t }, function (t) { return gs(t) || (Ys(e), t && t.response && (t.response.data = ms.call(e, e.transformResponse, t.response), t.response.headers = fs.from(t.response.headers))), Promise.reject(t) }) } const Vs = "1.13.2", $s = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => { $s[e] = function (n) { return typeof n === e || "a" + (t < 1 ? "n " : " ") + e } }); const Ws = {}; $s.transitional = function (e, t, n) { return (r, s, i) => { if (!1 === e) throw new Ur(function (e, t) { return "[Axios v" + Vs + "] Transitional option '" + e + "'" + t + (n ? ". " + n : "") }(s, " has been removed" + (t ? " in " + t : "")), Ur.ERR_DEPRECATED); return t && !Ws[s] && (Ws[s] = !0), !e || e(r, s, i) } }, $s.spelling = function (e) { return (e, t) => !0 }; const Ks = { assertOptions: function (e, t, n) { if ("object" != typeof e) throw new Ur("options must be an object", Ur.ERR_BAD_OPTION_VALUE); const r = Object.keys(e); let s = r.length; for (; s-- > 0;) { const i = r[s], o = t[i]; if (o) { const t = e[i], n = void 0 === t || o(t, i, e); if (!0 !== n) throw new Ur("option " + i + " must be " + n, Ur.ERR_BAD_OPTION_VALUE); continue } if (!0 !== n) throw new Ur("Unknown option " + i, Ur.ERR_BAD_OPTION) } }, validators: $s }, Qs = Ks.validators; let Xs = class { constructor(e) { this.defaults = e || {}, this.interceptors = { request: new Jr, response: new Jr } } async request(e, t) { try { return await this._request(e, t) } catch (n) { if (n instanceof Error) { let e = {}; Error.captureStackTrace ? Error.captureStackTrace(e) : e = new Error; const t = e.stack ? e.stack.replace(/^.+\n/, "") : ""; try { n.stack ? t && !String(n.stack).endsWith(t.replace(/^.+\n.+\n/, "")) && (n.stack += "\n" + t) : n.stack = t } catch (fg) { } } throw n } } _request(e, t) { "string" == typeof e ? (t = t || {}).url = e : t = e || {}, t = Ns(this.defaults, t); const { transitional: n, paramsSerializer: r, headers: s } = t; void 0 !== n && Ks.assertOptions(n, { silentJSONParsing: Qs.transitional(Qs.boolean), forcedJSONParsing: Qs.transitional(Qs.boolean), clarifyTimeoutError: Qs.transitional(Qs.boolean) }, !1), null != r && (Br.isFunction(r) ? t.paramsSerializer = { serialize: r } : Ks.assertOptions(r, { encode: Qs.function, serialize: Qs.function }, !0)), void 0 !== t.allowAbsoluteUrls || (void 0 !== this.defaults.allowAbsoluteUrls ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), Ks.assertOptions(t, { baseUrl: Qs.spelling("baseURL"), withXsrfToken: Qs.spelling("withXSRFToken") }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase(); let i = s && Br.merge(s.common, s[t.method]); s && Br.forEach(["delete", "get", "head", "post", "put", "patch", "common"], e => { delete s[e] }), t.headers = fs.concat(i, s); const o = []; let a = !0; this.interceptors.request.forEach(function (e) { "function" == typeof e.runWhen && !1 === e.runWhen(t) || (a = a && e.synchronous, o.unshift(e.fulfilled, e.rejected)) }); const l = []; let c; this.interceptors.response.forEach(function (e) { l.push(e.fulfilled, e.rejected) }); let u, h = 0; if (!a) { const e = [qs.bind(this), void 0]; for (e.unshift(...o), e.push(...l), u = e.length, c = Promise.resolve(t); h < u;)c = c.then(e[h++], e[h++]); return c } u = o.length; let d = t; for (; h < u;) { const e = o[h++], t = o[h++]; try { d = e(d) } catch (p) { t.call(this, p); break } } try { c = qs.call(this, d) } catch (p) { return Promise.reject(p) } for (h = 0, u = l.length; h < u;)c = c.then(l[h++], l[h++]); return c } getUri(e) { return Xr(ks((e = Ns(this.defaults, e)).baseURL, e.url, e.allowAbsoluteUrls), e.params, e.paramsSerializer) } }; Br.forEach(["delete", "get", "head", "options"], function (e) { Xs.prototype[e] = function (t, n) { return this.request(Ns(n || {}, { method: e, url: t, data: (n || {}).data })) } }), Br.forEach(["post", "put", "patch"], function (e) { function t(t) { return function (n, r, s) { return this.request(Ns(s || {}, { method: e, headers: t ? { "Content-Type": "multipart/form-data" } : {}, url: n, data: r })) } } Xs.prototype[e] = t(), Xs.prototype[e + "Form"] = t(!0) }); const Js = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511, WebServerIsDown: 521, ConnectionTimedOut: 522, OriginIsUnreachable: 523, TimeoutOccurred: 524, SslHandshakeFailed: 525, InvalidSslCertificate: 526 }; Object.entries(Js).forEach(([e, t]) => { Js[t] = e }); const Zs = function e(t) { const n = new Xs(t), r = Qn(Xs.prototype.request, n); return Br.extend(r, Xs.prototype, n, { allOwnKeys: !0 }), Br.extend(r, n, null, { allOwnKeys: !0 }), r.create = function (n) { return e(Ns(t, n)) }, r }(ls); Zs.Axios = Xs, Zs.CanceledError = Es, Zs.CancelToken = class e { constructor(e) { if ("function" != typeof e) throw new TypeError("executor must be a function."); let t; this.promise = new Promise(function (e) { t = e }); const n = this; this.promise.then(e => { if (!n._listeners) return; let t = n._listeners.length; for (; t-- > 0;)n._listeners[t](e); n._listeners = null }), this.promise.then = e => { let t; const r = new Promise(e => { n.subscribe(e), t = e }).then(e); return r.cancel = function () { n.unsubscribe(t) }, r }, e(function (e, r, s) { n.reason || (n.reason = new Es(e, r, s), t(n.reason)) }) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(e) { this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e] } unsubscribe(e) { if (!this._listeners) return; const t = this._listeners.indexOf(e); -1 !== t && this._listeners.splice(t, 1) } toAbortSignal() { const e = new AbortController, t = t => { e.abort(t) }; return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal } static source() { let t; return { token: new e(function (e) { t = e }), cancel: t } } }, Zs.isCancel = gs, Zs.VERSION = Vs, Zs.toFormData = Vr, Zs.AxiosError = Ur, Zs.Cancel = Zs.CanceledError, Zs.all = function (e) { return Promise.all(e) }, Zs.spread = function (e) { return function (t) { return e.apply(null, t) } }, Zs.isAxiosError = function (e) { return Br.isObject(e) && !0 === e.isAxiosError }, Zs.mergeConfig = Ns, Zs.AxiosHeaders = fs, Zs.formToJSON = e => as(Br.isHTMLForm(e) ? new FormData(e) : e), Zs.getAdapter = zs, Zs.HttpStatusCode = Js, Zs.default = Zs; const { Axios: ei, AxiosError: ti, CanceledError: ni, isCancel: ri, CancelToken: si, VERSION: ii, all: oi, Cancel: ai, isAxiosError: li, spread: ci, toFormData: ui, AxiosHeaders: hi, HttpStatusCode: di, formToJSON: pi, getAdapter: fi, mergeConfig: mi } = Zs, gi = Zs.create({ baseURL: "https://next-blog-server-226627032790.asia-east1.run.app/api", headers: { "Content-Type": "application/json" } }); gi.interceptors.request.use(e => { try { const t = localStorage.getItem("auth_token"); t && (e.headers.Authorization = `Bearer ${t}`) } catch (fg) { } return e }); const Ei = () => gi.get("/posts"), Ti = () => gi.get("/categories"), Ai = React.createContext(void 0); function _i({ children: e }) { const { i18n: t } = Kn(), [n, r] = React.useState([]), [s, i] = React.useState(!0), o = async () => { try { i(!0); const e = await Ti(); r(e.data.categories || []) } catch (e) { } finally { i(!1) } }; return React.useEffect(() => { o() }, []), T.jsx(Ai.Provider, { value: { categories: n, isLoading: s, getCategoryTitle: e => { var r, s; if (!e) return ""; const i = n.find(t => t.slug === e || t.id === e || t.title.toLowerCase() === e.toLowerCase()); if (!i) return e; const o = t.language; return (null == (s = null == (r = i.translations) ? void 0 : r[o]) ? void 0 : s.title) ? i.translations[o].title : i.title }, refreshCategories: o }, children: e }) } function yi() { const e = React.useContext(Ai); if (!e) throw new Error("useCategories must be used within CategoriesProvider"); return e } const bi = React.createContext({ user: null, isAuthenticated: !1, isLoading: !1, login: async () => !1, logout: () => { } }); function Si() { return React.useContext(bi) } function ki() { const { t: e, i18n: t } = Kn(), { theme: n, toggleTheme: r, textSize: s, setTextSize: i } = function () { const e = React.useContext(xt); if (!e) throw new Error("useTheme must be used within ThemeProvider"); return e }(), { isAuthenticated: o, logout: a } = Si(), [l, c] = React.useState([]), [u, h] = React.useState(!1), d = React.useRef(null); return React.useEffect(() => { function e(e) { d.current && !d.current.contains(e.target) && h(!1) } return document.addEventListener("mousedown", e), () => document.removeEventListener("mousedown", e) }, []), React.useEffect(() => { const e = () => { Ti().then(e => { c(e.data.categories) }).catch(e => { }) }; return e(), window.addEventListener("categories-updated", e), () => window.removeEventListener("categories-updated", e) }, []), T.jsx("nav", { className: "border-b border-gray-200 dark:border-gray-700", children: T.jsx("div", { className: "max-w-6xl mx-auto px-4 sm:px-6 lg:px-8", children: T.jsxs("div", { className: "flex justify-between h-16 items-center", children: [T.jsxs(Pe, { to: "/", className: "flex items-center text-2xl font-display text-text-light dark:text-text-dark hover:opacity-70 transition-opacity", children: [T.jsx("img", { src: "data:image/svg+xml,%3csvg%20width='500'%20height='500'%20viewBox='0%200%20500%20500'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20fill='%23000000'%3e%3ccircle%20cx='165'%20cy='180'%20r='40'%20/%3e%3ccircle%20cx='335'%20cy='180'%20r='40'%20/%3e%3cpath%20d='M%20150%20210%20Q%20250%20150%20350%20210%20C%20410%20240%20430%20350%20440%20420%20Q%20445%20480%20250%20480%20Q%2055%20480%2060%20420%20C%2070%20350%2090%20240%20150%20210%20Z'%20/%3e%3c/g%3e%3cpath%20d='M%20105%20305%20L%20250%20400%20L%20395%20305%20L%20410%20305%20L%20250%20450%20L%2090%20305%20Z'%20fill='%23FFFFFF'%20/%3e%3cg%3e%3ccircle%20cx='205'%20cy='245'%20r='16'%20fill='%23FFFFFF'%20/%3e%3ccircle%20cx='205'%20cy='245'%20r='7'%20fill='%23000000'%20/%3e%3ccircle%20cx='295'%20cy='245'%20r='16'%20fill='%23FFFFFF'%20/%3e%3ccircle%20cx='295'%20cy='245'%20r='7'%20fill='%23000000'%20/%3e%3c/g%3e%3cpath%20d='M%20220%20280%20Q%20250%20260%20280%20280%20Q%20295%20310%20280%20330%20Q%20250%20345%20220%20330%20Q%20205%20310%20220%20280%20Z'%20fill='%23FFFFFF'%20/%3e%3cpath%20d='M%20235%20285%20Q%20250%20280%20265%20285%20Q%20270%20295%20250%20310%20Q%20230%20295%20235%20285%20Z'%20fill='%23000000'%20/%3e%3crect%20x='248'%20y='310'%20width='4'%20height='10'%20rx='2'%20fill='%23000000'%20/%3e%3c/svg%3e", alt: "Logo", className: "mr-3 mb-2 flex-shrink-0 [filter:drop-shadow(-2px_0_0_#00e5ff)_drop-shadow(2px_0_0_#ff0055)] dark:[filter:drop-shadow(-2px_0_0_rgba(0,229,255,0.5))_drop-shadow(2px_0_0_rgba(255,0,85,0.5))_drop-shadow(0_0_5px_rgba(0,229,255,0.15))]", style: { width: "40px", height: "40px" } }), e("brand")] }), T.jsxs("div", { className: "flex items-center space-x-6", children: [T.jsx(Pe, { to: "/", className: "text-muted-light dark:text-muted-dark hover:text-text-light dark:hover:text-text-dark transition-colors", children: e("nav.home") }), T.jsxs("div", { className: "relative", ref: d, children: [T.jsxs("button", { onClick: () => h(!u), className: "flex items-center gap-1 text-muted-light dark:text-muted-dark hover:text-text-light dark:hover:text-text-dark transition-colors", children: [e("nav.categories", "Categories"), T.jsx("svg", { className: "w-4 h-4 transition-transform " + (u ? "rotate-180" : ""), fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: T.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" }) })] }), u && T.jsx("div", { className: "absolute left-0 mt-2 py-2 w-48 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 z-50", children: l.filter(e => o || !e.adminOnly).map(e => { var n, r; return T.jsxs(Pe, { to: `/category/${e.slug || e.id}`, className: "block px-4 py-2 text-muted-light dark:text-muted-dark hover:bg-gray-100 dark:hover:bg-gray-700 hover:text-text-light dark:hover:text-text-dark transition-colors " + (e.adminOnly ? "opacity-70" : ""), onClick: () => h(!1), children: [e.adminOnly ? " " : "", (null == (r = null == (n = e.translations) ? void 0 : n[t.language]) ? void 0 : r.title) || e.title] }, e.id) }) })] }), o && T.jsxs(Pe, { to: "/admin", className: "text-muted-light dark:text-muted-dark hover:text-text-light dark:hover:text-text-dark transition-colors font-medium", children: [" ", e("nav.admin")] })] }), T.jsxs("div", { className: "flex items-center space-x-4", children: [T.jsxs("div", { className: "hidden sm:flex items-center space-x-1 text-sm", children: [T.jsx("button", { onClick: () => { const e = ["small", "medium", "large", "xlarge", "xxlarge", "xxxlarge"], t = e.indexOf(s); t > 0 && i(e[t - 1]) }, disabled: "small" === s, className: "w-6 h-6 flex items-center justify-center rounded " + ("small" === s ? "opacity-30 cursor-not-allowed" : "hover:bg-gray-100 dark:hover:bg-gray-800"), title: "Decrease text size", children: "" }), T.jsx("span", { className: "w-6 h-6 flex items-center justify-center font-medium", children: "A" }), T.jsx("button", { onClick: () => { const e = ["small", "medium", "large", "xlarge", "xxlarge", "xxxlarge"], t = e.indexOf(s); t < e.length - 1 && i(e[t + 1]) }, disabled: "xxxlarge" === s, className: "w-6 h-6 flex items-center justify-center rounded " + ("xxxlarge" === s ? "opacity-30 cursor-not-allowed" : "hover:bg-gray-100 dark:hover:bg-gray-800"), title: "Increase text size", children: "+" })] }), T.jsxs("select", { value: t.language, onChange: e => t.changeLanguage(e.target.value), className: "bg-transparent text-sm text-muted-light dark:text-muted-dark hover:text-text-light dark:hover:text-text-dark uppercase border-none focus:ring-0 cursor-pointer appearance-none p-0 pr-6 bg-[url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%239CA3AF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E')] bg-[length:0.7em] bg-[right_0_center] bg-no-repeat", "aria-label": "Select Language", children: [T.jsx("option", { value: "en", className: "bg-white dark:bg-gray-800 py-1", children: "EN" }), T.jsx("option", { value: "poj", className: "bg-white dark:bg-gray-800 py-1", children: "POJ" }), T.jsx("option", { value: "hanlo", className: "bg-white dark:bg-gray-800 py-1", children: "" })] }), T.jsx("button", { onClick: r, className: "p-2 rounded hover:bg-gray-100 dark:hover:bg-gray-800", "aria-label": "Toggle theme", children: "light" === n ? T.jsx("svg", { className: "w-5 h-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: T.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" }) }) : T.jsx("svg", { className: "w-5 h-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: T.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" }) }) }), !1] })] }) }) }) } function Ci() { const { t: e } = Kn(), t = (new Date).getFullYear(); return T.jsx("footer", { className: "border-t border-gray-200 dark:border-gray-700 mt-20 py-10", children: T.jsx("div", { className: "max-w-6xl mx-auto px-4 sm:px-6 lg:px-8", children: T.jsx("div", { className: "text-muted-light dark:text-muted-dark text-sm", children: e("footer.copyright", { year: t }) }) }) }) } function Ni({ post: e, featured: t = !1, showDraftBadge: n = !1 }) { var r; const { t: s } = Kn(), { getCategoryTitle: i } = yi(), o = e.published || e.draft, a = null == o ? void 0 : o.meta, l = "published" !== e.status; if (!o) return null; const c = (null == (r = null == a ? void 0 : a.date) ? void 0 : r.substring(0, 7)) || `${(new Date).getFullYear()}-01`, u = (null == a ? void 0 : a.url) || e.id, h = (null == a ? void 0 : a.thumbImage) || ((e, t = 800, n = 600) => `https://picsum.photos/seed/${e}/${t}/${n}`)(e.id); return T.jsxs("article", { className: "group relative flex flex-col " + (t ? "col-span-full md:grid md:grid-cols-2 md:gap-8" : "h-full"), children: [T.jsx(Pe, { to: `/posts/${c}/${u}`, className: "absolute inset-0 z-10", "aria-label": o.title }), T.jsxs("div", { className: `overflow-hidden rounded-lg bg-gray-100 dark:bg-gray-800 ${t ? "aspect-video md:aspect-auto md:h-full" : "aspect-[16/10]"} mb-4 md:mb-0 relative shadow-sm transition-all duration-300 group-hover:shadow-md group-hover:translate-y-[-2px]`, children: [T.jsx("img", { src: h, alt: o.title, className: "w-full h-full object-cover transition-transform duration-700 ease-out group-hover:scale-105", loading: "lazy" }), n && l && T.jsx("div", { className: "absolute top-4 right-4 z-20", children: T.jsx("span", { className: "inline-block px-2 py-1 text-xs font-bold text-white uppercase tracking-wider bg-orange-500/80 backdrop-blur-sm rounded-sm", children: s("post.draft") }) }), (null == a ? void 0 : a.category) && T.jsx("div", { className: "absolute top-4 left-4 z-20", children: T.jsxs("span", { className: "inline-flex items-center gap-1 px-2 py-1 text-xs font-bold text-white uppercase tracking-wider bg-black/50 backdrop-blur-sm rounded-sm", children: [T.jsx("svg", { className: "w-3 h-3", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: T.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" }) }), i(a.category)] }) })] }), T.jsxs("div", { className: "flex flex-col " + (t ? "justify-center md:py-4" : "flex-1"), children: [T.jsxs("div", { className: "flex items-center gap-3 mb-3 text-xs font-medium text-muted-light dark:text-muted-dark", children: [(null == a ? void 0 : a.date) && T.jsx("time", { dateTime: a.date, children: a.date }), (null == a ? void 0 : a.featured) && T.jsx("span", { className: "text-yellow-600 dark:text-yellow-500 font-bold", children: s("post.featured") }), n && l && T.jsx("span", { className: "text-orange-500 font-bold", children: s("post.draft") })] }), T.jsx("h2", { className: `font-display font-bold text-text-light dark:text-text-dark ${t ? "text-3xl md:text-4xl" : "text-xl"} leading-tight mb-3 group-hover:text-accent transition-colors duration-200`, children: o.title }), (null == a ? void 0 : a.thumbText) && T.jsx("p", { className: `text-muted-light dark:text-muted-dark ${t ? "text-lg line-clamp-3" : "text-sm line-clamp-2"} mb-4`, children: a.thumbText }), T.jsx("div", { className: "mt-auto flex items-center text-sm font-medium text-accent opacity-0 -translate-x-2 transition-all duration-300 group-hover:opacity-100 group-hover:translate-x-0", children: s("post.readArticle") })] })] }) } function Ii() { const { t: e, i18n: t } = Kn(), [n, r] = React.useState([]), [s, i] = React.useState(!0), [o, a] = React.useState(null); React.useEffect(() => { l() }, [t.language]); const l = async () => { try { i(!0); const e = await Ei(); r(e.data.posts) } catch (t) { a(e("home.failedToLoad")) } finally { i(!1) } }, c = n.filter(e => { var t, n, r; return "help" !== (null == (r = null == (n = null == (t = e.published) ? void 0 : t.meta) ? void 0 : n.category) ? void 0 : r.toLowerCase()) }), u = c.filter(e => { var t, n; return null == (n = null == (t = e.published) ? void 0 : t.meta) ? void 0 : n.featured }), h = c.filter(e => { var t, n; return !(null == (n = null == (t = e.published) ? void 0 : t.meta) ? void 0 : n.featured) }); return T.jsxs(T.Fragment, { children: [T.jsxs(Ot, { children: [T.jsxs("title", { children: [e("home.title"), " | Next Blog"] }), T.jsx("meta", { name: "description", content: "A modern blog built with React and Firestore" })] }), T.jsxs("div", { className: "min-h-screen flex flex-col", children: [T.jsx(ki, {}), T.jsx("main", { className: "flex-1", children: T.jsxs("div", { className: "max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-12", children: [u.length > 0 && T.jsxs("section", { className: "mb-16", children: [T.jsx("h2", { className: "text-sm uppercase tracking-wider text-muted-light dark:text-muted-dark mb-6", children: e("home.featured") }), T.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-8", children: u.slice(0, 2).map(e => T.jsx(Ni, { post: e, featured: !0 }, e.id)) })] }), T.jsxs("section", { children: [T.jsx("h2", { className: "text-sm uppercase tracking-wider text-muted-light dark:text-muted-dark mb-6", children: e("home.latest") }), s ? T.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8", children: [...Array(6)].map((e, t) => T.jsxs("div", { className: "animate-pulse", children: [T.jsx("div", { className: "bg-gray-200 dark:bg-gray-700 aspect-[4/3] mb-4 rounded" }), T.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/4 mb-2" }), T.jsx("div", { className: "h-6 bg-gray-200 dark:bg-gray-700 rounded w-3/4 mb-2" }), T.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/2" })] }, t)) }) : o ? T.jsx("div", { className: "text-center py-12 text-muted-light dark:text-muted-dark", children: o }) : 0 === h.length ? T.jsx("div", { className: "text-center py-12 text-muted-light dark:text-muted-dark", children: e("home.noPosts") }) : T.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8", children: h.map(e => T.jsx(Ni, { post: e }, e.id)) })] })] }) }), T.jsx(Ci, {})] })] }) } const Oi = {}, xi = function (e, t, n) { let r = Promise.resolve(); if (t && t.length > 0) { const e = document.getElementsByTagName("link"), s = document.querySelector("meta[property=csp-nonce]"), i = (null == s ? void 0 : s.nonce) || (null == s ? void 0 : s.getAttribute("nonce")); r = Promise.allSettled(t.map(t => { if (t = function (e, t) { return new URL(e, t).href }(t, n), t in Oi) return; Oi[t] = !0; const r = t.endsWith(".css"), s = r ? '[rel="stylesheet"]' : ""; if (n) for (let n = e.length - 1; n >= 0; n--) { const s = e[n]; if (s.href === t && (!r || "stylesheet" === s.rel)) return } else if (document.querySelector(`link[href="${t}"]${s}`)) return; const o = document.createElement("link"); return o.rel = r ? "stylesheet" : "modulepreload", r || (o.as = "script"), o.crossOrigin = "", o.href = t, i && o.setAttribute("nonce", i), document.head.appendChild(o), r ? new Promise((e, n) => { o.addEventListener("load", e), o.addEventListener("error", () => n(new Error(`Unable to preload CSS for ${t}`))) }) : void 0 })) } function s(e) { const t = new Event("vite:preloadError", { cancelable: !0 }); if (t.payload = e, window.dispatchEvent(t), !t.defaultPrevented) throw e } return r.then(t => { for (const e of t || []) "rejected" === e.status && s(e.reason); return e().catch(s) }) }, Ri = React.lazy(() => xi(() => Promise.resolve().then(() => Xu), void 0, import.meta.url).then(e => ({ default: e.default }))), vi = xi(() => Promise.resolve().then(() => qd), void 0, import.meta.url).then(e => e.default), Di = xi(() => Promise.resolve().then(() => hg), void 0, import.meta.url).then(e => e.default); let Li = null, Pi = null; Promise.all([vi, Di]).then(([e, t]) => { Li = e, Pi = t }); const wi = () => T.jsx("div", { className: "animate-pulse space-y-4", children: [...Array(5)].map((e, t) => T.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded" }, t)) }); function Mi({ children: e, className: t }) { return T.jsx(React.Suspense, { fallback: T.jsx(wi, {}), children: T.jsx(Ri, { remarkPlugins: Li ? [Li] : [], rehypePlugins: Pi ? [Pi] : [], className: t, children: e }) }) } const Fi = (e, t = 1200, n = 800) => `https://picsum.photos/seed/${e}/${t}/${n}`; function Bi() { const { yearMonth: e, slug: t } = pe(), { t: n } = Kn(), { getCategoryTitle: r } = yi(), [s, i] = React.useState(null), [o, a] = React.useState(!0), [l, c] = React.useState(null); React.useEffect(() => { e && t && u(e, t) }, [e, t]); const u = async (e, t) => { try { a(!0); const n = await ((e, t) => gi.get(`/posts/by-slug/${e}/${t}`))(e, t); i(n.data.post) } catch (r) { c(n("post.notFound")) } finally { a(!1) } }, h = (null == s ? void 0 : s.published) || (null == s ? void 0 : s.draft), d = null == h ? void 0 : h.meta; return o ? T.jsxs("div", { className: "min-h-screen flex flex-col", children: [T.jsx(ki, {}), T.jsx("main", { className: "flex-1 animate-pulse", children: T.jsxs("div", { className: "max-w-3xl mx-auto px-4 py-12", children: [T.jsx("div", { className: "h-8 bg-gray-200 dark:bg-gray-700 rounded w-3/4 mb-4" }), T.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/4 mb-8" }), T.jsx("div", { className: "space-y-4", children: [...Array(8)].map((e, t) => T.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded" }, t)) })] }) }), T.jsx(Ci, {})] }) : !l && s && h ? T.jsxs(T.Fragment, { children: [T.jsxs(Ot, { children: [T.jsxs("title", { children: [h.title, " | Next Blog"] }), T.jsx("meta", { name: "description", content: (null == d ? void 0 : d.thumbText) || h.title }), (null == d ? void 0 : d.ogImage) && T.jsx("meta", { property: "og:image", content: d.ogImage })] }), T.jsxs("div", { className: "min-h-screen flex flex-col", children: [T.jsx(ki, {}), T.jsxs("main", { className: "flex-1 bg-background-light dark:bg-background-dark", children: [T.jsxs("div", { className: "relative w-full h-[50vh] md:h-[60vh] min-h-[400px] bg-gray-900 overflow-hidden", children: [T.jsx("img", { src: (null == d ? void 0 : d.thumbImage) || Fi(s.id), alt: h.title, className: "w-full h-full object-cover opacity-80" }), T.jsx("div", { className: "absolute inset-0 bg-gradient-to-t from-background-light dark:from-background-dark via-transparent to-transparent opacity-90" }), T.jsxs("div", { className: "absolute bottom-0 left-0 right-0 p-6 md:p-12 max-w-4xl mx-auto text-center", children: [T.jsxs("div", { className: "flex items-center justify-center gap-3 mb-6 animate-fade-in-up", children: [(null == d ? void 0 : d.featured) && T.jsx("span", { className: "px-2 py-1 text-xs uppercase tracking-[0.2em] font-bold text-white bg-yellow-600/90 rounded-sm shadow-sm backdrop-blur-sm", children: n("post.featured") }), (null == d ? void 0 : d.category) && T.jsxs("span", { className: "inline-flex items-center gap-1 px-2 py-1 text-xs uppercase tracking-[0.2em] font-medium text-white/90 bg-accent/80 rounded-sm shadow-sm backdrop-blur-sm", children: [T.jsx("svg", { className: "w-3 h-3", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: T.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" }) }), r(d.category)] })] }), T.jsx("h1", { className: "font-display text-4xl md:text-6xl lg:text-7xl text-white mb-6 leading-tight text-shadow-lg animate-fade-in-up delay-100", children: h.title }), T.jsxs("div", { className: "flex items-center justify-center space-x-6 text-white/80 text-sm md:text-base font-medium animate-fade-in-up delay-200", children: [(null == d ? void 0 : d.author) && T.jsxs("div", { className: "flex items-center gap-2", children: [T.jsx("div", { className: "w-8 h-8 rounded-full bg-accent/30 flex items-center justify-center text-xs font-bold ring-1 ring-white/20", children: d.author[0] }), T.jsx("span", { children: d.author })] }), (null == d ? void 0 : d.date) && T.jsxs(T.Fragment, { children: [T.jsx("span", { children: "" }), T.jsx("time", { className: "font-mono opacity-80", children: d.date })] })] })] })] }), T.jsxs("article", { className: "max-w-3xl mx-auto px-4 sm:px-6 py-16", children: [T.jsx("div", { className: "prose prose-lg md:prose-xl dark:prose-invert mx-auto drop-cap", children: T.jsx(Mi, { children: h.text }) }), (null == d ? void 0 : d.tags) && d.tags.length > 0 && T.jsx("div", { className: "mt-16 pt-10 border-t border-gray-200 dark:border-gray-800", children: T.jsx("div", { className: "flex flex-wrap gap-3", children: d.tags.map(e => T.jsxs("a", { href: `/tag/${e}`, className: "px-4 py-1.5 text-sm font-medium text-text-light dark:text-text-dark bg-surface-light dark:bg-surface-dark border border-gray-200 dark:border-gray-700 rounded-full hover:border-accent hover:text-accent dark:hover:text-accent transition-colors duration-200", children: ["#", e] }, e)) }) })] })] }), T.jsx(Ci, {})] })] }) : T.jsxs("div", { className: "min-h-screen flex flex-col", children: [T.jsx(ki, {}), T.jsx("main", { className: "flex-1 flex items-center justify-center", children: T.jsx("p", { className: "text-muted-light dark:text-muted-dark", children: l || n("post.notFound") }) }), T.jsx(Ci, {})] }) } function Ui() { var e, t; const { category: n, tag: r, author: s } = pe(), { t: i } = Kn(), { isAuthenticated: o } = Si(), [a, l] = React.useState([]), [c, u] = React.useState([]), [h, d] = React.useState(!0), [p, f] = React.useState(!1); React.useEffect(() => { Ti().then(e => { u(e.data.categories) }).catch(console.error) }, []), React.useEffect(() => { if (n && c.length > 0) { const e = c.find(e => e.id === n || e.slug === n); f((null == e ? void 0 : e.adminOnly) || !1) } m() }, [n, r, s, c, o]); const m = async () => { try { let e; d(!0); const t = c.find(e => e.id === n || e.slug === n); if (o && (null == t ? void 0 : t.adminOnly)) { e = await ((e = 1, t = 15) => gi.get(`/posts/admin/all?page=${e}&limit=${t}`))(1, 1e3); const t = e.data.posts.filter(e => { var t, r, s; return (null == (s = null == (r = null == (t = e.draft) ? void 0 : t.meta) ? void 0 : r.category) ? void 0 : s.toLowerCase()) === (null == n ? void 0 : n.toLowerCase()) }); l(t) } else n ? (e = await ((e, t = "en") => gi.get(`/posts?category=${e}&language=${t}`))(n, "all"), l(e.data.posts)) : r ? (e = await ((e, t = "en") => gi.get(`/posts?tag=${e}&language=${t}`))(r, "all"), l(e.data.posts)) : s ? (e = await ((e, t = "en") => gi.get(`/posts?author=${e}&language=${t}`))(s, "all"), l(e.data.posts)) : (e = await Ei(), l(e.data.posts)) } catch (e) { } finally { d(!1) } }, g = c.find(e => e.id === n || e.slug === n), { i18n: E } = Kn(), A = (null == (t = null == (e = null == g ? void 0 : g.translations) ? void 0 : e[E.language]) ? void 0 : t.title) || (null == g ? void 0 : g.title) || n || r || s || "Posts"; return T.jsxs(T.Fragment, { children: [T.jsx(Ot, { children: T.jsxs("title", { children: [A, " | Next Blog"] }) }), T.jsxs("div", { className: "min-h-screen flex flex-col", children: [T.jsx(ki, {}), T.jsx("main", { className: "flex-1", children: T.jsxs("div", { className: "max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-12", children: [T.jsxs("header", { className: "mb-12", children: [T.jsxs("h1", { className: "font-display text-4xl mb-2", children: [p && o ? " " : "", A] }), T.jsxs("p", { className: "text-muted-light dark:text-muted-dark", children: [i("category.postCount", { count: a.length }), p && o && ` ${i("category.includingDrafts")}`] })] }), h ? T.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8", children: [...Array(6)].map((e, t) => T.jsxs("div", { className: "animate-pulse", children: [T.jsx("div", { className: "bg-gray-200 dark:bg-gray-700 aspect-[4/3] mb-4 rounded" }), T.jsx("div", { className: "h-6 bg-gray-200 dark:bg-gray-700 rounded w-3/4 mb-2" }), T.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/2" })] }, t)) }) : 0 === a.length ? T.jsx("div", { className: "text-center py-12 text-muted-light dark:text-muted-dark", children: i("category.noPosts") }) : T.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8", children: a.map(e => T.jsx(Ni, { post: e, showDraftBadge: p && o }, e.id)) })] }) }), T.jsx(Ci, {})] })] }) } function Hi() { return T.jsx(bt, { children: T.jsx(Rt, { children: T.jsx(_i, { children: T.jsx(ve, { children: T.jsxs(Ne, { children: [T.jsx(ke, { path: "/", element: T.jsx(Ii, {}) }), T.jsx(ke, { path: "/posts/:yearMonth/:slug", element: T.jsx(Bi, {}) }), T.jsx(ke, { path: "/category/:category", element: T.jsx(Ui, {}) }), T.jsx(ke, { path: "/tag/:tag", element: T.jsx(Ui, {}) }), T.jsx(ke, { path: "/author/:author", element: T.jsx(Ui, {}) }), T.jsx(ke, { path: "*", element: T.jsx(Se, { to: "/", replace: !0 }) })] }) }) }) }) }) } const ji = { brand: "", footer: { copyright: " {{year}} Next Blog. MIT License." }, nav: { home: "Home", tutorials: "Tutorials", admin: "Admin", categories: "Categories" }, home: { title: "Blog", featured: "Featured", latest: "Latest Posts", readMore: "Read More", noPosts: "No posts yet.", loading: "Loading...", failedToLoad: "Failed to load posts" }, post: { by: "By", published: "Published", share: "Share", readArticle: "Read article ", featured: " Featured", draft: " Unpublished", notFound: "Post not found" }, category: { postCount: "{{count}} post", postCount_plural: "{{count}} posts", includingDrafts: "(including drafts)", noPosts: "No posts found." } }, Gi = Object.freeze(Object.defineProperty({ __proto__: null, default: ji }, Symbol.toStringTag, { value: "Module" })), zi = { en: { translation: ji }, poj: { translation: {} }, hanlo: { translation: {} } }; yn.use(Ln).init({ resources: zi, lng: "en", fallbackLng: "en", interpolation: { escapeValue: !1 } }), yn.on("languageChanged", async e => { if ("en" !== e && 0 === Object.keys(yn.getResourceBundle(e, "translation") || {}).length) { const t = await (async e => { switch (e) { case "poj": return (await xi(async () => { const { default: e } = await Promise.resolve().then(() => dg); return { default: e } }, void 0, import.meta.url)).default; case "hanlo": return (await xi(async () => { const { default: e } = await Promise.resolve().then(() => pg); return { default: e } }, void 0, import.meta.url)).default; default: return (await xi(async () => { const { default: e } = await Promise.resolve().then(() => Gi); return { default: e } }, void 0, import.meta.url)).default } })(e); yn.addResourceBundle(e, "translation", t, !0, !0) } }); class Yi extends React.Component { constructor(e) { super(e), this.state = { hasError: !1, error: null } } static getDerivedStateFromError(e) { return { hasError: !0, error: e } } componentDidCatch(e, t) { } render() { var e, t; return this.state.hasError ? T.jsxs("div", { style: { padding: "20px", color: "red" }, children: [T.jsx("h1", { children: "Something went wrong." }), T.jsx("pre", { children: null == (e = this.state.error) ? void 0 : e.toString() }), T.jsx("pre", { children: null == (t = this.state.error) ? void 0 : t.stack })] }) : this.props.children } } function qi() { } function Vi() { } function $i(e) { const t = [], n = String(e || ""); let r = n.indexOf(","), s = 0, i = !1; for (; !i;) { -1 === r && (r = n.length, i = !0); const e = n.slice(s, r).trim(); !e && i || t.push(e), s = r + 1, r = n.indexOf(",", s) } return t } function Wi(e, t) { const n = {}; return ("" === e[e.length - 1] ? [...e, ""] : e).join((n.padRight ? " " : "") + "," + (!1 === n.padLeft ? "" : " ")).trim() } ReactDOM.createRoot(document.getElementById("root")).render(T.jsx(React.StrictMode, { children: T.jsx(Yi, { children: T.jsx(Hi, {}) }) })); const Ki = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Qi = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Xi = {}; function Ji(e, t) { return (Xi.jsx ? Qi : Ki).test(e) } const Zi = /[ \t\n\f\r]/g; function eo(e) { return "" === e.replace(Zi, "") } class to { constructor(e, t, n) { this.normal = t, this.property = e, n && (this.space = n) } } function no(e, t) { const n = {}, r = {}; for (const s of e) Object.assign(n, s.property), Object.assign(r, s.normal); return new to(n, r, t) } function ro(e) { return e.toLowerCase() } to.prototype.normal = {}, to.prototype.property = {}, to.prototype.space = void 0; class so { constructor(e, t) { this.attribute = t, this.property = e } } so.prototype.attribute = "", so.prototype.booleanish = !1, so.prototype.boolean = !1, so.prototype.commaOrSpaceSeparated = !1, so.prototype.commaSeparated = !1, so.prototype.defined = !1, so.prototype.mustUseProperty = !1, so.prototype.number = !1, so.prototype.overloadedBoolean = !1, so.prototype.property = "", so.prototype.spaceSeparated = !1, so.prototype.space = void 0; let io = 0; const oo = fo(), ao = fo(), lo = fo(), co = fo(), uo = fo(), ho = fo(), po = fo(); function fo() { return 2 ** ++io } const mo = Object.freeze(Object.defineProperty({ __proto__: null, boolean: oo, booleanish: ao, commaOrSpaceSeparated: po, commaSeparated: ho, number: co, overloadedBoolean: lo, spaceSeparated: uo }, Symbol.toStringTag, { value: "Module" })), go = Object.keys(mo); class Eo extends so { constructor(e, t, n, r) { let s = -1; if (super(e, t), To(this, "space", r), "number" == typeof n) for (; ++s < go.length;) { const e = go[s]; To(this, go[s], (n & mo[e]) === mo[e]) } } } function To(e, t, n) { n && (e[t] = n) } function Ao(e) { const t = {}, n = {}; for (const [r, s] of Object.entries(e.properties)) { const i = new Eo(r, e.transform(e.attributes || {}, r), s, e.space); e.mustUseProperty && e.mustUseProperty.includes(r) && (i.mustUseProperty = !0), t[r] = i, n[ro(r)] = r, n[ro(i.attribute)] = r } return new to(t, n, e.space) } Eo.prototype.defined = !0; const _o = Ao({ properties: { ariaActiveDescendant: null, ariaAtomic: ao, ariaAutoComplete: null, ariaBusy: ao, ariaChecked: ao, ariaColCount: co, ariaColIndex: co, ariaColSpan: co, ariaControls: uo, ariaCurrent: null, ariaDescribedBy: uo, ariaDetails: null, ariaDisabled: ao, ariaDropEffect: uo, ariaErrorMessage: null, ariaExpanded: ao, ariaFlowTo: uo, ariaGrabbed: ao, ariaHasPopup: null, ariaHidden: ao, ariaInvalid: null, ariaKeyShortcuts: null, ariaLabel: null, ariaLabelledBy: uo, ariaLevel: co, ariaLive: null, ariaModal: ao, ariaMultiLine: ao, ariaMultiSelectable: ao, ariaOrientation: null, ariaOwns: uo, ariaPlaceholder: null, ariaPosInSet: co, ariaPressed: ao, ariaReadOnly: ao, ariaRelevant: null, ariaRequired: ao, ariaRoleDescription: uo, ariaRowCount: co, ariaRowIndex: co, ariaRowSpan: co, ariaSelected: ao, ariaSetSize: co, ariaSort: null, ariaValueMax: co, ariaValueMin: co, ariaValueNow: co, ariaValueText: null, role: null }, transform: (e, t) => "role" === t ? t : "aria-" + t.slice(4).toLowerCase() }); function yo(e, t) { return t in e ? e[t] : t } function bo(e, t) { return yo(e, t.toLowerCase()) } const So = Ao({ attributes: { acceptcharset: "accept-charset", classname: "class", htmlfor: "for", httpequiv: "http-equiv" }, mustUseProperty: ["checked", "multiple", "muted", "selected"], properties: { abbr: null, accept: ho, acceptCharset: uo, accessKey: uo, action: null, allow: null, allowFullScreen: oo, allowPaymentRequest: oo, allowUserMedia: oo, alt: null, as: null, async: oo, autoCapitalize: null, autoComplete: uo, autoFocus: oo, autoPlay: oo, blocking: uo, capture: null, charSet: null, checked: oo, cite: null, className: uo, cols: co, colSpan: null, content: null, contentEditable: ao, controls: oo, controlsList: uo, coords: co | ho, crossOrigin: null, data: null, dateTime: null, decoding: null, default: oo, defer: oo, dir: null, dirName: null, disabled: oo, download: lo, draggable: ao, encType: null, enterKeyHint: null, fetchPriority: null, form: null, formAction: null, formEncType: null, formMethod: null, formNoValidate: oo, formTarget: null, headers: uo, height: co, hidden: lo, high: co, href: null, hrefLang: null, htmlFor: uo, httpEquiv: uo, id: null, imageSizes: null, imageSrcSet: null, inert: oo, inputMode: null, integrity: null, is: null, isMap: oo, itemId: null, itemProp: uo, itemRef: uo, itemScope: oo, itemType: uo, kind: null, label: null, lang: null, language: null, list: null, loading: null, loop: oo, low: co, manifest: null, max: null, maxLength: co, media: null, method: null, min: null, minLength: co, multiple: oo, muted: oo, name: null, nonce: null, noModule: oo, noValidate: oo, onAbort: null, onAfterPrint: null, onAuxClick: null, onBeforeMatch: null, onBeforePrint: null, onBeforeToggle: null, onBeforeUnload: null, onBlur: null, onCancel: null, onCanPlay: null, onCanPlayThrough: null, onChange: null, onClick: null, onClose: null, onContextLost: null, onContextMenu: null, onContextRestored: null, onCopy: null, onCueChange: null, onCut: null, onDblClick: null, onDrag: null, onDragEnd: null, onDragEnter: null, onDragExit: null, onDragLeave: null, onDragOver: null, onDragStart: null, onDrop: null, onDurationChange: null, onEmptied: null, onEnded: null, onError: null, onFocus: null, onFormData: null, onHashChange: null, onInput: null, onInvalid: null, onKeyDown: null, onKeyPress: null, onKeyUp: null, onLanguageChange: null, onLoad: null, onLoadedData: null, onLoadedMetadata: null, onLoadEnd: null, onLoadStart: null, onMessage: null, onMessageError: null, onMouseDown: null, onMouseEnter: null, onMouseLeave: null, onMouseMove: null, onMouseOut: null, onMouseOver: null, onMouseUp: null, onOffline: null, onOnline: null, onPageHide: null, onPageShow: null, onPaste: null, onPause: null, onPlay: null, onPlaying: null, onPopState: null, onProgress: null, onRateChange: null, onRejectionHandled: null, onReset: null, onResize: null, onScroll: null, onScrollEnd: null, onSecurityPolicyViolation: null, onSeeked: null, onSeeking: null, onSelect: null, onSlotChange: null, onStalled: null, onStorage: null, onSubmit: null, onSuspend: null, onTimeUpdate: null, onToggle: null, onUnhandledRejection: null, onUnload: null, onVolumeChange: null, onWaiting: null, onWheel: null, open: oo, optimum: co, pattern: null, ping: uo, placeholder: null, playsInline: oo, popover: null, popoverTarget: null, popoverTargetAction: null, poster: null, preload: null, readOnly: oo, referrerPolicy: null, rel: uo, required: oo, reversed: oo, rows: co, rowSpan: co, sandbox: uo, scope: null, scoped: oo, seamless: oo, selected: oo, shadowRootClonable: oo, shadowRootDelegatesFocus: oo, shadowRootMode: null, shape: null, size: co, sizes: null, slot: null, span: co, spellCheck: ao, src: null, srcDoc: null, srcLang: null, srcSet: null, start: co, step: null, style: null, tabIndex: co, target: null, title: null, translate: null, type: null, typeMustMatch: oo, useMap: null, value: ao, width: co, wrap: null, writingSuggestions: null, align: null, aLink: null, archive: uo, axis: null, background: null, bgColor: null, border: co, borderColor: null, bottomMargin: co, cellPadding: null, cellSpacing: null, char: null, charOff: null, classId: null, clear: null, code: null, codeBase: null, codeType: null, color: null, compact: oo, declare: oo, event: null, face: null, frame: null, frameBorder: null, hSpace: co, leftMargin: co, link: null, longDesc: null, lowSrc: null, marginHeight: co, marginWidth: co, noResize: oo, noHref: oo, noShade: oo, noWrap: oo, object: null, profile: null, prompt: null, rev: null, rightMargin: co, rules: null, scheme: null, scrolling: ao, standby: null, summary: null, text: null, topMargin: co, valueType: null, version: null, vAlign: null, vLink: null, vSpace: co, allowTransparency: null, autoCorrect: null, autoSave: null, disablePictureInPicture: oo, disableRemotePlayback: oo, prefix: null, property: null, results: co, security: null, unselectable: null }, space: "html", transform: bo }), ko = Ao({ attributes: { accentHeight: "accent-height", alignmentBaseline: "alignment-baseline", arabicForm: "arabic-form", baselineShift: "baseline-shift", capHeight: "cap-height", className: "class", clipPath: "clip-path", clipRule: "clip-rule", colorInterpolation: "color-interpolation", colorInterpolationFilters: "color-interpolation-filters", colorProfile: "color-profile", colorRendering: "color-rendering", crossOrigin: "crossorigin", dataType: "datatype", dominantBaseline: "dominant-baseline", enableBackground: "enable-background", fillOpacity: "fill-opacity", fillRule: "fill-rule", floodColor: "flood-color", floodOpacity: "flood-opacity", fontFamily: "font-family", fontSize: "font-size", fontSizeAdjust: "font-size-adjust", fontStretch: "font-stretch", fontStyle: "font-style", fontVariant: "font-variant", fontWeight: "font-weight", glyphName: "glyph-name", glyphOrientationHorizontal: "glyph-orientation-horizontal", glyphOrientationVertical: "glyph-orientation-vertical", hrefLang: "hreflang", horizAdvX: "horiz-adv-x", horizOriginX: "horiz-origin-x", horizOriginY: "horiz-origin-y", imageRendering: "image-rendering", letterSpacing: "letter-spacing", lightingColor: "lighting-color", markerEnd: "marker-end", markerMid: "marker-mid", markerStart: "marker-start", navDown: "nav-down", navDownLeft: "nav-down-left", navDownRight: "nav-down-right", navLeft: "nav-left", navNext: "nav-next", navPrev: "nav-prev", navRight: "nav-right", navUp: "nav-up", navUpLeft: "nav-up-left", navUpRight: "nav-up-right", onAbort: "onabort", onActivate: "onactivate", onAfterPrint: "onafterprint", onBeforePrint: "onbeforeprint", onBegin: "onbegin", onCancel: "oncancel", onCanPlay: "oncanplay", onCanPlayThrough: "oncanplaythrough", onChange: "onchange", onClick: "onclick", onClose: "onclose", onCopy: "oncopy", onCueChange: "oncuechange", onCut: "oncut", onDblClick: "ondblclick", onDrag: "ondrag", onDragEnd: "ondragend", onDragEnter: "ondragenter", onDragExit: "ondragexit", onDragLeave: "ondragleave", onDragOver: "ondragover", onDragStart: "ondragstart", onDrop: "ondrop", onDurationChange: "ondurationchange", onEmptied: "onemptied", onEnd: "onend", onEnded: "onended", onError: "onerror", onFocus: "onfocus", onFocusIn: "onfocusin", onFocusOut: "onfocusout", onHashChange: "onhashchange", onInput: "oninput", onInvalid: "oninvalid", onKeyDown: "onkeydown", onKeyPress: "onkeypress", onKeyUp: "onkeyup", onLoad: "onload", onLoadedData: "onloadeddata", onLoadedMetadata: "onloadedmetadata", onLoadStart: "onloadstart", onMessage: "onmessage", onMouseDown: "onmousedown", onMouseEnter: "onmouseenter", onMouseLeave: "onmouseleave", onMouseMove: "onmousemove", onMouseOut: "onmouseout", onMouseOver: "onmouseover", onMouseUp: "onmouseup", onMouseWheel: "onmousewheel", onOffline: "onoffline", onOnline: "ononline", onPageHide: "onpagehide", onPageShow: "onpageshow", onPaste: "onpaste", onPause: "onpause", onPlay: "onplay", onPlaying: "onplaying", onPopState: "onpopstate", onProgress: "onprogress", onRateChange: "onratechange", onRepeat: "onrepeat", onReset: "onreset", onResize: "onresize", onScroll: "onscroll", onSeeked: "onseeked", onSeeking: "onseeking", onSelect: "onselect", onShow: "onshow", onStalled: "onstalled", onStorage: "onstorage", onSubmit: "onsubmit", onSuspend: "onsuspend", onTimeUpdate: "ontimeupdate", onToggle: "ontoggle", onUnload: "onunload", onVolumeChange: "onvolumechange", onWaiting: "onwaiting", onZoom: "onzoom", overlinePosition: "overline-position", overlineThickness: "overline-thickness", paintOrder: "paint-order", panose1: "panose-1", pointerEvents: "pointer-events", referrerPolicy: "referrerpolicy", renderingIntent: "rendering-intent", shapeRendering: "shape-rendering", stopColor: "stop-color", stopOpacity: "stop-opacity", strikethroughPosition: "strikethrough-position", strikethroughThickness: "strikethrough-thickness", strokeDashArray: "stroke-dasharray", strokeDashOffset: "stroke-dashoffset", strokeLineCap: "stroke-linecap", strokeLineJoin: "stroke-linejoin", strokeMiterLimit: "stroke-miterlimit", strokeOpacity: "stroke-opacity", strokeWidth: "stroke-width", tabIndex: "tabindex", textAnchor: "text-anchor", textDecoration: "text-decoration", textRendering: "text-rendering", transformOrigin: "transform-origin", typeOf: "typeof", underlinePosition: "underline-position", underlineThickness: "underline-thickness", unicodeBidi: "unicode-bidi", unicodeRange: "unicode-range", unitsPerEm: "units-per-em", vAlphabetic: "v-alphabetic", vHanging: "v-hanging", vIdeographic: "v-ideographic", vMathematical: "v-mathematical", vectorEffect: "vector-effect", vertAdvY: "vert-adv-y", vertOriginX: "vert-origin-x", vertOriginY: "vert-origin-y", wordSpacing: "word-spacing", writingMode: "writing-mode", xHeight: "x-height", playbackOrder: "playbackorder", timelineBegin: "timelinebegin" }, properties: { about: po, accentHeight: co, accumulate: null, additive: null, alignmentBaseline: null, alphabetic: co, amplitude: co, arabicForm: null, ascent: co, attributeName: null, attributeType: null, azimuth: co, bandwidth: null, baselineShift: null, baseFrequency: null, baseProfile: null, bbox: null, begin: null, bias: co, by: null, calcMode: null, capHeight: co, className: uo, clip: null, clipPath: null, clipPathUnits: null, clipRule: null, color: null, colorInterpolation: null, colorInterpolationFilters: null, colorProfile: null, colorRendering: null, content: null, contentScriptType: null, contentStyleType: null, crossOrigin: null, cursor: null, cx: null, cy: null, d: null, dataType: null, defaultAction: null, descent: co, diffuseConstant: co, direction: null, display: null, dur: null, divisor: co, dominantBaseline: null, download: oo, dx: null, dy: null, edgeMode: null, editable: null, elevation: co, enableBackground: null, end: null, event: null, exponent: co, externalResourcesRequired: null, fill: null, fillOpacity: co, fillRule: null, filter: null, filterRes: null, filterUnits: null, floodColor: null, floodOpacity: null, focusable: null, focusHighlight: null, fontFamily: null, fontSize: null, fontSizeAdjust: null, fontStretch: null, fontStyle: null, fontVariant: null, fontWeight: null, format: null, fr: null, from: null, fx: null, fy: null, g1: ho, g2: ho, glyphName: ho, glyphOrientationHorizontal: null, glyphOrientationVertical: null, glyphRef: null, gradientTransform: null, gradientUnits: null, handler: null, hanging: co, hatchContentUnits: null, hatchUnits: null, height: null, href: null, hrefLang: null, horizAdvX: co, horizOriginX: co, horizOriginY: co, id: null, ideographic: co, imageRendering: null, initialVisibility: null, in: null, in2: null, intercept: co, k: co, k1: co, k2: co, k3: co, k4: co, kernelMatrix: po, kernelUnitLength: null, keyPoints: null, keySplines: null, keyTimes: null, kerning: null, lang: null, lengthAdjust: null, letterSpacing: null, lightingColor: null, limitingConeAngle: co, local: null, markerEnd: null, markerMid: null, markerStart: null, markerHeight: null, markerUnits: null, markerWidth: null, mask: null, maskContentUnits: null, maskUnits: null, mathematical: null, max: null, media: null, mediaCharacterEncoding: null, mediaContentEncodings: null, mediaSize: co, mediaTime: null, method: null, min: null, mode: null, name: null, navDown: null, navDownLeft: null, navDownRight: null, navLeft: null, navNext: null, navPrev: null, navRight: null, navUp: null, navUpLeft: null, navUpRight: null, numOctaves: null, observer: null, offset: null, onAbort: null, onActivate: null, onAfterPrint: null, onBeforePrint: null, onBegin: null, onCancel: null, onCanPlay: null, onCanPlayThrough: null, onChange: null, onClick: null, onClose: null, onCopy: null, onCueChange: null, onCut: null, onDblClick: null, onDrag: null, onDragEnd: null, onDragEnter: null, onDragExit: null, onDragLeave: null, onDragOver: null, onDragStart: null, onDrop: null, onDurationChange: null, onEmptied: null, onEnd: null, onEnded: null, onError: null, onFocus: null, onFocusIn: null, onFocusOut: null, onHashChange: null, onInput: null, onInvalid: null, onKeyDown: null, onKeyPress: null, onKeyUp: null, onLoad: null, onLoadedData: null, onLoadedMetadata: null, onLoadStart: null, onMessage: null, onMouseDown: null, onMouseEnter: null, onMouseLeave: null, onMouseMove: null, onMouseOut: null, onMouseOver: null, onMouseUp: null, onMouseWheel: null, onOffline: null, onOnline: null, onPageHide: null, onPageShow: null, onPaste: null, onPause: null, onPlay: null, onPlaying: null, onPopState: null, onProgress: null, onRateChange: null, onRepeat: null, onReset: null, onResize: null, onScroll: null, onSeeked: null, onSeeking: null, onSelect: null, onShow: null, onStalled: null, onStorage: null, onSubmit: null, onSuspend: null, onTimeUpdate: null, onToggle: null, onUnload: null, onVolumeChange: null, onWaiting: null, onZoom: null, opacity: null, operator: null, order: null, orient: null, orientation: null, origin: null, overflow: null, overlay: null, overlinePosition: co, overlineThickness: co, paintOrder: null, panose1: null, path: null, pathLength: co, patternContentUnits: null, patternTransform: null, patternUnits: null, phase: null, ping: uo, pitch: null, playbackOrder: null, pointerEvents: null, points: null, pointsAtX: co, pointsAtY: co, pointsAtZ: co, preserveAlpha: null, preserveAspectRatio: null, primitiveUnits: null, propagate: null, property: po, r: null, radius: null, referrerPolicy: null, refX: null, refY: null, rel: po, rev: po, renderingIntent: null, repeatCount: null, repeatDur: null, requiredExtensions: po, requiredFeatures: po, requiredFonts: po, requiredFormats: po, resource: null, restart: null, result: null, rotate: null, rx: null, ry: null, scale: null, seed: null, shapeRendering: null, side: null, slope: null, snapshotTime: null, specularConstant: co, specularExponent: co, spreadMethod: null, spacing: null, startOffset: null, stdDeviation: null, stemh: null, stemv: null, stitchTiles: null, stopColor: null, stopOpacity: null, strikethroughPosition: co, strikethroughThickness: co, string: null, stroke: null, strokeDashArray: po, strokeDashOffset: null, strokeLineCap: null, strokeLineJoin: null, strokeMiterLimit: co, strokeOpacity: co, strokeWidth: null, style: null, surfaceScale: co, syncBehavior: null, syncBehaviorDefault: null, syncMaster: null, syncTolerance: null, syncToleranceDefault: null, systemLanguage: po, tabIndex: co, tableValues: null, target: null, targetX: co, targetY: co, textAnchor: null, textDecoration: null, textRendering: null, textLength: null, timelineBegin: null, title: null, transformBehavior: null, type: null, typeOf: po, to: null, transform: null, transformOrigin: null, u1: null, u2: null, underlinePosition: co, underlineThickness: co, unicode: null, unicodeBidi: null, unicodeRange: null, unitsPerEm: co, values: null, vAlphabetic: co, vMathematical: co, vectorEffect: null, vHanging: co, vIdeographic: co, version: null, vertAdvY: co, vertOriginX: co, vertOriginY: co, viewBox: null, viewTarget: null, visibility: null, width: null, widths: null, wordSpacing: null, writingMode: null, x: null, x1: null, x2: null, xChannelSelector: null, xHeight: co, y: null, y1: null, y2: null, yChannelSelector: null, z: null, zoomAndPan: null }, space: "svg", transform: yo }), Co = Ao({ properties: { xLinkActuate: null, xLinkArcRole: null, xLinkHref: null, xLinkRole: null, xLinkShow: null, xLinkTitle: null, xLinkType: null }, space: "xlink", transform: (e, t) => "xlink:" + t.slice(5).toLowerCase() }), No = Ao({ attributes: { xmlnsxlink: "xmlns:xlink" }, properties: { xmlnsXLink: null, xmlns: null }, space: "xmlns", transform: bo }), Io = Ao({ properties: { xmlBase: null, xmlLang: null, xmlSpace: null }, space: "xml", transform: (e, t) => "xml:" + t.slice(3).toLowerCase() }), Oo = { classId: "classID", dataType: "datatype", itemId: "itemID", strokeDashArray: "strokeDasharray", strokeDashOffset: "strokeDashoffset", strokeLineCap: "strokeLinecap", strokeLineJoin: "strokeLinejoin", strokeMiterLimit: "strokeMiterlimit", typeOf: "typeof", xLinkActuate: "xlinkActuate", xLinkArcRole: "xlinkArcrole", xLinkHref: "xlinkHref", xLinkRole: "xlinkRole", xLinkShow: "xlinkShow", xLinkTitle: "xlinkTitle", xLinkType: "xlinkType", xmlnsXLink: "xmlnsXlink" }, xo = /[A-Z]/g, Ro = /-[a-z]/g, vo = /^data[-\w.:]+$/i; function Do(e, t) { const n = ro(t); let r = t, s = so; if (n in e.normal) return e.property[e.normal[n]]; if (n.length > 4 && "data" === n.slice(0, 4) && vo.test(t)) { if ("-" === t.charAt(4)) { const e = t.slice(5).replace(Ro, Po); r = "data" + e.charAt(0).toUpperCase() + e.slice(1) } else { const e = t.slice(4); if (!Ro.test(e)) { let n = e.replace(xo, Lo); "-" !== n.charAt(0) && (n = "-" + n), t = "data" + n } } s = Eo } return new s(r, t) } function Lo(e) { return "-" + e.toLowerCase() } function Po(e) { return e.charAt(1).toUpperCase() } const wo = no([_o, So, Co, No, Io], "html"), Mo = no([_o, ko, Co, No, Io], "svg"); function Fo(e) { const t = String(e || "").trim(); return t ? t.split(/[ \t\n\r\f]+/g) : [] } function Bo(e) { return e.join(" ").trim() } var Uo = {}, Ho = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, jo = /\n/g, Go = /^\s*/, zo = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Yo = /^:\s*/, qo = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Vo = /^[;\s]*/, $o = /^\s+|\s+$/g, Wo = ""; function Ko(e) { return e ? e.replace($o, Wo) : Wo } var Qo = s && s.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(Uo, "__esModule", { value: !0 }), Uo.default = function (e, t) { let n = null; if (!e || "string" != typeof e) return n; const r = (0, Xo.default)(e), s = "function" == typeof t; return r.forEach(e => { if ("declaration" !== e.type) return; const { property: r, value: i } = e; s ? t(r, i, e) : i && (n = n || {}, n[r] = i) }), n }; const Xo = Qo(function (e, t) { if ("string" != typeof e) throw new TypeError("First argument must be a string"); if (!e) return []; t = t || {}; var n = 1, r = 1; function s(e) { var t = e.match(jo); t && (n += t.length); var s = e.lastIndexOf("\n"); r = ~s ? e.length - s : r + e.length } function i() { var e = { line: n, column: r }; return function (t) { return t.position = new o(e), c(), t } } function o(e) { this.start = e, this.end = { line: n, column: r }, this.source = t.source } function a(s) { var i = new Error(t.source + ":" + n + ":" + r + ": " + s); if (i.reason = s, i.filename = t.source, i.line = n, i.column = r, i.source = e, !t.silent) throw i } function l(t) { var n = t.exec(e); if (n) { var r = n[0]; return s(r), e = e.slice(r.length), n } } function c() { l(Go) } function u(e) { var t; for (e = e || []; t = h();)!1 !== t && e.push(t); return e } function h() { var t = i(); if ("/" == e.charAt(0) && "*" == e.charAt(1)) { for (var n = 2; Wo != e.charAt(n) && ("*" != e.charAt(n) || "/" != e.charAt(n + 1));)++n; if (n += 2, Wo === e.charAt(n - 1)) return a("End of comment missing"); var o = e.slice(2, n - 2); return r += 2, s(o), e = e.slice(n), r += 2, t({ type: "comment", comment: o }) } } function d() { var e = i(), t = l(zo); if (t) { if (h(), !l(Yo)) return a("property missing ':'"); var n = l(qo), r = e({ type: "declaration", property: Ko(t[0].replace(Ho, Wo)), value: n ? Ko(n[0].replace(Ho, Wo)) : Wo }); return l(Vo), r } } return o.prototype.content = e, c(), function () { var e, t = []; for (u(t); e = d();)!1 !== e && (t.push(e), u(t)); return t }() }); var Jo = {}; Object.defineProperty(Jo, "__esModule", { value: !0 }), Jo.camelCase = void 0; var Zo = /^--[a-zA-Z0-9_-]+$/, ea = /-([a-z])/g, ta = /^[^-]+$/, na = /^-(webkit|moz|ms|o|khtml)-/, ra = /^-(ms)-/, sa = function (e, t) { return t.toUpperCase() }, ia = function (e, t) { return "".concat(t, "-") }; Jo.camelCase = function (e, t) { return void 0 === t && (t = {}), function (e) { return !e || ta.test(e) || Zo.test(e) }(e) ? e : (e = e.toLowerCase(), (e = t.reactCompat ? e.replace(ra, ia) : e.replace(na, ia)).replace(ea, sa)) }; var oa = (s && s.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } })(Uo), aa = Jo; function la(e, t) { var n = {}; return e && "string" == typeof e ? ((0, oa.default)(e, function (e, r) { e && r && (n[(0, aa.camelCase)(e, t)] = r) }), n) : n } la.default = la; const ca = i(la), ua = da("end"), ha = da("start"); function da(e) { return function (t) { const n = t && t.position && t.position[e] || {}; if ("number" == typeof n.line && n.line > 0 && "number" == typeof n.column && n.column > 0) return { line: n.line, column: n.column, offset: "number" == typeof n.offset && n.offset > -1 ? n.offset : void 0 } } } function pa(e) { return e && "object" == typeof e ? "position" in e || "type" in e ? ma(e.position) : "start" in e || "end" in e ? ma(e) : "line" in e || "column" in e ? fa(e) : "" : "" } function fa(e) { return ga(e && e.line) + ":" + ga(e && e.column) } function ma(e) { return fa(e && e.start) + "-" + fa(e && e.end) } function ga(e) { return e && "number" == typeof e ? e : 1 } class Ea extends Error { constructor(e, t, n) { super(), "string" == typeof t && (n = t, t = void 0); let r = "", s = {}, i = !1; if (t && (s = "line" in t && "column" in t || "start" in t && "end" in t ? { place: t } : "type" in t ? { ancestors: [t], place: t.position } : { ...t }), "string" == typeof e ? r = e : !s.cause && e && (i = !0, r = e.message, s.cause = e), !s.ruleId && !s.source && "string" == typeof n) { const e = n.indexOf(":"); -1 === e ? s.ruleId = n : (s.source = n.slice(0, e), s.ruleId = n.slice(e + 1)) } if (!s.place && s.ancestors && s.ancestors) { const e = s.ancestors[s.ancestors.length - 1]; e && (s.place = e.position) } const o = s.place && "start" in s.place ? s.place.start : s.place; this.ancestors = s.ancestors || void 0, this.cause = s.cause || void 0, this.column = o ? o.column : void 0, this.fatal = void 0, this.file = "", this.message = r, this.line = o ? o.line : void 0, this.name = pa(s.place) || "1:1", this.place = s.place || void 0, this.reason = this.message, this.ruleId = s.ruleId || void 0, this.source = s.source || void 0, this.stack = i && s.cause && "string" == typeof s.cause.stack ? s.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0 } } Ea.prototype.file = "", Ea.prototype.name = "", Ea.prototype.reason = "", Ea.prototype.message = "", Ea.prototype.stack = "", Ea.prototype.column = void 0, Ea.prototype.line = void 0, Ea.prototype.ancestors = void 0, Ea.prototype.cause = void 0, Ea.prototype.fatal = void 0, Ea.prototype.place = void 0, Ea.prototype.ruleId = void 0, Ea.prototype.source = void 0; const Ta = {}.hasOwnProperty, Aa = new Map, _a = /[A-Z]/g, ya = new Set(["table", "tbody", "thead", "tfoot", "tr"]), ba = new Set(["td", "th"]), Sa = "https://github.com/syntax-tree/hast-util-to-jsx-runtime"; function ka(e, t, n) { return "element" === t.type ? function (e, t, n) { const r = e.schema; let s = r; "svg" === t.tagName.toLowerCase() && "html" === r.space && (s = Mo, e.schema = s), e.ancestors.push(t); const i = xa(e, t.tagName, !1), o = function (e, t) { const n = {}; let r, s; for (s in t.properties) if ("children" !== s && Ta.call(t.properties, s)) { const i = Oa(e, s, t.properties[s]); if (i) { const [s, o] = i; e.tableCellAlignToStyle && "align" === s && "string" == typeof o && ba.has(t.tagName) ? r = o : n[s] = o } } return r && ((n.style || (n.style = {}))["css" === e.stylePropertyNameCase ? "text-align" : "textAlign"] = r), n }(e, t); let a = Ia(e, t); return ya.has(t.tagName) && (a = a.filter(function (e) { return "string" != typeof e || !("object" == typeof (t = e) ? "text" === t.type && eo(t.value) : eo(t)); var t })), Ca(e, o, i, t), Na(o, a), e.ancestors.pop(), e.schema = r, e.create(t, i, o, n) }(e, t, n) : "mdxFlowExpression" === t.type || "mdxTextExpression" === t.type ? function (e, t) { if (t.data && t.data.estree && e.evaluater) { const n = t.data.estree.body[0]; return n.type, e.evaluater.evaluateExpression(n.expression) } Ra(e, t.position) }(e, t) : "mdxJsxFlowElement" === t.type || "mdxJsxTextElement" === t.type ? function (e, t, n) { const r = e.schema; let s = r; "svg" === t.name && "html" === r.space && (s = Mo, e.schema = s), e.ancestors.push(t); const i = null === t.name ? e.Fragment : xa(e, t.name, !0), o = function (e, t) { const n = {}; for (const r of t.attributes) if ("mdxJsxExpressionAttribute" === r.type) if (r.data && r.data.estree && e.evaluater) { const t = r.data.estree.body[0]; qi(t.type); const s = t.expression; qi(s.type); const i = s.properties[0]; qi(i.type), Object.assign(n, e.evaluater.evaluateExpression(i.argument)) } else Ra(e, t.position); else { const s = r.name; let i; if (r.value && "object" == typeof r.value) if (r.value.data && r.value.data.estree && e.evaluater) { const t = r.value.data.estree.body[0]; qi(t.type), i = e.evaluater.evaluateExpression(t.expression) } else Ra(e, t.position); else i = null === r.value || r.value; n[s] = i } return n }(e, t), a = Ia(e, t); return Ca(e, o, i, t), Na(o, a), e.ancestors.pop(), e.schema = r, e.create(t, i, o, n) }(e, t, n) : "mdxjsEsm" === t.type ? function (e, t) { if (t.data && t.data.estree && e.evaluater) return e.evaluater.evaluateProgram(t.data.estree); Ra(e, t.position) }(e, t) : "root" === t.type ? function (e, t, n) { const r = {}; return Na(r, Ia(e, t)), e.create(t, e.Fragment, r, n) }(e, t, n) : "text" === t.type ? function (e, t) { return t.value }(0, t) : void 0 } function Ca(e, t, n, r) { "string" != typeof n && n !== e.Fragment && e.passNode && (t.node = r) } function Na(e, t) { if (t.length > 0) { const n = t.length > 1 ? t : t[0]; n && (e.children = n) } } function Ia(e, t) { const n = []; let r = -1; const s = e.passKeys ? new Map : Aa; for (; ++r < t.children.length;) { const i = t.children[r]; let o; if (e.passKeys) { const e = "element" === i.type ? i.tagName : "mdxJsxFlowElement" === i.type || "mdxJsxTextElement" === i.type ? i.name : void 0; if (e) { const t = s.get(e) || 0; o = e + "-" + t, s.set(e, t + 1) } } const a = ka(e, i, o); void 0 !== a && n.push(a) } return n } function Oa(e, t, n) { const r = Do(e.schema, t); if (!(null == n || "number" == typeof n && Number.isNaN(n))) { if (Array.isArray(n) && (n = r.commaSeparated ? Wi(n) : Bo(n)), "style" === r.property) { let t = "object" == typeof n ? n : function (e, t) { try { return ca(t, { reactCompat: !0 }) } catch (n) { if (e.ignoreInvalidStyle) return {}; const t = n, r = new Ea("Cannot parse `style` attribute", { ancestors: e.ancestors, cause: t, ruleId: "style", source: "hast-util-to-jsx-runtime" }); throw r.file = e.filePath || void 0, r.url = Sa + "#cannot-parse-style-attribute", r } }(e, String(n)); return "css" === e.stylePropertyNameCase && (t = function (e) { const t = {}; let n; for (n in e) Ta.call(e, n) && (t[va(n)] = e[n]); return t }(t)), ["style", t] } return ["react" === e.elementAttributeNameCase && r.space ? Oo[r.property] || r.property : r.attribute, n] } } function xa(e, t, n) { let r; if (n) if (t.includes(".")) { const e = t.split("."); let n, s = -1; for (; ++s < e.length;) { const t = Ji(e[s]) ? { type: "Identifier", name: e[s] } : { type: "Literal", value: e[s] }; n = n ? { type: "MemberExpression", object: n, property: t, computed: Boolean(s && "Literal" === t.type), optional: !1 } : t } r = n } else r = Ji(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t }; else r = { type: "Literal", value: t }; if ("Literal" === r.type) { const t = r.value; return Ta.call(e.components, t) ? e.components[t] : t } if (e.evaluater) return e.evaluater.evaluateExpression(r); Ra(e) } function Ra(e, t) { const n = new Ea("Cannot handle MDX estrees without `createEvaluater`", { ancestors: e.ancestors, place: t, ruleId: "mdx-estree", source: "hast-util-to-jsx-runtime" }); throw n.file = e.filePath || void 0, n.url = Sa + "#cannot-handle-mdx-estrees-without-createevaluater", n } function va(e) { let t = e.replace(_a, Da); return "ms-" === t.slice(0, 3) && (t = "-" + t), t } function Da(e) { return "-" + e.toLowerCase() } const La = { action: ["form"], cite: ["blockquote", "del", "ins", "q"], data: ["object"], formAction: ["button", "input"], href: ["a", "area", "base", "link"], icon: ["menuitem"], itemId: null, manifest: ["html"], ping: ["a", "area"], poster: ["video"], src: ["audio", "embed", "iframe", "img", "input", "script", "source", "track", "video"] }, Pa = {}; function wa(e, t) { return Ma(e, "boolean" != typeof Pa.includeImageAlt || Pa.includeImageAlt, "boolean" != typeof Pa.includeHtml || Pa.includeHtml) } function Ma(e, t, n) { if (function (e) { return Boolean(e && "object" == typeof e) }(e)) { if ("value" in e) return "html" !== e.type || n ? e.value : ""; if (t && "alt" in e && e.alt) return e.alt; if ("children" in e) return Fa(e.children, t, n) } return Array.isArray(e) ? Fa(e, t, n) : "" } function Fa(e, t, n) { const r = []; let s = -1; for (; ++s < e.length;)r[s] = Ma(e[s], t, n); return r.join("") } const Ba = document.createElement("i"); function Ua(e) { const t = "&" + e + ";"; Ba.innerHTML = t; const n = Ba.textContent; return (59 !== n.charCodeAt(n.length - 1) || "semi" === e) && n !== t && n } function Ha(e, t, n, r) { const s = e.length; let i, o = 0; if (t = t < 0 ? -t > s ? 0 : s + t : t > s ? s : t, n = n > 0 ? n : 0, r.length < 1e4) i = Array.from(r), i.unshift(t, n), e.splice(...i); else for (n && e.splice(t, n); o < r.length;)i = r.slice(o, o + 1e4), i.unshift(t, 0), e.splice(...i), o += 1e4, t += 1e4 } function ja(e, t) { return e.length > 0 ? (Ha(e, e.length, 0, t), e) : t } const Ga = {}.hasOwnProperty; function za(e) { const t = {}; let n = -1; for (; ++n < e.length;)Ya(t, e[n]); return t } function Ya(e, t) { let n; for (n in t) { const r = (Ga.call(e, n) ? e[n] : void 0) || (e[n] = {}), s = t[n]; let i; if (s) for (i in s) { Ga.call(r, i) || (r[i] = []); const e = s[i]; qa(r[i], Array.isArray(e) ? e : e ? [e] : []) } } } function qa(e, t) { let n = -1; const r = []; for (; ++n < t.length;)("after" === t[n].add ? e : r).push(t[n]); Ha(e, 0, 0, r) } function Va(e, t) { const n = Number.parseInt(e, t); return n < 9 || 11 === n || n > 13 && n < 32 || n > 126 && n < 160 || n > 55295 && n < 57344 || n > 64975 && n < 65008 || !(65535 & ~n) || 65534 == (65535 & n) || n > 1114111 ? "" : String.fromCodePoint(n) } function $a(e) { return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase() } const Wa = ol(/[A-Za-z]/), Ka = ol(/[\dA-Za-z]/), Qa = ol(/[#-'*+\--9=?A-Z^-~]/); function Xa(e) { return null !== e && (e < 32 || 127 === e) } const Ja = ol(/\d/), Za = ol(/[\dA-Fa-f]/), el = ol(/[!-/:-@[-`{-~]/); function tl(e) { return null !== e && e < -2 } function nl(e) { return null !== e && (e < 0 || 32 === e) } function rl(e) { return -2 === e || -1 === e || 32 === e } const sl = ol(new RegExp("\\p{P}|\\p{S}", "u")), il = ol(/\s/); function ol(e) { return function (t) { return null !== t && t > -1 && e.test(String.fromCharCode(t)) } } function al(e) { const t = []; let n = -1, r = 0, s = 0; for (; ++n < e.length;) { const i = e.charCodeAt(n); let o = ""; if (37 === i && Ka(e.charCodeAt(n + 1)) && Ka(e.charCodeAt(n + 2))) s = 2; else if (i < 128) /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(i)) || (o = String.fromCharCode(i)); else if (i > 55295 && i < 57344) { const t = e.charCodeAt(n + 1); i < 56320 && t > 56319 && t < 57344 ? (o = String.fromCharCode(i, t), s = 1) : o = "" } else o = String.fromCharCode(i); o && (t.push(e.slice(r, n), encodeURIComponent(o)), r = n + s + 1, o = ""), s && (n += s, s = 0) } return t.join("") + e.slice(r) } function ll(e, t, n, r) { const s = r ? r - 1 : Number.POSITIVE_INFINITY; let i = 0; return function (r) { return rl(r) ? (e.enter(n), o(r)) : t(r) }; function o(r) { return rl(r) && i++ < s ? (e.consume(r), o) : (e.exit(n), t(r)) } } const cl = { tokenize: function (e) { const t = e.attempt(this.parser.constructs.contentInitial, function (n) { if (null !== n) return e.enter("lineEnding"), e.consume(n), e.exit("lineEnding"), ll(e, t, "linePrefix"); e.consume(n) }, function (t) { return e.enter("paragraph"), r(t) }); let n; return t; function r(t) { const r = e.enter("chunkText", { contentType: "text", previous: n }); return n && (n.next = r), n = r, s(t) } function s(t) { return null === t ? (e.exit("chunkText"), e.exit("paragraph"), void e.consume(t)) : tl(t) ? (e.consume(t), e.exit("chunkText"), r) : (e.consume(t), s) } } }, ul = { tokenize: function (e) { const t = this, n = []; let r, s, i, o = 0; return a; function a(r) { if (o < n.length) { const s = n[o]; return t.containerState = s[1], e.attempt(s[0].continuation, l, c)(r) } return c(r) } function l(e) { if (o++, t.containerState._closeFlow) { t.containerState._closeFlow = void 0, r && T(); const n = t.events.length; let s, i = n; for (; i--;)if ("exit" === t.events[i][0] && "chunkFlow" === t.events[i][1].type) { s = t.events[i][1].end; break } E(o); let a = n; for (; a < t.events.length;)t.events[a][1].end = { ...s }, a++; return Ha(t.events, i + 1, 0, t.events.slice(n)), t.events.length = a, c(e) } return a(e) } function c(s) { if (o === n.length) { if (!r) return d(s); if (r.currentConstruct && r.currentConstruct.concrete) return f(s); t.interrupt = Boolean(r.currentConstruct && !r._gfmTableDynamicInterruptHack) } return t.containerState = {}, e.check(hl, u, h)(s) } function u(e) { return r && T(), E(o), d(e) } function h(e) { return t.parser.lazy[t.now().line] = o !== n.length, i = t.now().offset, f(e) } function d(n) { return t.containerState = {}, e.attempt(hl, p, f)(n) } function p(e) { return o++, n.push([t.currentConstruct, t.containerState]), d(e) } function f(n) { return null === n ? (r && T(), E(0), void e.consume(n)) : (r = r || t.parser.flow(t.now()), e.enter("chunkFlow", { _tokenizer: r, contentType: "flow", previous: s }), m(n)) } function m(n) { return null === n ? (g(e.exit("chunkFlow"), !0), E(0), void e.consume(n)) : tl(n) ? (e.consume(n), g(e.exit("chunkFlow")), o = 0, t.interrupt = void 0, a) : (e.consume(n), m) } function g(e, n) { const a = t.sliceStream(e); if (n && a.push(null), e.previous = s, s && (s.next = e), s = e, r.defineSkip(e.start), r.write(a), t.parser.lazy[e.start.line]) { let e = r.events.length; for (; e--;)if (r.events[e][1].start.offset < i && (!r.events[e][1].end || r.events[e][1].end.offset > i)) return; const n = t.events.length; let s, a, l = n; for (; l--;)if ("exit" === t.events[l][0] && "chunkFlow" === t.events[l][1].type) { if (s) { a = t.events[l][1].end; break } s = !0 } for (E(o), e = n; e < t.events.length;)t.events[e][1].end = { ...a }, e++; Ha(t.events, l + 1, 0, t.events.slice(n)), t.events.length = e } } function E(r) { let s = n.length; for (; s-- > r;) { const r = n[s]; t.containerState = r[1], r[0].exit.call(t, e) } n.length = r } function T() { r.write([null]), s = void 0, r = void 0, t.containerState._closeFlow = void 0 } } }, hl = { tokenize: function (e, t, n) { return ll(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4) } }; function dl(e) { return null === e || nl(e) || il(e) ? 1 : sl(e) ? 2 : void 0 } function pl(e, t, n) { const r = []; let s = -1; for (; ++s < e.length;) { const i = e[s].resolveAll; i && !r.includes(i) && (t = i(t, n), r.push(i)) } return t } const fl = { name: "attention", resolveAll: function (e, t) { let n, r, s, i, o, a, l, c, u = -1; for (; ++u < e.length;)if ("enter" === e[u][0] && "attentionSequence" === e[u][1].type && e[u][1]._close) for (n = u; n--;)if ("exit" === e[n][0] && "attentionSequence" === e[n][1].type && e[n][1]._open && t.sliceSerialize(e[n][1]).charCodeAt(0) === t.sliceSerialize(e[u][1]).charCodeAt(0)) { if ((e[n][1]._close || e[u][1]._open) && (e[u][1].end.offset - e[u][1].start.offset) % 3 && !((e[n][1].end.offset - e[n][1].start.offset + e[u][1].end.offset - e[u][1].start.offset) % 3)) continue; a = e[n][1].end.offset - e[n][1].start.offset > 1 && e[u][1].end.offset - e[u][1].start.offset > 1 ? 2 : 1; const h = { ...e[n][1].end }, d = { ...e[u][1].start }; ml(h, -a), ml(d, a), i = { type: a > 1 ? "strongSequence" : "emphasisSequence", start: h, end: { ...e[n][1].end } }, o = { type: a > 1 ? "strongSequence" : "emphasisSequence", start: { ...e[u][1].start }, end: d }, s = { type: a > 1 ? "strongText" : "emphasisText", start: { ...e[n][1].end }, end: { ...e[u][1].start } }, r = { type: a > 1 ? "strong" : "emphasis", start: { ...i.start }, end: { ...o.end } }, e[n][1].end = { ...i.start }, e[u][1].start = { ...o.end }, l = [], e[n][1].end.offset - e[n][1].start.offset && (l = ja(l, [["enter", e[n][1], t], ["exit", e[n][1], t]])), l = ja(l, [["enter", r, t], ["enter", i, t], ["exit", i, t], ["enter", s, t]]), l = ja(l, pl(t.parser.constructs.insideSpan.null, e.slice(n + 1, u), t)), l = ja(l, [["exit", s, t], ["enter", o, t], ["exit", o, t], ["exit", r, t]]), e[u][1].end.offset - e[u][1].start.offset ? (c = 2, l = ja(l, [["enter", e[u][1], t], ["exit", e[u][1], t]])) : c = 0, Ha(e, n - 1, u - n + 3, l), u = n + l.length - c - 2; break } for (u = -1; ++u < e.length;)"attentionSequence" === e[u][1].type && (e[u][1].type = "data"); return e }, tokenize: function (e, t) { const n = this.parser.constructs.attentionMarkers.null, r = this.previous, s = dl(r); let i; return function (t) { return i = t, e.enter("attentionSequence"), o(t) }; function o(a) { if (a === i) return e.consume(a), o; const l = e.exit("attentionSequence"), c = dl(a), u = !c || 2 === c && s || n.includes(a), h = !s || 2 === s && c || n.includes(r); return l._open = Boolean(42 === i ? u : u && (s || !h)), l._close = Boolean(42 === i ? h : h && (c || !u)), t(a) } } }; function ml(e, t) { e.column += t, e.offset += t, e._bufferIndex += t } const gl = { name: "autolink", tokenize: function (e, t, n) { let r = 0; return function (t) { return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(t), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), s }; function s(t) { return Wa(t) ? (e.consume(t), i) : 64 === t ? n(t) : l(t) } function i(e) { return 43 === e || 45 === e || 46 === e || Ka(e) ? (r = 1, o(e)) : l(e) } function o(t) { return 58 === t ? (e.consume(t), r = 0, a) : (43 === t || 45 === t || 46 === t || Ka(t)) && r++ < 32 ? (e.consume(t), o) : (r = 0, l(t)) } function a(r) { return 62 === r ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(r), e.exit("autolinkMarker"), e.exit("autolink"), t) : null === r || 32 === r || 60 === r || Xa(r) ? n(r) : (e.consume(r), a) } function l(t) { return 64 === t ? (e.consume(t), c) : Qa(t) ? (e.consume(t), l) : n(t) } function c(e) { return Ka(e) ? u(e) : n(e) } function u(n) { return 46 === n ? (e.consume(n), r = 0, c) : 62 === n ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(n), e.exit("autolinkMarker"), e.exit("autolink"), t) : h(n) } function h(t) { if ((45 === t || Ka(t)) && r++ < 63) { const n = 45 === t ? h : u; return e.consume(t), n } return n(t) } } }, El = { partial: !0, tokenize: function (e, t, n) { return function (t) { return rl(t) ? ll(e, r, "linePrefix")(t) : r(t) }; function r(e) { return null === e || tl(e) ? t(e) : n(e) } } }, Tl = { continuation: { tokenize: function (e, t, n) { const r = this; return function (t) { return rl(t) ? ll(e, s, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t) : s(t) }; function s(r) { return e.attempt(Tl, t, n)(r) } } }, exit: function (e) { e.exit("blockQuote") }, name: "blockQuote", tokenize: function (e, t, n) { const r = this; return function (t) { if (62 === t) { const n = r.containerState; return n.open || (e.enter("blockQuote", { _container: !0 }), n.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(t), e.exit("blockQuoteMarker"), s } return n(t) }; function s(n) { return rl(n) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(n), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(n)) } } }, Al = { name: "characterEscape", tokenize: function (e, t, n) { return function (t) { return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(t), e.exit("escapeMarker"), r }; function r(r) { return el(r) ? (e.enter("characterEscapeValue"), e.consume(r), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(r) } } }, _l = { name: "characterReference", tokenize: function (e, t, n) { const r = this; let s, i, o = 0; return function (t) { return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(t), e.exit("characterReferenceMarker"), a }; function a(t) { return 35 === t ? (e.enter("characterReferenceMarkerNumeric"), e.consume(t), e.exit("characterReferenceMarkerNumeric"), l) : (e.enter("characterReferenceValue"), s = 31, i = Ka, c(t)) } function l(t) { return 88 === t || 120 === t ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(t), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), s = 6, i = Za, c) : (e.enter("characterReferenceValue"), s = 7, i = Ja, c(t)) } function c(a) { if (59 === a && o) { const s = e.exit("characterReferenceValue"); return i !== Ka || Ua(r.sliceSerialize(s)) ? (e.enter("characterReferenceMarker"), e.consume(a), e.exit("characterReferenceMarker"), e.exit("characterReference"), t) : n(a) } return i(a) && o++ < s ? (e.consume(a), c) : n(a) } } }, yl = { partial: !0, tokenize: function (e, t, n) { const r = this; return function (t) { return null === t ? n(t) : (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), s) }; function s(e) { return r.parser.lazy[r.now().line] ? n(e) : t(e) } } }, bl = { concrete: !0, name: "codeFenced", tokenize: function (e, t, n) { const r = this, s = { partial: !0, tokenize: function (e, t, n) { let s = 0; return function (t) { return e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), o }; function o(t) { return e.enter("codeFencedFence"), rl(t) ? ll(e, l, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t) : l(t) } function l(t) { return t === i ? (e.enter("codeFencedFenceSequence"), c(t)) : n(t) } function c(t) { return t === i ? (s++, e.consume(t), c) : s >= a ? (e.exit("codeFencedFenceSequence"), rl(t) ? ll(e, u, "whitespace")(t) : u(t)) : n(t) } function u(r) { return null === r || tl(r) ? (e.exit("codeFencedFence"), t(r)) : n(r) } } }; let i, o = 0, a = 0; return function (t) { return function (t) { const n = r.events[r.events.length - 1]; return o = n && "linePrefix" === n[1].type ? n[2].sliceSerialize(n[1], !0).length : 0, i = t, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), l(t) }(t) }; function l(t) { return t === i ? (a++, e.consume(t), l) : a < 3 ? n(t) : (e.exit("codeFencedFenceSequence"), rl(t) ? ll(e, c, "whitespace")(t) : c(t)) } function c(n) { return null === n || tl(n) ? (e.exit("codeFencedFence"), r.interrupt ? t(n) : e.check(yl, p, T)(n)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", { contentType: "string" }), u(n)) } function u(t) { return null === t || tl(t) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), c(t)) : rl(t) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), ll(e, h, "whitespace")(t)) : 96 === t && t === i ? n(t) : (e.consume(t), u) } function h(t) { return null === t || tl(t) ? c(t) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", { contentType: "string" }), d(t)) } function d(t) { return null === t || tl(t) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), c(t)) : 96 === t && t === i ? n(t) : (e.consume(t), d) } function p(t) { return e.attempt(s, T, f)(t) } function f(t) { return e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), m } function m(t) { return o > 0 && rl(t) ? ll(e, g, "linePrefix", o + 1)(t) : g(t) } function g(t) { return null === t || tl(t) ? e.check(yl, p, T)(t) : (e.enter("codeFlowValue"), E(t)) } function E(t) { return null === t || tl(t) ? (e.exit("codeFlowValue"), g(t)) : (e.consume(t), E) } function T(n) { return e.exit("codeFenced"), t(n) } } }, Sl = { name: "codeIndented", tokenize: function (e, t, n) { const r = this; return function (t) { return e.enter("codeIndented"), ll(e, s, "linePrefix", 5)(t) }; function s(e) { const t = r.events[r.events.length - 1]; return t && "linePrefix" === t[1].type && t[2].sliceSerialize(t[1], !0).length >= 4 ? i(e) : n(e) } function i(t) { return null === t ? a(t) : tl(t) ? e.attempt(kl, i, a)(t) : (e.enter("codeFlowValue"), o(t)) } function o(t) { return null === t || tl(t) ? (e.exit("codeFlowValue"), i(t)) : (e.consume(t), o) } function a(n) { return e.exit("codeIndented"), t(n) } } }, kl = { partial: !0, tokenize: function (e, t, n) { const r = this; return s; function s(t) { return r.parser.lazy[r.now().line] ? n(t) : tl(t) ? (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), s) : ll(e, i, "linePrefix", 5)(t) } function i(e) { const i = r.events[r.events.length - 1]; return i && "linePrefix" === i[1].type && i[2].sliceSerialize(i[1], !0).length >= 4 ? t(e) : tl(e) ? s(e) : n(e) } } }, Cl = { name: "codeText", previous: function (e) { return 96 !== e || "characterEscape" === this.events[this.events.length - 1][1].type }, resolve: function (e) { let t, n, r = e.length - 4, s = 3; if (!("lineEnding" !== e[s][1].type && "space" !== e[s][1].type || "lineEnding" !== e[r][1].type && "space" !== e[r][1].type)) for (t = s; ++t < r;)if ("codeTextData" === e[t][1].type) { e[s][1].type = "codeTextPadding", e[r][1].type = "codeTextPadding", s += 2, r -= 2; break } for (t = s - 1, r++; ++t <= r;)void 0 === n ? t !== r && "lineEnding" !== e[t][1].type && (n = t) : t !== r && "lineEnding" !== e[t][1].type || (e[n][1].type = "codeTextData", t !== n + 2 && (e[n][1].end = e[t - 1][1].end, e.splice(n + 2, t - n - 2), r -= t - n - 2, t = n + 2), n = void 0); return e }, tokenize: function (e, t, n) { let r, s, i = 0; return function (t) { return e.enter("codeText"), e.enter("codeTextSequence"), o(t) }; function o(t) { return 96 === t ? (e.consume(t), i++, o) : (e.exit("codeTextSequence"), a(t)) } function a(t) { return null === t ? n(t) : 32 === t ? (e.enter("space"), e.consume(t), e.exit("space"), a) : 96 === t ? (s = e.enter("codeTextSequence"), r = 0, c(t)) : tl(t) ? (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), a) : (e.enter("codeTextData"), l(t)) } function l(t) { return null === t || 32 === t || 96 === t || tl(t) ? (e.exit("codeTextData"), a(t)) : (e.consume(t), l) } function c(n) { return 96 === n ? (e.consume(n), r++, c) : r === i ? (e.exit("codeTextSequence"), e.exit("codeText"), t(n)) : (s.type = "codeTextData", l(n)) } } }; class Nl { constructor(e) { this.left = e ? [...e] : [], this.right = [] } get(e) { if (e < 0 || e >= this.left.length + this.right.length) throw new RangeError("Cannot access index `" + e + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`"); return e < this.left.length ? this.left[e] : this.right[this.right.length - e + this.left.length - 1] } get length() { return this.left.length + this.right.length } shift() { return this.setCursor(0), this.right.pop() } slice(e, t) { const n = null == t ? Number.POSITIVE_INFINITY : t; return n < this.left.length ? this.left.slice(e, n) : e > this.left.length ? this.right.slice(this.right.length - n + this.left.length, this.right.length - e + this.left.length).reverse() : this.left.slice(e).concat(this.right.slice(this.right.length - n + this.left.length).reverse()) } splice(e, t, n) { const r = t || 0; this.setCursor(Math.trunc(e)); const s = this.right.splice(this.right.length - r, Number.POSITIVE_INFINITY); return n && Il(this.left, n), s.reverse() } pop() { return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop() } push(e) { this.setCursor(Number.POSITIVE_INFINITY), this.left.push(e) } pushMany(e) { this.setCursor(Number.POSITIVE_INFINITY), Il(this.left, e) } unshift(e) { this.setCursor(0), this.right.push(e) } unshiftMany(e) { this.setCursor(0), Il(this.right, e.reverse()) } setCursor(e) { if (!(e === this.left.length || e > this.left.length && 0 === this.right.length || e < 0 && 0 === this.left.length)) if (e < this.left.length) { const t = this.left.splice(e, Number.POSITIVE_INFINITY); Il(this.right, t.reverse()) } else { const t = this.right.splice(this.left.length + this.right.length - e, Number.POSITIVE_INFINITY); Il(this.left, t.reverse()) } } } function Il(e, t) { let n = 0; if (t.length < 1e4) e.push(...t); else for (; n < t.length;)e.push(...t.slice(n, n + 1e4)), n += 1e4 } function Ol(e) { const t = {}; let n, r, s, i, o, a, l, c = -1; const u = new Nl(e); for (; ++c < u.length;) { for (; c in t;)c = t[c]; if (n = u.get(c), c && "chunkFlow" === n[1].type && "listItemPrefix" === u.get(c - 1)[1].type && (a = n[1]._tokenizer.events, s = 0, s < a.length && "lineEndingBlank" === a[s][1].type && (s += 2), s < a.length && "content" === a[s][1].type)) for (; ++s < a.length && "content" !== a[s][1].type;)"chunkText" === a[s][1].type && (a[s][1]._isInFirstContentOfListItem = !0, s++); if ("enter" === n[0]) n[1].contentType && (Object.assign(t, xl(u, c)), c = t[c], l = !0); else if (n[1]._container) { for (s = c, r = void 0; s--;)if (i = u.get(s), "lineEnding" === i[1].type || "lineEndingBlank" === i[1].type) "enter" === i[0] && (r && (u.get(r)[1].type = "lineEndingBlank"), i[1].type = "lineEnding", r = s); else if ("linePrefix" !== i[1].type && "listItemIndent" !== i[1].type) break; r && (n[1].end = { ...u.get(r)[1].start }, o = u.slice(r, c), o.unshift(n), u.splice(r, c - r + 1, o)) } } return Ha(e, 0, Number.POSITIVE_INFINITY, u.slice(0)), !l } function xl(e, t) { const n = e.get(t)[1], r = e.get(t)[2]; let s = t - 1; const i = []; let o = n._tokenizer; o || (o = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (o._contentTypeTextTrailing = !0)); const a = o.events, l = [], c = {}; let u, h, d = -1, p = n, f = 0, m = 0; const g = [m]; for (; p;) { for (; e.get(++s)[1] !== p;); i.push(s), p._tokenizer || (u = r.sliceStream(p), p.next || u.push(null), h && o.defineSkip(p.start), p._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(u), p._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), h = p, p = p.next } for (p = n; ++d < a.length;)"exit" === a[d][0] && "enter" === a[d - 1][0] && a[d][1].type === a[d - 1][1].type && a[d][1].start.line !== a[d][1].end.line && (m = d + 1, g.push(m), p._tokenizer = void 0, p.previous = void 0, p = p.next); for (o.events = [], p ? (p._tokenizer = void 0, p.previous = void 0) : g.pop(), d = g.length; d--;) { const t = a.slice(g[d], g[d + 1]), n = i.pop(); l.push([n, n + t.length - 1]), e.splice(n, 2, t) } for (l.reverse(), d = -1; ++d < l.length;)c[f + l[d][0]] = f + l[d][1], f += l[d][1] - l[d][0] - 1; return c } const Rl = { resolve: function (e) { return Ol(e), e }, tokenize: function (e, t) { let n; return function (t) { return e.enter("content"), n = e.enter("chunkContent", { contentType: "content" }), r(t) }; function r(t) { return null === t ? s(t) : tl(t) ? e.check(vl, i, s)(t) : (e.consume(t), r) } function s(n) { return e.exit("chunkContent"), e.exit("content"), t(n) } function i(t) { return e.consume(t), e.exit("chunkContent"), n.next = e.enter("chunkContent", { contentType: "content", previous: n }), n = n.next, r } } }, vl = { partial: !0, tokenize: function (e, t, n) { const r = this; return function (t) { return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), ll(e, s, "linePrefix") }; function s(s) { if (null === s || tl(s)) return n(s); const i = r.events[r.events.length - 1]; return !r.parser.constructs.disable.null.includes("codeIndented") && i && "linePrefix" === i[1].type && i[2].sliceSerialize(i[1], !0).length >= 4 ? t(s) : e.interrupt(r.parser.constructs.flow, n, t)(s) } } }; function Dl(e, t, n, r, s, i, o, a, l) { const c = l || Number.POSITIVE_INFINITY; let u = 0; return function (t) { return 60 === t ? (e.enter(r), e.enter(s), e.enter(i), e.consume(t), e.exit(i), h) : null === t || 32 === t || 41 === t || Xa(t) ? n(t) : (e.enter(r), e.enter(o), e.enter(a), e.enter("chunkString", { contentType: "string" }), f(t)) }; function h(n) { return 62 === n ? (e.enter(i), e.consume(n), e.exit(i), e.exit(s), e.exit(r), t) : (e.enter(a), e.enter("chunkString", { contentType: "string" }), d(n)) } function d(t) { return 62 === t ? (e.exit("chunkString"), e.exit(a), h(t)) : null === t || 60 === t || tl(t) ? n(t) : (e.consume(t), 92 === t ? p : d) } function p(t) { return 60 === t || 62 === t || 92 === t ? (e.consume(t), d) : d(t) } function f(s) { return u || null !== s && 41 !== s && !nl(s) ? u < c && 40 === s ? (e.consume(s), u++, f) : 41 === s ? (e.consume(s), u--, f) : null === s || 32 === s || 40 === s || Xa(s) ? n(s) : (e.consume(s), 92 === s ? m : f) : (e.exit("chunkString"), e.exit(a), e.exit(o), e.exit(r), t(s)) } function m(t) { return 40 === t || 41 === t || 92 === t ? (e.consume(t), f) : f(t) } } function Ll(e, t, n, r, s, i) { const o = this; let a, l = 0; return function (t) { return e.enter(r), e.enter(s), e.consume(t), e.exit(s), e.enter(i), c }; function c(h) { return l > 999 || null === h || 91 === h || 93 === h && !a || 94 === h && !l && "_hiddenFootnoteSupport" in o.parser.constructs ? n(h) : 93 === h ? (e.exit(i), e.enter(s), e.consume(h), e.exit(s), e.exit(r), t) : tl(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), c) : (e.enter("chunkString", { contentType: "string" }), u(h)) } function u(t) { return null === t || 91 === t || 93 === t || tl(t) || l++ > 999 ? (e.exit("chunkString"), c(t)) : (e.consume(t), a || (a = !rl(t)), 92 === t ? h : u) } function h(t) { return 91 === t || 92 === t || 93 === t ? (e.consume(t), l++, u) : u(t) } } function Pl(e, t, n, r, s, i) { let o; return function (t) { return 34 === t || 39 === t || 40 === t ? (e.enter(r), e.enter(s), e.consume(t), e.exit(s), o = 40 === t ? 41 : t, a) : n(t) }; function a(n) { return n === o ? (e.enter(s), e.consume(n), e.exit(s), e.exit(r), t) : (e.enter(i), l(n)) } function l(t) { return t === o ? (e.exit(i), a(o)) : null === t ? n(t) : tl(t) ? (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), ll(e, l, "linePrefix")) : (e.enter("chunkString", { contentType: "string" }), c(t)) } function c(t) { return t === o || null === t || tl(t) ? (e.exit("chunkString"), l(t)) : (e.consume(t), 92 === t ? u : c) } function u(t) { return t === o || 92 === t ? (e.consume(t), c) : c(t) } } function wl(e, t) { let n; return function r(s) { return tl(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), n = !0, r) : rl(s) ? ll(e, r, n ? "linePrefix" : "lineSuffix")(s) : t(s) } } const Ml = { name: "definition", tokenize: function (e, t, n) { const r = this; let s; return function (t) { return e.enter("definition"), function (t) { return Ll.call(r, e, i, n, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(t) }(t) }; function i(t) { return s = $a(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), 58 === t ? (e.enter("definitionMarker"), e.consume(t), e.exit("definitionMarker"), o) : n(t) } function o(t) { return nl(t) ? wl(e, a)(t) : a(t) } function a(t) { return Dl(e, l, n, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString")(t) } function l(t) { return e.attempt(Fl, c, c)(t) } function c(t) { return rl(t) ? ll(e, u, "whitespace")(t) : u(t) } function u(i) { return null === i || tl(i) ? (e.exit("definition"), r.parser.defined.push(s), t(i)) : n(i) } } }, Fl = { partial: !0, tokenize: function (e, t, n) { return function (t) { return nl(t) ? wl(e, r)(t) : n(t) }; function r(t) { return Pl(e, s, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(t) } function s(t) { return rl(t) ? ll(e, i, "whitespace")(t) : i(t) } function i(e) { return null === e || tl(e) ? t(e) : n(e) } } }, Bl = { name: "hardBreakEscape", tokenize: function (e, t, n) { return function (t) { return e.enter("hardBreakEscape"), e.consume(t), r }; function r(r) { return tl(r) ? (e.exit("hardBreakEscape"), t(r)) : n(r) } } }, Ul = { name: "headingAtx", resolve: function (e, t) { let n, r, s = e.length - 2, i = 3; return "whitespace" === e[i][1].type && (i += 2), s - 2 > i && "whitespace" === e[s][1].type && (s -= 2), "atxHeadingSequence" === e[s][1].type && (i === s - 1 || s - 4 > i && "whitespace" === e[s - 2][1].type) && (s -= i + 1 === s ? 2 : 4), s > i && (n = { type: "atxHeadingText", start: e[i][1].start, end: e[s][1].end }, r = { type: "chunkText", start: e[i][1].start, end: e[s][1].end, contentType: "text" }, Ha(e, i, s - i + 1, [["enter", n, t], ["enter", r, t], ["exit", r, t], ["exit", n, t]])), e }, tokenize: function (e, t, n) { let r = 0; return function (t) { return e.enter("atxHeading"), function (t) { return e.enter("atxHeadingSequence"), s(t) }(t) }; function s(t) { return 35 === t && r++ < 6 ? (e.consume(t), s) : null === t || nl(t) ? (e.exit("atxHeadingSequence"), i(t)) : n(t) } function i(n) { return 35 === n ? (e.enter("atxHeadingSequence"), o(n)) : null === n || tl(n) ? (e.exit("atxHeading"), t(n)) : rl(n) ? ll(e, i, "whitespace")(n) : (e.enter("atxHeadingText"), a(n)) } function o(t) { return 35 === t ? (e.consume(t), o) : (e.exit("atxHeadingSequence"), i(t)) } function a(t) { return null === t || 35 === t || nl(t) ? (e.exit("atxHeadingText"), i(t)) : (e.consume(t), a) } } }, Hl = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"], jl = ["pre", "script", "style", "textarea"], Gl = { concrete: !0, name: "htmlFlow", resolveTo: function (e) { let t = e.length; for (; t-- && ("enter" !== e[t][0] || "htmlFlow" !== e[t][1].type);); return t > 1 && "linePrefix" === e[t - 2][1].type && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e }, tokenize: function (e, t, n) { const r = this; let s, i, o, a, l; return function (t) { return function (t) { return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(t), c }(t) }; function c(a) { return 33 === a ? (e.consume(a), u) : 47 === a ? (e.consume(a), i = !0, p) : 63 === a ? (e.consume(a), s = 3, r.interrupt ? t : P) : Wa(a) ? (e.consume(a), o = String.fromCharCode(a), f) : n(a) } function u(i) { return 45 === i ? (e.consume(i), s = 2, h) : 91 === i ? (e.consume(i), s = 5, a = 0, d) : Wa(i) ? (e.consume(i), s = 4, r.interrupt ? t : P) : n(i) } function h(s) { return 45 === s ? (e.consume(s), r.interrupt ? t : P) : n(s) } function d(s) { return s === "CDATA[".charCodeAt(a++) ? (e.consume(s), 6 === a ? r.interrupt ? t : N : d) : n(s) } function p(t) { return Wa(t) ? (e.consume(t), o = String.fromCharCode(t), f) : n(t) } function f(a) { if (null === a || 47 === a || 62 === a || nl(a)) { const l = 47 === a, c = o.toLowerCase(); return l || i || !jl.includes(c) ? Hl.includes(o.toLowerCase()) ? (s = 6, l ? (e.consume(a), m) : r.interrupt ? t(a) : N(a)) : (s = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(a) : i ? g(a) : E(a)) : (s = 1, r.interrupt ? t(a) : N(a)) } return 45 === a || Ka(a) ? (e.consume(a), o += String.fromCharCode(a), f) : n(a) } function m(s) { return 62 === s ? (e.consume(s), r.interrupt ? t : N) : n(s) } function g(t) { return rl(t) ? (e.consume(t), g) : k(t) } function E(t) { return 47 === t ? (e.consume(t), k) : 58 === t || 95 === t || Wa(t) ? (e.consume(t), T) : rl(t) ? (e.consume(t), E) : k(t) } function T(t) { return 45 === t || 46 === t || 58 === t || 95 === t || Ka(t) ? (e.consume(t), T) : A(t) } function A(t) { return 61 === t ? (e.consume(t), _) : rl(t) ? (e.consume(t), A) : E(t) } function _(t) { return null === t || 60 === t || 61 === t || 62 === t || 96 === t ? n(t) : 34 === t || 39 === t ? (e.consume(t), l = t, y) : rl(t) ? (e.consume(t), _) : b(t) } function y(t) { return t === l ? (e.consume(t), l = null, S) : null === t || tl(t) ? n(t) : (e.consume(t), y) } function b(t) { return null === t || 34 === t || 39 === t || 47 === t || 60 === t || 61 === t || 62 === t || 96 === t || nl(t) ? A(t) : (e.consume(t), b) } function S(e) { return 47 === e || 62 === e || rl(e) ? E(e) : n(e) } function k(t) { return 62 === t ? (e.consume(t), C) : n(t) } function C(t) { return null === t || tl(t) ? N(t) : rl(t) ? (e.consume(t), C) : n(t) } function N(t) { return 45 === t && 2 === s ? (e.consume(t), R) : 60 === t && 1 === s ? (e.consume(t), v) : 62 === t && 4 === s ? (e.consume(t), w) : 63 === t && 3 === s ? (e.consume(t), P) : 93 === t && 5 === s ? (e.consume(t), L) : !tl(t) || 6 !== s && 7 !== s ? null === t || tl(t) ? (e.exit("htmlFlowData"), I(t)) : (e.consume(t), N) : (e.exit("htmlFlowData"), e.check(zl, M, I)(t)) } function I(t) { return e.check(Yl, O, M)(t) } function O(t) { return e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), x } function x(t) { return null === t || tl(t) ? I(t) : (e.enter("htmlFlowData"), N(t)) } function R(t) { return 45 === t ? (e.consume(t), P) : N(t) } function v(t) { return 47 === t ? (e.consume(t), o = "", D) : N(t) } function D(t) { if (62 === t) { const n = o.toLowerCase(); return jl.includes(n) ? (e.consume(t), w) : N(t) } return Wa(t) && o.length < 8 ? (e.consume(t), o += String.fromCharCode(t), D) : N(t) } function L(t) { return 93 === t ? (e.consume(t), P) : N(t) } function P(t) { return 62 === t ? (e.consume(t), w) : 45 === t && 2 === s ? (e.consume(t), P) : N(t) } function w(t) { return null === t || tl(t) ? (e.exit("htmlFlowData"), M(t)) : (e.consume(t), w) } function M(n) { return e.exit("htmlFlow"), t(n) } } }, zl = { partial: !0, tokenize: function (e, t, n) { return function (r) { return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), e.attempt(El, t, n) } } }, Yl = { partial: !0, tokenize: function (e, t, n) { const r = this; return function (t) { return tl(t) ? (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), s) : n(t) }; function s(e) { return r.parser.lazy[r.now().line] ? n(e) : t(e) } } }, ql = { name: "htmlText", tokenize: function (e, t, n) { const r = this; let s, i, o; return function (t) { return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(t), a }; function a(t) { return 33 === t ? (e.consume(t), l) : 47 === t ? (e.consume(t), _) : 63 === t ? (e.consume(t), T) : Wa(t) ? (e.consume(t), S) : n(t) } function l(t) { return 45 === t ? (e.consume(t), c) : 91 === t ? (e.consume(t), i = 0, p) : Wa(t) ? (e.consume(t), E) : n(t) } function c(t) { return 45 === t ? (e.consume(t), d) : n(t) } function u(t) { return null === t ? n(t) : 45 === t ? (e.consume(t), h) : tl(t) ? (o = u, D(t)) : (e.consume(t), u) } function h(t) { return 45 === t ? (e.consume(t), d) : u(t) } function d(e) { return 62 === e ? v(e) : 45 === e ? h(e) : u(e) } function p(t) { return t === "CDATA[".charCodeAt(i++) ? (e.consume(t), 6 === i ? f : p) : n(t) } function f(t) { return null === t ? n(t) : 93 === t ? (e.consume(t), m) : tl(t) ? (o = f, D(t)) : (e.consume(t), f) } function m(t) { return 93 === t ? (e.consume(t), g) : f(t) } function g(t) { return 62 === t ? v(t) : 93 === t ? (e.consume(t), g) : f(t) } function E(t) { return null === t || 62 === t ? v(t) : tl(t) ? (o = E, D(t)) : (e.consume(t), E) } function T(t) { return null === t ? n(t) : 63 === t ? (e.consume(t), A) : tl(t) ? (o = T, D(t)) : (e.consume(t), T) } function A(e) { return 62 === e ? v(e) : T(e) } function _(t) { return Wa(t) ? (e.consume(t), y) : n(t) } function y(t) { return 45 === t || Ka(t) ? (e.consume(t), y) : b(t) } function b(t) { return tl(t) ? (o = b, D(t)) : rl(t) ? (e.consume(t), b) : v(t) } function S(t) { return 45 === t || Ka(t) ? (e.consume(t), S) : 47 === t || 62 === t || nl(t) ? k(t) : n(t) } function k(t) { return 47 === t ? (e.consume(t), v) : 58 === t || 95 === t || Wa(t) ? (e.consume(t), C) : tl(t) ? (o = k, D(t)) : rl(t) ? (e.consume(t), k) : v(t) } function C(t) { return 45 === t || 46 === t || 58 === t || 95 === t || Ka(t) ? (e.consume(t), C) : N(t) } function N(t) { return 61 === t ? (e.consume(t), I) : tl(t) ? (o = N, D(t)) : rl(t) ? (e.consume(t), N) : k(t) } function I(t) { return null === t || 60 === t || 61 === t || 62 === t || 96 === t ? n(t) : 34 === t || 39 === t ? (e.consume(t), s = t, O) : tl(t) ? (o = I, D(t)) : rl(t) ? (e.consume(t), I) : (e.consume(t), x) } function O(t) { return t === s ? (e.consume(t), s = void 0, R) : null === t ? n(t) : tl(t) ? (o = O, D(t)) : (e.consume(t), O) } function x(t) { return null === t || 34 === t || 39 === t || 60 === t || 61 === t || 96 === t ? n(t) : 47 === t || 62 === t || nl(t) ? k(t) : (e.consume(t), x) } function R(e) { return 47 === e || 62 === e || nl(e) ? k(e) : n(e) } function v(r) { return 62 === r ? (e.consume(r), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(r) } function D(t) { return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), L } function L(t) { return rl(t) ? ll(e, P, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t) : P(t) } function P(t) { return e.enter("htmlTextData"), o(t) } } }, Vl = { name: "labelEnd", resolveAll: function (e) { let t = -1; const n = []; for (; ++t < e.length;) { const r = e[t][1]; if (n.push(e[t]), "labelImage" === r.type || "labelLink" === r.type || "labelEnd" === r.type) { const e = "labelImage" === r.type ? 4 : 2; r.type = "data", t += e } } return e.length !== n.length && Ha(e, 0, e.length, n), e }, resolveTo: function (e, t) { let n, r, s, i, o = e.length, a = 0; for (; o--;)if (n = e[o][1], r) { if ("link" === n.type || "labelLink" === n.type && n._inactive) break; "enter" === e[o][0] && "labelLink" === n.type && (n._inactive = !0) } else if (s) { if ("enter" === e[o][0] && ("labelImage" === n.type || "labelLink" === n.type) && !n._balanced && (r = o, "labelLink" !== n.type)) { a = 2; break } } else "labelEnd" === n.type && (s = o); const l = { type: "labelLink" === e[r][1].type ? "link" : "image", start: { ...e[r][1].start }, end: { ...e[e.length - 1][1].end } }, c = { type: "label", start: { ...e[r][1].start }, end: { ...e[s][1].end } }, u = { type: "labelText", start: { ...e[r + a + 2][1].end }, end: { ...e[s - 2][1].start } }; return i = [["enter", l, t], ["enter", c, t]], i = ja(i, e.slice(r + 1, r + a + 3)), i = ja(i, [["enter", u, t]]), i = ja(i, pl(t.parser.constructs.insideSpan.null, e.slice(r + a + 4, s - 3), t)), i = ja(i, [["exit", u, t], e[s - 2], e[s - 1], ["exit", c, t]]), i = ja(i, e.slice(s + 1)), i = ja(i, [["exit", l, t]]), Ha(e, r, e.length, i), e }, tokenize: function (e, t, n) { const r = this; let s, i, o = r.events.length; for (; o--;)if (("labelImage" === r.events[o][1].type || "labelLink" === r.events[o][1].type) && !r.events[o][1]._balanced) { s = r.events[o][1]; break } return function (t) { return s ? s._inactive ? u(t) : (i = r.parser.defined.includes($a(r.sliceSerialize({ start: s.end, end: r.now() }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(t), e.exit("labelMarker"), e.exit("labelEnd"), a) : n(t) }; function a(t) { return 40 === t ? e.attempt($l, c, i ? c : u)(t) : 91 === t ? e.attempt(Wl, c, i ? l : u)(t) : i ? c(t) : u(t) } function l(t) { return e.attempt(Kl, c, u)(t) } function c(e) { return t(e) } function u(e) { return s._balanced = !0, n(e) } } }, $l = { tokenize: function (e, t, n) { return function (t) { return e.enter("resource"), e.enter("resourceMarker"), e.consume(t), e.exit("resourceMarker"), r }; function r(t) { return nl(t) ? wl(e, s)(t) : s(t) } function s(t) { return 41 === t ? c(t) : Dl(e, i, o, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(t) } function i(t) { return nl(t) ? wl(e, a)(t) : c(t) } function o(e) { return n(e) } function a(t) { return 34 === t || 39 === t || 40 === t ? Pl(e, l, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(t) : c(t) } function l(t) { return nl(t) ? wl(e, c)(t) : c(t) } function c(r) { return 41 === r ? (e.enter("resourceMarker"), e.consume(r), e.exit("resourceMarker"), e.exit("resource"), t) : n(r) } } }, Wl = { tokenize: function (e, t, n) { const r = this; return function (t) { return Ll.call(r, e, s, i, "reference", "referenceMarker", "referenceString")(t) }; function s(e) { return r.parser.defined.includes($a(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(e) : n(e) } function i(e) { return n(e) } } }, Kl = { tokenize: function (e, t, n) { return function (t) { return e.enter("reference"), e.enter("referenceMarker"), e.consume(t), e.exit("referenceMarker"), r }; function r(r) { return 93 === r ? (e.enter("referenceMarker"), e.consume(r), e.exit("referenceMarker"), e.exit("reference"), t) : n(r) } } }, Ql = { name: "labelStartImage", resolveAll: Vl.resolveAll, tokenize: function (e, t, n) { const r = this; return function (t) { return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(t), e.exit("labelImageMarker"), s }; function s(t) { return 91 === t ? (e.enter("labelMarker"), e.consume(t), e.exit("labelMarker"), e.exit("labelImage"), i) : n(t) } function i(e) { return 94 === e && "_hiddenFootnoteSupport" in r.parser.constructs ? n(e) : t(e) } } }, Xl = { name: "labelStartLink", resolveAll: Vl.resolveAll, tokenize: function (e, t, n) { const r = this; return function (t) { return e.enter("labelLink"), e.enter("labelMarker"), e.consume(t), e.exit("labelMarker"), e.exit("labelLink"), s }; function s(e) { return 94 === e && "_hiddenFootnoteSupport" in r.parser.constructs ? n(e) : t(e) } } }, Jl = { name: "lineEnding", tokenize: function (e, t) { return function (n) { return e.enter("lineEnding"), e.consume(n), e.exit("lineEnding"), ll(e, t, "linePrefix") } } }, Zl = { name: "thematicBreak", tokenize: function (e, t, n) { let r, s = 0; return function (t) { return e.enter("thematicBreak"), function (e) { return r = e, i(e) }(t) }; function i(i) { return i === r ? (e.enter("thematicBreakSequence"), o(i)) : s >= 3 && (null === i || tl(i)) ? (e.exit("thematicBreak"), t(i)) : n(i) } function o(t) { return t === r ? (e.consume(t), s++, o) : (e.exit("thematicBreakSequence"), rl(t) ? ll(e, i, "whitespace")(t) : i(t)) } } }, ec = { continuation: { tokenize: function (e, t, n) { const r = this; return r.containerState._closeFlow = void 0, e.check(El, function (n) { return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, ll(e, t, "listItemIndent", r.containerState.size + 1)(n) }, function (n) { return r.containerState.furtherBlankLines || !rl(n) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, s(n)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(nc, t, s)(n)) }); function s(s) { return r.containerState._closeFlow = !0, r.interrupt = void 0, ll(e, e.attempt(ec, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s) } } }, exit: function (e) { e.exit(this.containerState.type) }, name: "list", tokenize: function (e, t, n) { const r = this, s = r.events[r.events.length - 1]; let i = s && "linePrefix" === s[1].type ? s[2].sliceSerialize(s[1], !0).length : 0, o = 0; return function (t) { const s = r.containerState.type || (42 === t || 43 === t || 45 === t ? "listUnordered" : "listOrdered"); if ("listUnordered" === s ? !r.containerState.marker || t === r.containerState.marker : Ja(t)) { if (r.containerState.type || (r.containerState.type = s, e.enter(s, { _container: !0 })), "listUnordered" === s) return e.enter("listItemPrefix"), 42 === t || 45 === t ? e.check(Zl, n, l)(t) : l(t); if (!r.interrupt || 49 === t) return e.enter("listItemPrefix"), e.enter("listItemValue"), a(t) } return n(t) }; function a(t) { return Ja(t) && ++o < 10 ? (e.consume(t), a) : (!r.interrupt || o < 2) && (r.containerState.marker ? t === r.containerState.marker : 41 === t || 46 === t) ? (e.exit("listItemValue"), l(t)) : n(t) } function l(t) { return e.enter("listItemMarker"), e.consume(t), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || t, e.check(El, r.interrupt ? n : c, e.attempt(tc, h, u)) } function c(e) { return r.containerState.initialBlankLine = !0, i++, h(e) } function u(t) { return rl(t) ? (e.enter("listItemPrefixWhitespace"), e.consume(t), e.exit("listItemPrefixWhitespace"), h) : n(t) } function h(n) { return r.containerState.size = i + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(n) } } }, tc = { partial: !0, tokenize: function (e, t, n) { const r = this; return ll(e, function (e) { const s = r.events[r.events.length - 1]; return !rl(e) && s && "listItemPrefixWhitespace" === s[1].type ? t(e) : n(e) }, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5) } }, nc = { partial: !0, tokenize: function (e, t, n) { const r = this; return ll(e, function (e) { const s = r.events[r.events.length - 1]; return s && "listItemIndent" === s[1].type && s[2].sliceSerialize(s[1], !0).length === r.containerState.size ? t(e) : n(e) }, "listItemIndent", r.containerState.size + 1) } }, rc = { name: "setextUnderline", resolveTo: function (e, t) { let n, r, s, i = e.length; for (; i--;)if ("enter" === e[i][0]) { if ("content" === e[i][1].type) { n = i; break } "paragraph" === e[i][1].type && (r = i) } else "content" === e[i][1].type && e.splice(i, 1), s || "definition" !== e[i][1].type || (s = i); const o = { type: "setextHeading", start: { ...e[n][1].start }, end: { ...e[e.length - 1][1].end } }; return e[r][1].type = "setextHeadingText", s ? (e.splice(r, 0, ["enter", o, t]), e.splice(s + 1, 0, ["exit", e[n][1], t]), e[n][1].end = { ...e[s][1].end }) : e[n][1] = o, e.push(["exit", o, t]), e }, tokenize: function (e, t, n) { const r = this; let s; return function (t) { let o, a = r.events.length; for (; a--;)if ("lineEnding" !== r.events[a][1].type && "linePrefix" !== r.events[a][1].type && "content" !== r.events[a][1].type) { o = "paragraph" === r.events[a][1].type; break } return r.parser.lazy[r.now().line] || !r.interrupt && !o ? n(t) : (e.enter("setextHeadingLine"), s = t, function (t) { return e.enter("setextHeadingLineSequence"), i(t) }(t)) }; function i(t) { return t === s ? (e.consume(t), i) : (e.exit("setextHeadingLineSequence"), rl(t) ? ll(e, o, "lineSuffix")(t) : o(t)) } function o(r) { return null === r || tl(r) ? (e.exit("setextHeadingLine"), t(r)) : n(r) } } }, sc = { tokenize: function (e) { const t = this, n = e.attempt(El, function (r) { if (null !== r) return e.enter("lineEndingBlank"), e.consume(r), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n; e.consume(r) }, e.attempt(this.parser.constructs.flowInitial, r, ll(e, e.attempt(this.parser.constructs.flow, r, e.attempt(Rl, r)), "linePrefix"))); return n; function r(r) { if (null !== r) return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), t.currentConstruct = void 0, n; e.consume(r) } } }, ic = { resolveAll: cc() }, oc = lc("string"), ac = lc("text"); function lc(e) { return { resolveAll: cc("text" === e ? uc : void 0), tokenize: function (t) { const n = this, r = this.parser.constructs[e], s = t.attempt(r, i, o); return i; function i(e) { return l(e) ? s(e) : o(e) } function o(e) { if (null !== e) return t.enter("data"), t.consume(e), a; t.consume(e) } function a(e) { return l(e) ? (t.exit("data"), s(e)) : (t.consume(e), a) } function l(e) { if (null === e) return !0; const t = r[e]; let s = -1; if (t) for (; ++s < t.length;) { const e = t[s]; if (!e.previous || e.previous.call(n, n.previous)) return !0 } return !1 } } } } function cc(e) { return function (t, n) { let r, s = -1; for (; ++s <= t.length;)void 0 === r ? t[s] && "data" === t[s][1].type && (r = s, s++) : t[s] && "data" === t[s][1].type || (s !== r + 2 && (t[r][1].end = t[s - 1][1].end, t.splice(r + 2, s - r - 2), s = r + 2), r = void 0); return e ? e(t, n) : t } } function uc(e, t) { let n = 0; for (; ++n <= e.length;)if ((n === e.length || "lineEnding" === e[n][1].type) && "data" === e[n - 1][1].type) { const r = e[n - 1][1], s = t.sliceStream(r); let i, o = s.length, a = -1, l = 0; for (; o--;) { const e = s[o]; if ("string" == typeof e) { for (a = e.length; 32 === e.charCodeAt(a - 1);)l++, a--; if (a) break; a = -1 } else if (-2 === e) i = !0, l++; else if (-1 !== e) { o++; break } } if (t._contentTypeTextTrailing && n === e.length && (l = 0), l) { const s = { type: n === e.length || i || l < 2 ? "lineSuffix" : "hardBreakTrailing", start: { _bufferIndex: o ? a : r.start._bufferIndex + a, _index: r.start._index + o, line: r.end.line, column: r.end.column - l, offset: r.end.offset - l }, end: { ...r.end } }; r.end = { ...s.start }, r.start.offset === r.end.offset ? Object.assign(r, s) : (e.splice(n, 0, ["enter", s, t], ["exit", s, t]), n += 2) } n++ } return e } const hc = { 42: ec, 43: ec, 45: ec, 48: ec, 49: ec, 50: ec, 51: ec, 52: ec, 53: ec, 54: ec, 55: ec, 56: ec, 57: ec, 62: Tl }, dc = { 91: Ml }, pc = { [-2]: Sl, [-1]: Sl, 32: Sl }, fc = { 35: Ul, 42: Zl, 45: [rc, Zl], 60: Gl, 61: rc, 95: Zl, 96: bl, 126: bl }, mc = { 38: _l, 92: Al }, gc = { [-5]: Jl, [-4]: Jl, [-3]: Jl, 33: Ql, 38: _l, 42: fl, 60: [gl, ql], 91: Xl, 92: [Bl, Al], 93: Vl, 95: fl, 96: Cl }, Ec = { null: [fl, ic] }, Tc = Object.freeze(Object.defineProperty({ __proto__: null, attentionMarkers: { null: [42, 95] }, contentInitial: dc, disable: { null: [] }, document: hc, flow: fc, flowInitial: pc, insideSpan: Ec, string: mc, text: gc }, Symbol.toStringTag, { value: "Module" })); function Ac(e, t, n) { let r = { _bufferIndex: -1, _index: 0, line: n && n.line || 1, column: n && n.column || 1, offset: n && n.offset || 0 }; const s = {}, i = []; let o = [], a = []; const l = { attempt: m(function (e, t) { g(e, t.from) }), check: m(f), consume: function (e) { tl(e) ? (r.line++, r.column = 1, r.offset += -3 === e ? 2 : 1, E()) : -1 !== e && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === o[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = e }, enter: function (e, t) { const n = t || {}; return n.type = e, n.start = d(), c.events.push(["enter", n, c]), a.push(n), n }, exit: function (e) { const t = a.pop(); return t.end = d(), c.events.push(["exit", t, c]), t }, interrupt: m(f, { interrupt: !0 }) }, c = { code: null, containerState: {}, defineSkip: function (e) { s[e.line] = e.column, E() }, events: [], now: d, parser: e, previous: null, sliceSerialize: function (e, t) { return function (e, t) { let n = -1; const r = []; let s; for (; ++n < e.length;) { const i = e[n]; let o; if ("string" == typeof i) o = i; else switch (i) { case -5: o = "\r"; break; case -4: o = "\n"; break; case -3: o = "\r\n"; break; case -2: o = t ? " " : "\t"; break; case -1: if (!t && s) continue; o = " "; break; default: o = String.fromCharCode(i) }s = -2 === i, r.push(o) } return r.join("") }(h(e), t) }, sliceStream: h, write: function (e) { return o = ja(o, e), function () { let e; for (; r._index < o.length;) { const t = o[r._index]; if ("string" == typeof t) for (e = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === e && r._bufferIndex < t.length;)p(t.charCodeAt(r._bufferIndex)); else p(t) } }(), null !== o[o.length - 1] ? [] : (g(t, 0), c.events = pl(i, c.events, c), c.events) } }; let u = t.tokenize.call(c, l); return t.resolveAll && i.push(t), c; function h(e) { return function (e, t) { const n = t.start._index, r = t.start._bufferIndex, s = t.end._index, i = t.end._bufferIndex; let o; if (n === s) o = [e[n].slice(r, i)]; else { if (o = e.slice(n, s), r > -1) { const e = o[0]; "string" == typeof e ? o[0] = e.slice(r) : o.shift() } i > 0 && o.push(e[s].slice(0, i)) } return o }(o, e) } function d() { const { _bufferIndex: e, _index: t, line: n, column: s, offset: i } = r; return { _bufferIndex: e, _index: t, line: n, column: s, offset: i } } function p(e) { u = u(e) } function f(e, t) { t.restore() } function m(e, t) { return function (n, s, i) { let o, u, h, p; return Array.isArray(n) ? m(n) : "tokenize" in n ? m([n]) : (f = n, function (e) { const t = null !== e && f[e], n = null !== e && f.null; return m([...Array.isArray(t) ? t : t ? [t] : [], ...Array.isArray(n) ? n : n ? [n] : []])(e) }); var f; function m(e) { return o = e, u = 0, 0 === e.length ? i : g(e[u]) } function g(e) { return function (n) { return p = function () { const e = d(), t = c.previous, n = c.currentConstruct, s = c.events.length, i = Array.from(a); return { from: s, restore: function () { r = e, c.previous = t, c.currentConstruct = n, c.events.length = s, a = i, E() } } }(), h = e, e.partial || (c.currentConstruct = e), e.name && c.parser.constructs.disable.null.includes(e.name) ? A() : e.tokenize.call(t ? Object.assign(Object.create(c), t) : c, l, T, A)(n) } } function T(t) { return e(h, p), s } function A(e) { return p.restore(), ++u < o.length ? g(o[u]) : i } } } function g(e, t) { e.resolveAll && !i.includes(e) && i.push(e), e.resolve && Ha(c.events, t, c.events.length - t, e.resolve(c.events.slice(t), c)), e.resolveTo && (c.events = e.resolveTo(c.events, c)) } function E() { r.line in s && r.column < 2 && (r.column = s[r.line], r.offset += s[r.line] - 1) } } const _c = /[\0\t\n\r]/g, yc = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi; function bc(e, t, n) { if (t) return t; if (35 === n.charCodeAt(0)) { const e = n.charCodeAt(1), t = 120 === e || 88 === e; return Va(n.slice(t ? 2 : 1), t ? 16 : 10) } return Ua(n) || e } const Sc = {}.hasOwnProperty; function kc(e, t, n) { return "string" != typeof t && (n = t, t = void 0), function (e) { const t = { transforms: [], canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"], enter: { autolink: s(T), autolinkProtocol: u, autolinkEmail: u, atxHeading: s(m), blockQuote: s(function () { return { type: "blockquote", children: [] } }), characterEscape: u, characterReference: u, codeFenced: s(f), codeFencedFenceInfo: i, codeFencedFenceMeta: i, codeIndented: s(f, i), codeText: s(function () { return { type: "inlineCode", value: "" } }, i), codeTextData: u, data: u, codeFlowValue: u, definition: s(function () { return { type: "definition", identifier: "", label: null, title: null, url: "" } }), definitionDestinationString: i, definitionLabelString: i, definitionTitleString: i, emphasis: s(function () { return { type: "emphasis", children: [] } }), hardBreakEscape: s(g), hardBreakTrailing: s(g), htmlFlow: s(E, i), htmlFlowData: u, htmlText: s(E, i), htmlTextData: u, image: s(function () { return { type: "image", title: null, url: "", alt: null } }), label: i, link: s(T), listItem: s(function (e) { return { type: "listItem", spread: e._spread, checked: null, children: [] } }), listItemValue: function (e) { this.data.expectingFirstListItemValue && (this.stack[this.stack.length - 2].start = Number.parseInt(this.sliceSerialize(e), 10), this.data.expectingFirstListItemValue = void 0) }, listOrdered: s(A, function () { this.data.expectingFirstListItemValue = !0 }), listUnordered: s(A), paragraph: s(function () { return { type: "paragraph", children: [] } }), reference: function () { this.data.referenceType = "collapsed" }, referenceString: i, resourceDestinationString: i, resourceTitleString: i, setextHeading: s(m), strong: s(function () { return { type: "strong", children: [] } }), thematicBreak: s(function () { return { type: "thematicBreak" } }) }, exit: { atxHeading: a(), atxHeadingSequence: function (e) { const t = this.stack[this.stack.length - 1]; if (!t.depth) { const n = this.sliceSerialize(e).length; t.depth = n } }, autolink: a(), autolinkEmail: function (e) { h.call(this, e), this.stack[this.stack.length - 1].url = "mailto:" + this.sliceSerialize(e) }, autolinkProtocol: function (e) { h.call(this, e), this.stack[this.stack.length - 1].url = this.sliceSerialize(e) }, blockQuote: a(), characterEscapeValue: h, characterReferenceMarkerHexadecimal: p, characterReferenceMarkerNumeric: p, characterReferenceValue: function (e) { const t = this.sliceSerialize(e), n = this.data.characterReferenceType; let r; n ? (r = Va(t, "characterReferenceMarkerNumeric" === n ? 10 : 16), this.data.characterReferenceType = void 0) : r = Ua(t); this.stack[this.stack.length - 1].value += r }, characterReference: function (e) { this.stack.pop().position.end = Cc(e.end) }, codeFenced: a(function () { const e = this.resume(); this.stack[this.stack.length - 1].value = e.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0 }), codeFencedFence: function () { this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0) }, codeFencedFenceInfo: function () { const e = this.resume(); this.stack[this.stack.length - 1].lang = e }, codeFencedFenceMeta: function () { const e = this.resume(); this.stack[this.stack.length - 1].meta = e }, codeFlowValue: h, codeIndented: a(function () { const e = this.resume(); this.stack[this.stack.length - 1].value = e.replace(/(\r?\n|\r)$/g, "") }), codeText: a(function () { const e = this.resume(); this.stack[this.stack.length - 1].value = e }), codeTextData: h, data: h, definition: a(), definitionDestinationString: function () { const e = this.resume(); this.stack[this.stack.length - 1].url = e }, definitionLabelString: function (e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.label = t, n.identifier = $a(this.sliceSerialize(e)).toLowerCase() }, definitionTitleString: function () { const e = this.resume(); this.stack[this.stack.length - 1].title = e }, emphasis: a(), hardBreakEscape: a(d), hardBreakTrailing: a(d), htmlFlow: a(function () { const e = this.resume(); this.stack[this.stack.length - 1].value = e }), htmlFlowData: h, htmlText: a(function () { const e = this.resume(); this.stack[this.stack.length - 1].value = e }), htmlTextData: h, image: a(function () { const e = this.stack[this.stack.length - 1]; if (this.data.inReference) { const t = this.data.referenceType || "shortcut"; e.type += "Reference", e.referenceType = t, delete e.url, delete e.title } else delete e.identifier, delete e.label; this.data.referenceType = void 0 }), label: function () { const e = this.stack[this.stack.length - 1], t = this.resume(), n = this.stack[this.stack.length - 1]; if (this.data.inReference = !0, "link" === n.type) { const t = e.children; n.children = t } else n.alt = t }, labelText: function (e) { const t = this.sliceSerialize(e), n = this.stack[this.stack.length - 2]; n.label = function (e) { return e.replace(yc, bc) }(t), n.identifier = $a(t).toLowerCase() }, lineEnding: function (e) { const n = this.stack[this.stack.length - 1]; if (this.data.atHardBreak) return n.children[n.children.length - 1].position.end = Cc(e.end), void (this.data.atHardBreak = void 0); !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(n.type) && (u.call(this, e), h.call(this, e)) }, link: a(function () { const e = this.stack[this.stack.length - 1]; if (this.data.inReference) { const t = this.data.referenceType || "shortcut"; e.type += "Reference", e.referenceType = t, delete e.url, delete e.title } else delete e.identifier, delete e.label; this.data.referenceType = void 0 }), listItem: a(), listOrdered: a(), listUnordered: a(), paragraph: a(), referenceString: function (e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.label = t, n.identifier = $a(this.sliceSerialize(e)).toLowerCase(), this.data.referenceType = "full" }, resourceDestinationString: function () { const e = this.resume(); this.stack[this.stack.length - 1].url = e }, resourceTitleString: function () { const e = this.resume(); this.stack[this.stack.length - 1].title = e }, resource: function () { this.data.inReference = void 0 }, setextHeading: a(function () { this.data.setextHeadingSlurpLineEnding = void 0 }), setextHeadingLineSequence: function (e) { this.stack[this.stack.length - 1].depth = 61 === this.sliceSerialize(e).codePointAt(0) ? 1 : 2 }, setextHeadingText: function () { this.data.setextHeadingSlurpLineEnding = !0 }, strong: a(), thematicBreak: a() } }; Nc(t, (e || {}).mdastExtensions || []); const n = {}; return function (e) { let s = { type: "root", children: [] }; const a = { stack: [s], tokenStack: [], config: t, enter: o, exit: l, buffer: i, resume: c, data: n }, u = []; let h = -1; for (; ++h < e.length;)"listOrdered" !== e[h][1].type && "listUnordered" !== e[h][1].type || ("enter" === e[h][0] ? u.push(h) : h = r(e, u.pop(), h)); for (h = -1; ++h < e.length;) { const n = t[e[h][0]]; Sc.call(n, e[h][1].type) && n[e[h][1].type].call(Object.assign({ sliceSerialize: e[h][2].sliceSerialize }, a), e[h][1]) } if (a.tokenStack.length > 0) { const e = a.tokenStack[a.tokenStack.length - 1]; (e[1] || Oc).call(a, void 0, e[0]) } for (s.position = { start: Cc(e.length > 0 ? e[0][1].start : { line: 1, column: 1, offset: 0 }), end: Cc(e.length > 0 ? e[e.length - 2][1].end : { line: 1, column: 1, offset: 0 }) }, h = -1; ++h < t.transforms.length;)s = t.transforms[h](s) || s; return s }; function r(e, t, n) { let r, s, i, o, a = t - 1, l = -1, c = !1; for (; ++a <= n;) { const t = e[a]; switch (t[1].type) { case "listUnordered": case "listOrdered": case "blockQuote": "enter" === t[0] ? l++ : l--, o = void 0; break; case "lineEndingBlank": "enter" === t[0] && (!r || o || l || i || (i = a), o = void 0); break; case "linePrefix": case "listItemValue": case "listItemMarker": case "listItemPrefix": case "listItemPrefixWhitespace": break; default: o = void 0 }if (!l && "enter" === t[0] && "listItemPrefix" === t[1].type || -1 === l && "exit" === t[0] && ("listUnordered" === t[1].type || "listOrdered" === t[1].type)) { if (r) { let o = a; for (s = void 0; o--;) { const t = e[o]; if ("lineEnding" === t[1].type || "lineEndingBlank" === t[1].type) { if ("exit" === t[0]) continue; s && (e[s][1].type = "lineEndingBlank", c = !0), t[1].type = "lineEnding", s = o } else if ("linePrefix" !== t[1].type && "blockQuotePrefix" !== t[1].type && "blockQuotePrefixWhitespace" !== t[1].type && "blockQuoteMarker" !== t[1].type && "listItemIndent" !== t[1].type) break } i && (!s || i < s) && (r._spread = !0), r.end = Object.assign({}, s ? e[s][1].start : t[1].end), e.splice(s || a, 0, ["exit", r, t[2]]), a++, n++ } if ("listItemPrefix" === t[1].type) { const s = { type: "listItem", _spread: !1, start: Object.assign({}, t[1].start), end: void 0 }; r = s, e.splice(a, 0, ["enter", s, t[2]]), a++, n++, i = void 0, o = !0 } } } return e[t][1]._spread = c, n } function s(e, t) { return function (n) { o.call(this, e(n), n), t && t.call(this, n) } } function i() { this.stack.push({ type: "fragment", children: [] }) } function o(e, t, n) { this.stack[this.stack.length - 1].children.push(e), this.stack.push(e), this.tokenStack.push([t, n || void 0]), e.position = { start: Cc(t.start), end: void 0 } } function a(e) { return function (t) { e && e.call(this, t), l.call(this, t) } } function l(e, t) { const n = this.stack.pop(), r = this.tokenStack.pop(); if (!r) throw new Error("Cannot close `" + e.type + "` (" + pa({ start: e.start, end: e.end }) + "): its not open"); r[0].type !== e.type && (t ? t.call(this, e, r[0]) : (r[1] || Oc).call(this, e, r[0])), n.position.end = Cc(e.end) } function c() { return wa(this.stack.pop()) } function u(e) { const t = this.stack[this.stack.length - 1].children; let n = t[t.length - 1]; n && "text" === n.type || (n = { type: "text", value: "" }, n.position = { start: Cc(e.start), end: void 0 }, t.push(n)), this.stack.push(n) } function h(e) { const t = this.stack.pop(); t.value += this.sliceSerialize(e), t.position.end = Cc(e.end) } function d() { this.data.atHardBreak = !0 } function p(e) { this.data.characterReferenceType = e.type } function f() { return { type: "code", lang: null, meta: null, value: "" } } function m() { return { type: "heading", depth: 0, children: [] } } function g() { return { type: "break" } } function E() { return { type: "html", value: "" } } function T() { return { type: "link", title: null, url: "", children: [] } } function A(e) { return { type: "list", ordered: "listOrdered" === e.type, start: null, spread: e._spread, children: [] } } }(n)(function (e) { for (; !Ol(e);); return e }(function (e) { const t = { constructs: za([Tc, ...(e || {}).extensions || []]), content: n(cl), defined: [], document: n(ul), flow: n(sc), lazy: {}, string: n(oc), text: n(ac) }; return t; function n(e) { return function (n) { return Ac(t, e, n) } } }(n).document().write(function () { let e, t = 1, n = "", r = !0; return function (s, i, o) { const a = []; let l, c, u, h, d; for (s = n + ("string" == typeof s ? s.toString() : new TextDecoder(i || void 0).decode(s)), u = 0, n = "", r && (65279 === s.charCodeAt(0) && u++, r = void 0); u < s.length;) { if (_c.lastIndex = u, l = _c.exec(s), h = l && void 0 !== l.index ? l.index : s.length, d = s.charCodeAt(h), !l) { n = s.slice(u); break } if (10 === d && u === h && e) a.push(-3), e = void 0; else switch (e && (a.push(-5), e = void 0), u < h && (a.push(s.slice(u, h)), t += h - u), d) { case 0: a.push(65533), t++; break; case 9: for (c = 4 * Math.ceil(t / 4), a.push(-2); t++ < c;)a.push(-1); break; case 10: a.push(-4), t = 1; break; default: e = !0, t = 1 }u = h + 1 } return o && (e && a.push(-5), n && a.push(n), a.push(null)), a } }()(e, t, !0)))) } function Cc(e) { return { line: e.line, column: e.column, offset: e.offset } } function Nc(e, t) { let n = -1; for (; ++n < t.length;) { const r = t[n]; Array.isArray(r) ? Nc(e, r) : Ic(e, r) } } function Ic(e, t) { let n; for (n in t) if (Sc.call(t, n)) switch (n) { case "canContainEols": { const r = t[n]; r && e[n].push(...r); break } case "transforms": { const r = t[n]; r && e[n].push(...r); break } case "enter": case "exit": { const r = t[n]; r && Object.assign(e[n], r); break } } } function Oc(e, t) { throw e ? new Error("Cannot close `" + e.type + "` (" + pa({ start: e.start, end: e.end }) + "): a different token (`" + t.type + "`, " + pa({ start: t.start, end: t.end }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + pa({ start: t.start, end: t.end }) + ") is still open") } function xc(e) { const t = this; t.parser = function (n) { return kc(n, { ...t.data("settings"), ...e, extensions: t.data("micromarkExtensions") || [], mdastExtensions: t.data("fromMarkdownExtensions") || [] }) } } function Rc(e, t) { const n = t.referenceType; let r = "]"; if ("collapsed" === n ? r += "[]" : "full" === n && (r += "[" + (t.label || t.identifier) + "]"), "imageReference" === t.type) return [{ type: "text", value: "![" + t.alt + r }]; const s = e.all(t), i = s[0]; i && "text" === i.type ? i.value = "[" + i.value : s.unshift({ type: "text", value: "[" }); const o = s[s.length - 1]; return o && "text" === o.type ? o.value += r : s.push({ type: "text", value: r }), s } function vc(e) { const t = e.spread; return null == t ? e.children.length > 1 : t } function Dc(e) { const t = String(e), n = /\r?\n|\r/g; let r = n.exec(t), s = 0; const i = []; for (; r;)i.push(Lc(t.slice(s, r.index), s > 0, !0), r[0]), s = r.index + r[0].length, r = n.exec(t); return i.push(Lc(t.slice(s), s > 0, !1)), i.join("") } function Lc(e, t, n) { let r = 0, s = e.length; if (t) { let t = e.codePointAt(r); for (; 9 === t || 32 === t;)r++, t = e.codePointAt(r) } if (n) { let t = e.codePointAt(s - 1); for (; 9 === t || 32 === t;)s--, t = e.codePointAt(s - 1) } return s > r ? e.slice(r, s) : "" } const Pc = { blockquote: function (e, t) { const n = { type: "element", tagName: "blockquote", properties: {}, children: e.wrap(e.all(t), !0) }; return e.patch(t, n), e.applyData(t, n) }, break: function (e, t) { const n = { type: "element", tagName: "br", properties: {}, children: [] }; return e.patch(t, n), [e.applyData(t, n), { type: "text", value: "\n" }] }, code: function (e, t) { const n = t.value ? t.value + "\n" : "", r = {}, s = t.lang ? t.lang.split(/\s+/) : []; s.length > 0 && (r.className = ["language-" + s[0]]); let i = { type: "element", tagName: "code", properties: r, children: [{ type: "text", value: n }] }; return t.meta && (i.data = { meta: t.meta }), e.patch(t, i), i = e.applyData(t, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, e.patch(t, i), i }, delete: function (e, t) { const n = { type: "element", tagName: "del", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, emphasis: function (e, t) { const n = { type: "element", tagName: "em", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, footnoteReference: function (e, t) { const n = "string" == typeof e.options.clobberPrefix ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), s = al(r.toLowerCase()), i = e.footnoteOrder.indexOf(r); let o, a = e.footnoteCounts.get(r); void 0 === a ? (a = 0, e.footnoteOrder.push(r), o = e.footnoteOrder.length) : o = i + 1, a += 1, e.footnoteCounts.set(r, a); const l = { type: "element", tagName: "a", properties: { href: "#" + n + "fn-" + s, id: n + "fnref-" + s + (a > 1 ? "-" + a : ""), dataFootnoteRef: !0, ariaDescribedBy: ["footnote-label"] }, children: [{ type: "text", value: String(o) }] }; e.patch(t, l); const c = { type: "element", tagName: "sup", properties: {}, children: [l] }; return e.patch(t, c), e.applyData(t, c) }, heading: function (e, t) { const n = { type: "element", tagName: "h" + t.depth, properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, html: function (e, t) { if (e.options.allowDangerousHtml) { const n = { type: "raw", value: t.value }; return e.patch(t, n), e.applyData(t, n) } }, imageReference: function (e, t) { const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n); if (!r) return Rc(e, t); const s = { src: al(r.url || ""), alt: t.alt }; null !== r.title && void 0 !== r.title && (s.title = r.title); const i = { type: "element", tagName: "img", properties: s, children: [] }; return e.patch(t, i), e.applyData(t, i) }, image: function (e, t) { const n = { src: al(t.url) }; null !== t.alt && void 0 !== t.alt && (n.alt = t.alt), null !== t.title && void 0 !== t.title && (n.title = t.title); const r = { type: "element", tagName: "img", properties: n, children: [] }; return e.patch(t, r), e.applyData(t, r) }, inlineCode: function (e, t) { const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") }; e.patch(t, n); const r = { type: "element", tagName: "code", properties: {}, children: [n] }; return e.patch(t, r), e.applyData(t, r) }, linkReference: function (e, t) { const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n); if (!r) return Rc(e, t); const s = { href: al(r.url || "") }; null !== r.title && void 0 !== r.title && (s.title = r.title); const i = { type: "element", tagName: "a", properties: s, children: e.all(t) }; return e.patch(t, i), e.applyData(t, i) }, link: function (e, t) { const n = { href: al(t.url) }; null !== t.title && void 0 !== t.title && (n.title = t.title); const r = { type: "element", tagName: "a", properties: n, children: e.all(t) }; return e.patch(t, r), e.applyData(t, r) }, listItem: function (e, t, n) { const r = e.all(t), s = n ? function (e) { let t = !1; if ("list" === e.type) { t = e.spread || !1; const n = e.children; let r = -1; for (; !t && ++r < n.length;)t = vc(n[r]) } return t }(n) : vc(t), i = {}, o = []; if ("boolean" == typeof t.checked) { const e = r[0]; let n; e && "element" === e.type && "p" === e.tagName ? n = e : (n = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(n)), n.children.length > 0 && n.children.unshift({ type: "text", value: " " }), n.children.unshift({ type: "element", tagName: "input", properties: { type: "checkbox", checked: t.checked, disabled: !0 }, children: [] }), i.className = ["task-list-item"] } let a = -1; for (; ++a < r.length;) { const e = r[a]; (s || 0 !== a || "element" !== e.type || "p" !== e.tagName) && o.push({ type: "text", value: "\n" }), "element" !== e.type || "p" !== e.tagName || s ? o.push(e) : o.push(...e.children) } const l = r[r.length - 1]; l && (s || "element" !== l.type || "p" !== l.tagName) && o.push({ type: "text", value: "\n" }); const c = { type: "element", tagName: "li", properties: i, children: o }; return e.patch(t, c), e.applyData(t, c) }, list: function (e, t) { const n = {}, r = e.all(t); let s = -1; for ("number" == typeof t.start && 1 !== t.start && (n.start = t.start); ++s < r.length;) { const e = r[s]; if ("element" === e.type && "li" === e.tagName && e.properties && Array.isArray(e.properties.className) && e.properties.className.includes("task-list-item")) { n.className = ["contains-task-list"]; break } } const i = { type: "element", tagName: t.ordered ? "ol" : "ul", properties: n, children: e.wrap(r, !0) }; return e.patch(t, i), e.applyData(t, i) }, paragraph: function (e, t) { const n = { type: "element", tagName: "p", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, root: function (e, t) { const n = { type: "root", children: e.wrap(e.all(t)) }; return e.patch(t, n), e.applyData(t, n) }, strong: function (e, t) { const n = { type: "element", tagName: "strong", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, table: function (e, t) { const n = e.all(t), r = n.shift(), s = []; if (r) { const n = { type: "element", tagName: "thead", properties: {}, children: e.wrap([r], !0) }; e.patch(t.children[0], n), s.push(n) } if (n.length > 0) { const r = { type: "element", tagName: "tbody", properties: {}, children: e.wrap(n, !0) }, i = ha(t.children[1]), o = ua(t.children[t.children.length - 1]); i && o && (r.position = { start: i, end: o }), s.push(r) } const i = { type: "element", tagName: "table", properties: {}, children: e.wrap(s, !0) }; return e.patch(t, i), e.applyData(t, i) }, tableCell: function (e, t) { const n = { type: "element", tagName: "td", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, tableRow: function (e, t, n) { const r = n ? n.children : void 0, s = 0 === (r ? r.indexOf(t) : 1) ? "th" : "td", i = n && "table" === n.type ? n.align : void 0, o = i ? i.length : t.children.length; let a = -1; const l = []; for (; ++a < o;) { const n = t.children[a], r = {}, o = i ? i[a] : void 0; o && (r.align = o); let c = { type: "element", tagName: s, properties: r, children: [] }; n && (c.children = e.all(n), e.patch(n, c), c = e.applyData(n, c)), l.push(c) } const c = { type: "element", tagName: "tr", properties: {}, children: e.wrap(l, !0) }; return e.patch(t, c), e.applyData(t, c) }, text: function (e, t) { const n = { type: "text", value: Dc(String(t.value)) }; return e.patch(t, n), e.applyData(t, n) }, thematicBreak: function (e, t) { const n = { type: "element", tagName: "hr", properties: {}, children: [] }; return e.patch(t, n), e.applyData(t, n) }, toml: wc, yaml: wc, definition: wc, footnoteDefinition: wc }; function wc() { } const Mc = "object" == typeof self ? self : globalThis, Fc = e => ((e, t) => { const n = (t, n) => (e.set(n, t), t), r = s => { if (e.has(s)) return e.get(s); const [i, o] = t[s]; switch (i) { case 0: case -1: return n(o, s); case 1: { const e = n([], s); for (const t of o) e.push(r(t)); return e } case 2: { const e = n({}, s); for (const [t, n] of o) e[r(t)] = r(n); return e } case 3: return n(new Date(o), s); case 4: { const { source: e, flags: t } = o; return n(new RegExp(e, t), s) } case 5: { const e = n(new Map, s); for (const [t, n] of o) e.set(r(t), r(n)); return e } case 6: { const e = n(new Set, s); for (const t of o) e.add(r(t)); return e } case 7: { const { name: e, message: t } = o; return n(new Mc[e](t), s) } case 8: return n(BigInt(o), s); case "BigInt": return n(Object(BigInt(o)), s); case "ArrayBuffer": return n(new Uint8Array(o).buffer, o); case "DataView": { const { buffer: e } = new Uint8Array(o); return n(new DataView(e), o) } }return n(new Mc[i](o), s) }; return r })(new Map, e)(0), Bc = "", { toString: Uc } = {}, { keys: Hc } = Object, jc = e => { const t = typeof e; if ("object" !== t || !e) return [0, t]; const n = Uc.call(e).slice(8, -1); switch (n) { case "Array": return [1, Bc]; case "Object": return [2, Bc]; case "Date": return [3, Bc]; case "RegExp": return [4, Bc]; case "Map": return [5, Bc]; case "Set": return [6, Bc]; case "DataView": return [1, n] }return n.includes("Array") ? [1, n] : n.includes("Error") ? [7, n] : [2, n] }, Gc = ([e, t]) => 0 === e && ("function" === t || "symbol" === t), zc = (e, { json: t, lossy: n } = {}) => { const r = []; return ((e, t, n, r) => { const s = (e, t) => { const s = r.push(e) - 1; return n.set(t, s), s }, i = r => { if (n.has(r)) return n.get(r); let [o, a] = jc(r); switch (o) { case 0: { let t = r; switch (a) { case "bigint": o = 8, t = r.toString(); break; case "function": case "symbol": if (e) throw new TypeError("unable to serialize " + a); t = null; break; case "undefined": return s([-1], r) }return s([o, t], r) } case 1: { if (a) { let e = r; return "DataView" === a ? e = new Uint8Array(r.buffer) : "ArrayBuffer" === a && (e = new Uint8Array(r)), s([a, [...e]], r) } const e = [], t = s([o, e], r); for (const n of r) e.push(i(n)); return t } case 2: { if (a) switch (a) { case "BigInt": return s([a, r.toString()], r); case "Boolean": case "Number": case "String": return s([a, r.valueOf()], r) }if (t && "toJSON" in r) return i(r.toJSON()); const n = [], l = s([o, n], r); for (const t of Hc(r)) !e && Gc(jc(r[t])) || n.push([i(t), i(r[t])]); return l } case 3: return s([o, r.toISOString()], r); case 4: { const { source: e, flags: t } = r; return s([o, { source: e, flags: t }], r) } case 5: { const t = [], n = s([o, t], r); for (const [s, o] of r) (e || !Gc(jc(s)) && !Gc(jc(o))) && t.push([i(s), i(o)]); return n } case 6: { const t = [], n = s([o, t], r); for (const s of r) !e && Gc(jc(s)) || t.push(i(s)); return n } }const { message: l } = r; return s([o, { name: a, message: l }], r) }; return i })(!(t || n), !!t, new Map, r)(e), r }, Yc = "function" == typeof structuredClone ? (e, t) => t && ("json" in t || "lossy" in t) ? Fc(zc(e, t)) : structuredClone(e) : (e, t) => Fc(zc(e, t)); function qc(e, t) { const n = [{ type: "text", value: "" }]; return t > 1 && n.push({ type: "element", tagName: "sup", properties: {}, children: [{ type: "text", value: String(t) }] }), n } function Vc(e, t) { return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "") } const $c = function (e) { if (null == e) return Kc; if ("function" == typeof e) return Wc(e); if ("object" == typeof e) return Array.isArray(e) ? function (e) { const t = []; let n = -1; for (; ++n < e.length;)t[n] = $c(e[n]); return Wc(function (...e) { let n = -1; for (; ++n < t.length;)if (t[n].apply(this, e)) return !0; return !1 }) }(e) : function (e) { const t = e; return Wc(function (n) { const r = n; let s; for (s in e) if (r[s] !== t[s]) return !1; return !0 }) }(e); if ("string" == typeof e) return t = e, Wc(function (e) { return e && e.type === t }); var t; throw new Error("Expected function, string, or object as test") }; function Wc(e) { return function (t, n, r) { return Boolean(function (e) { return null !== e && "object" == typeof e && "type" in e }(t) && e.call(this, t, "number" == typeof n ? n : void 0, r || void 0)) } } function Kc() { return !0 } const Qc = [], Xc = !1; function Jc(e, t, n, r) { let s; "function" == typeof t && "function" != typeof n ? (r = n, n = t) : s = t; const i = $c(s), o = r ? -1 : 1; !function e(s, a, l) { const c = s && "object" == typeof s ? s : {}; if ("string" == typeof c.type) { const e = "string" == typeof c.tagName ? c.tagName : "string" == typeof c.name ? c.name : void 0; Object.defineProperty(u, "name", { value: "node (" + s.type + (e ? "<" + e + ">" : "") + ")" }) } return u; function u() { let c, u, h, d = Qc; if ((!t || i(s, a, l[l.length - 1] || void 0)) && (d = function (e) { return Array.isArray(e) ? e : "number" == typeof e ? [true, e] : null == e ? Qc : [e] }(n(s, l)), d[0] === Xc)) return d; if ("children" in s && s.children) { const t = s; if (t.children && "skip" !== d[0]) for (u = (r ? t.children.length : -1) + o, h = l.concat(t); u > -1 && u < t.children.length;) { const n = t.children[u]; if (c = e(n, u, h)(), c[0] === Xc) return c; u = "number" == typeof c[1] ? c[1] : u + o } } return d } }(e, void 0, [])() } function Zc(e, t, n, r) { let s, i, o; "function" == typeof t && "function" != typeof n ? (i = void 0, o = t, s = n) : (i = t, o = n, s = r), Jc(e, i, function (e, t) { const n = t[t.length - 1], r = n ? n.children.indexOf(e) : void 0; return o(e, r, n) }, s) } const eu = {}.hasOwnProperty, tu = {}; function nu(e, t) { e.position && (t.position = function (e) { const t = ha(e), n = ua(e); if (t && n) return { start: t, end: n } }(e)) } function ru(e, t) { let n = t; if (e && e.data) { const t = e.data.hName, r = e.data.hChildren, s = e.data.hProperties; "string" == typeof t && ("element" === n.type ? n.tagName = t : n = { type: "element", tagName: t, properties: {}, children: "children" in n ? n.children : [n] }), "element" === n.type && s && Object.assign(n.properties, Yc(s)), "children" in n && n.children && null != r && (n.children = r) } return n } function su(e, t) { const n = t.data || {}, r = !("value" in t) || eu.call(n, "hProperties") || eu.call(n, "hChildren") ? { type: "element", tagName: "div", properties: {}, children: e.all(t) } : { type: "text", value: t.value }; return e.patch(t, r), e.applyData(t, r) } function iu(e, t) { const n = []; let r = -1; for (t && n.push({ type: "text", value: "\n" }); ++r < e.length;)r && n.push({ type: "text", value: "\n" }), n.push(e[r]); return t && e.length > 0 && n.push({ type: "text", value: "\n" }), n } function ou(e) { let t = 0, n = e.charCodeAt(t); for (; 9 === n || 32 === n;)t++, n = e.charCodeAt(t); return e.slice(t) } function au(e, t) { const n = function (e, t) { const n = t || tu, r = new Map, s = new Map, i = new Map, o = { ...Pc, ...n.handlers }, a = { all: function (e) { const t = []; if ("children" in e) { const n = e.children; let r = -1; for (; ++r < n.length;) { const s = a.one(n[r], e); if (s) { if (r && "break" === n[r - 1].type && (Array.isArray(s) || "text" !== s.type || (s.value = ou(s.value)), !Array.isArray(s) && "element" === s.type)) { const e = s.children[0]; e && "text" === e.type && (e.value = ou(e.value)) } Array.isArray(s) ? t.push(...s) : t.push(s) } } } return t }, applyData: ru, definitionById: r, footnoteById: s, footnoteCounts: i, footnoteOrder: [], handlers: o, one: function (e, t) { const n = e.type, r = a.handlers[n]; if (eu.call(a.handlers, n) && r) return r(a, e, t); if (a.options.passThrough && a.options.passThrough.includes(n)) { if ("children" in e) { const { children: t, ...n } = e, r = Yc(n); return r.children = a.all(e), r } return Yc(e) } return (a.options.unknownHandler || su)(a, e, t) }, options: n, patch: nu, wrap: iu }; return Zc(e, function (e) { if ("definition" === e.type || "footnoteDefinition" === e.type) { const t = "definition" === e.type ? r : s, n = String(e.identifier).toUpperCase(); t.has(n) || t.set(n, e) } }), a }(e, t), r = n.one(e, void 0), s = function (e) { const t = "string" == typeof e.options.clobberPrefix ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || qc, r = e.options.footnoteBackLabel || Vc, s = e.options.footnoteLabel || "Footnotes", i = e.options.footnoteLabelTagName || "h2", o = e.options.footnoteLabelProperties || { className: ["sr-only"] }, a = []; let l = -1; for (; ++l < e.footnoteOrder.length;) { const s = e.footnoteById.get(e.footnoteOrder[l]); if (!s) continue; const i = e.all(s), o = String(s.identifier).toUpperCase(), c = al(o.toLowerCase()); let u = 0; const h = [], d = e.footnoteCounts.get(o); for (; void 0 !== d && ++u <= d;) { h.length > 0 && h.push({ type: "text", value: " " }); let e = "string" == typeof n ? n : n(l, u); "string" == typeof e && (e = { type: "text", value: e }), h.push({ type: "element", tagName: "a", properties: { href: "#" + t + "fnref-" + c + (u > 1 ? "-" + u : ""), dataFootnoteBackref: "", ariaLabel: "string" == typeof r ? r : r(l, u), className: ["data-footnote-backref"] }, children: Array.isArray(e) ? e : [e] }) } const p = i[i.length - 1]; if (p && "element" === p.type && "p" === p.tagName) { const e = p.children[p.children.length - 1]; e && "text" === e.type ? e.value += " " : p.children.push({ type: "text", value: " " }), p.children.push(...h) } else i.push(...h); const f = { type: "element", tagName: "li", properties: { id: t + "fn-" + c }, children: e.wrap(i, !0) }; e.patch(s, f), a.push(f) } if (0 !== a.length) return { type: "element", tagName: "section", properties: { dataFootnotes: !0, className: ["footnotes"] }, children: [{ type: "element", tagName: i, properties: { ...Yc(o), id: "footnote-label" }, children: [{ type: "text", value: s }] }, { type: "text", value: "\n" }, { type: "element", tagName: "ol", properties: {}, children: e.wrap(a, !0) }, { type: "text", value: "\n" }] } }(n), i = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] }; return s && i.children.push({ type: "text", value: "\n" }, s), i } function lu(e, t) { return e && "run" in e ? async function (n, r) { const s = au(n, { file: r, ...t }); await e.run(s, r) } : function (n, r) { return au(n, { file: r, ...e || t }) } } function cu(e) { if (e) throw e } var uu = Object.prototype.hasOwnProperty, hu = Object.prototype.toString, du = Object.defineProperty, pu = Object.getOwnPropertyDescriptor, fu = function (e) { return "function" == typeof Array.isArray ? Array.isArray(e) : "[object Array]" === hu.call(e) }, mu = function (e) { if (!e || "[object Object]" !== hu.call(e)) return !1; var t, n = uu.call(e, "constructor"), r = e.constructor && e.constructor.prototype && uu.call(e.constructor.prototype, "isPrototypeOf"); if (e.constructor && !n && !r) return !1; for (t in e); return void 0 === t || uu.call(e, t) }, gu = function (e, t) { du && "__proto__" === t.name ? du(e, t.name, { enumerable: !0, configurable: !0, value: t.newValue, writable: !0 }) : e[t.name] = t.newValue }, Eu = function (e, t) { if ("__proto__" === t) { if (!uu.call(e, t)) return; if (pu) return pu(e, t).value } return e[t] }; const Tu = i(function e() { var t, n, r, s, i, o, a = arguments[0], l = 1, c = arguments.length, u = !1; for ("boolean" == typeof a && (u = a, a = arguments[1] || {}, l = 2), (null == a || "object" != typeof a && "function" != typeof a) && (a = {}); l < c; ++l)if (null != (t = arguments[l])) for (n in t) r = Eu(a, n), a !== (s = Eu(t, n)) && (u && s && (mu(s) || (i = fu(s))) ? (i ? (i = !1, o = r && fu(r) ? r : []) : o = r && mu(r) ? r : {}, gu(a, { name: n, newValue: e(u, o, s) })) : void 0 !== s && gu(a, { name: n, newValue: s })); return a }); function Au(e) { if ("object" != typeof e || null === e) return !1; const t = Object.getPrototypeOf(e); return !(null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t) || Symbol.toStringTag in e || Symbol.iterator in e) } const _u = function (e, t) { if (void 0 !== t && "string" != typeof t) throw new TypeError('"ext" argument must be a string'); Cu(e); let n, r = 0, s = -1, i = e.length; if (void 0 === t || 0 === t.length || t.length > e.length) { for (; i--;)if (47 === e.codePointAt(i)) { if (n) { r = i + 1; break } } else s < 0 && (n = !0, s = i + 1); return s < 0 ? "" : e.slice(r, s) } if (t === e) return ""; let o = -1, a = t.length - 1; for (; i--;)if (47 === e.codePointAt(i)) { if (n) { r = i + 1; break } } else o < 0 && (n = !0, o = i + 1), a > -1 && (e.codePointAt(i) === t.codePointAt(a--) ? a < 0 && (s = i) : (a = -1, s = o)); return r === s ? s = o : s < 0 && (s = e.length), e.slice(r, s) }, yu = function (e) { if (Cu(e), 0 === e.length) return "."; let t, n = -1, r = e.length; for (; --r;)if (47 === e.codePointAt(r)) { if (t) { n = r; break } } else t || (t = !0); return n < 0 ? 47 === e.codePointAt(0) ? "/" : "." : 1 === n && 47 === e.codePointAt(0) ? "//" : e.slice(0, n) }, bu = function (e) { Cu(e); let t, n = e.length, r = -1, s = 0, i = -1, o = 0; for (; n--;) { const a = e.codePointAt(n); if (47 !== a) r < 0 && (t = !0, r = n + 1), 46 === a ? i < 0 ? i = n : 1 !== o && (o = 1) : i > -1 && (o = -1); else if (t) { s = n + 1; break } } return i < 0 || r < 0 || 0 === o || 1 === o && i === r - 1 && i === s + 1 ? "" : e.slice(i, r) }, Su = function (...e) { let t, n = -1; for (; ++n < e.length;)Cu(e[n]), e[n] && (t = void 0 === t ? e[n] : t + "/" + e[n]); return void 0 === t ? "." : function (e) { Cu(e); const t = 47 === e.codePointAt(0); let n = function (e, t) { let n, r, s = "", i = 0, o = -1, a = 0, l = -1; for (; ++l <= e.length;) { if (l < e.length) n = e.codePointAt(l); else { if (47 === n) break; n = 47 } if (47 === n) { if (o === l - 1 || 1 === a); else if (o !== l - 1 && 2 === a) { if (s.length < 2 || 2 !== i || 46 !== s.codePointAt(s.length - 1) || 46 !== s.codePointAt(s.length - 2)) if (s.length > 2) { if (r = s.lastIndexOf("/"), r !== s.length - 1) { r < 0 ? (s = "", i = 0) : (s = s.slice(0, r), i = s.length - 1 - s.lastIndexOf("/")), o = l, a = 0; continue } } else if (s.length > 0) { s = "", i = 0, o = l, a = 0; continue } t && (s = s.length > 0 ? s + "/.." : "..", i = 2) } else s.length > 0 ? s += "/" + e.slice(o + 1, l) : s = e.slice(o + 1, l), i = l - o - 1; o = l, a = 0 } else 46 === n && a > -1 ? a++ : a = -1 } return s }(e, !t); return 0 !== n.length || t || (n = "."), n.length > 0 && 47 === e.codePointAt(e.length - 1) && (n += "/"), t ? "/" + n : n }(t) }, ku = "/"; function Cu(e) { if ("string" != typeof e) throw new TypeError("Path must be a string. Received " + JSON.stringify(e)) } const Nu = function () { return "/" }; function Iu(e) { return Boolean(null !== e && "object" == typeof e && "href" in e && e.href && "protocol" in e && e.protocol && void 0 === e.auth) } const Ou = ["history", "path", "basename", "stem", "extname", "dirname"]; class xu { constructor(e) { let t; t = e ? Iu(e) ? { path: e } : "string" == typeof e || function (e) { return Boolean(e && "object" == typeof e && "byteLength" in e && "byteOffset" in e) }(e) ? { value: e } : e : {}, this.cwd = "cwd" in t ? "" : Nu(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored; let n, r = -1; for (; ++r < Ou.length;) { const e = Ou[r]; e in t && void 0 !== t[e] && null !== t[e] && (this[e] = "history" === e ? [...t[e]] : t[e]) } for (n in t) Ou.includes(n) || (this[n] = t[n]) } get basename() { return "string" == typeof this.path ? _u(this.path) : void 0 } set basename(e) { vu(e, "basename"), Ru(e, "basename"), this.path = Su(this.dirname || "", e) } get dirname() { return "string" == typeof this.path ? yu(this.path) : void 0 } set dirname(e) { Du(this.basename, "dirname"), this.path = Su(e || "", this.basename) } get extname() { return "string" == typeof this.path ? bu(this.path) : void 0 } set extname(e) { if (Ru(e, "extname"), Du(this.dirname, "extname"), e) { if (46 !== e.codePointAt(0)) throw new Error("`extname` must start with `.`"); if (e.includes(".", 1)) throw new Error("`extname` cannot contain multiple dots") } this.path = Su(this.dirname, this.stem + (e || "")) } get path() { return this.history[this.history.length - 1] } set path(e) { Iu(e) && (e = function (e) { if ("string" == typeof e) e = new URL(e); else if (!Iu(e)) { const t = new TypeError('The "path" argument must be of type string or an instance of URL. Received `' + e + "`"); throw t.code = "ERR_INVALID_ARG_TYPE", t } if ("file:" !== e.protocol) { const e = new TypeError("The URL must be of scheme file"); throw e.code = "ERR_INVALID_URL_SCHEME", e } return function (e) { if ("" !== e.hostname) { const e = new TypeError('File URL host must be "localhost" or empty on darwin'); throw e.code = "ERR_INVALID_FILE_URL_HOST", e } const t = e.pathname; let n = -1; for (; ++n < t.length;)if (37 === t.codePointAt(n) && 50 === t.codePointAt(n + 1)) { const e = t.codePointAt(n + 2); if (70 === e || 102 === e) { const e = new TypeError("File URL path must not include encoded / characters"); throw e.code = "ERR_INVALID_FILE_URL_PATH", e } } return decodeURIComponent(t) }(e) }(e)), vu(e, "path"), this.path !== e && this.history.push(e) } get stem() { return "string" == typeof this.path ? _u(this.path, this.extname) : void 0 } set stem(e) { vu(e, "stem"), Ru(e, "stem"), this.path = Su(this.dirname || "", e + (this.extname || "")) } fail(e, t, n) { const r = this.message(e, t, n); throw r.fatal = !0, r } info(e, t, n) { const r = this.message(e, t, n); return r.fatal = void 0, r } message(e, t, n) { const r = new Ea(e, t, n); return this.path && (r.name = this.path + ":" + r.name, r.file = this.path), r.fatal = !1, this.messages.push(r), r } toString(e) { return void 0 === this.value ? "" : "string" == typeof this.value ? this.value : new TextDecoder(e || void 0).decode(this.value) } } function Ru(e, t) { if (e && e.includes(ku)) throw new Error("`" + t + "` cannot be a path: did not expect `" + ku + "`") } function vu(e, t) { if (!e) throw new Error("`" + t + "` cannot be empty") } function Du(e, t) { if (!e) throw new Error("Setting `" + t + "` requires `path` to be set too") } const Lu = function (e) { const t = this.constructor.prototype, n = t[e], r = function () { return n.apply(r, arguments) }; return Object.setPrototypeOf(r, t), r }, Pu = {}.hasOwnProperty; class wu extends Lu { constructor() { super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = function () { const e = [], t = { run: function (...t) { let n = -1; const r = t.pop(); if ("function" != typeof r) throw new TypeError("Expected function as last argument, not " + r); !function s(i, ...o) { const a = e[++n]; let l = -1; if (i) r(i); else { for (; ++l < t.length;)null !== o[l] && void 0 !== o[l] || (o[l] = t[l]); t = o, a ? function (e, t) { let n; return function (...t) { const o = e.length > t.length; let a; o && t.push(r); try { a = e.apply(this, t) } catch (i) { if (o && n) throw i; return r(i) } o || (a && a.then && "function" == typeof a.then ? a.then(s, r) : a instanceof Error ? r(a) : s(a)) }; function r(e, ...r) { n || (n = !0, t(e, ...r)) } function s(e) { r(null, e) } }(a, s)(...o) : r(null, ...o) } }(null, ...t) }, use: function (n) { if ("function" != typeof n) throw new TypeError("Expected `middelware` to be a function, not " + n); return e.push(n), t } }; return t }() } copy() { const e = new wu; let t = -1; for (; ++t < this.attachers.length;) { const n = this.attachers[t]; e.use(...n) } return e.data(Tu(!0, {}, this.namespace)), e } data(e, t) { return "string" == typeof e ? 2 === arguments.length ? (Uu("data", this.frozen), this.namespace[e] = t, this) : Pu.call(this.namespace, e) && this.namespace[e] || void 0 : e ? (Uu("data", this.frozen), this.namespace = e, this) : this.namespace } freeze() { if (this.frozen) return this; const e = this; for (; ++this.freezeIndex < this.attachers.length;) { const [t, ...n] = this.attachers[this.freezeIndex]; if (!1 === n[0]) continue; !0 === n[0] && (n[0] = void 0); const r = t.call(e, ...n); "function" == typeof r && this.transformers.use(r) } return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this } parse(e) { this.freeze(); const t = Gu(e), n = this.parser || this.Parser; return Fu("parse", n), n(String(t), t) } process(e, t) { const n = this; return this.freeze(), Fu("process", this.parser || this.Parser), Bu("process", this.compiler || this.Compiler), t ? r(void 0, t) : new Promise(r); function r(r, s) { const i = Gu(e), o = n.parse(i); function a(e, n) { e || !n ? s(e) : r ? r(n) : t(void 0, n) } n.run(o, i, function (e, t, r) { if (e || !t || !r) return a(e); const s = t, i = n.stringify(s, r); var o; "string" == typeof (o = i) || function (e) { return Boolean(e && "object" == typeof e && "byteLength" in e && "byteOffset" in e) }(o) ? r.value = i : r.result = i, a(e, r) }) } } processSync(e) { let t, n = !1; return this.freeze(), Fu("processSync", this.parser || this.Parser), Bu("processSync", this.compiler || this.Compiler), this.process(e, function (e, r) { n = !0, cu(e), t = r }), ju("processSync", "process", n), t } run(e, t, n) { Hu(e), this.freeze(); const r = this.transformers; return n || "function" != typeof t || (n = t, t = void 0), n ? s(void 0, n) : new Promise(s); function s(s, i) { const o = Gu(t); r.run(e, o, function (t, r, o) { const a = r || e; t ? i(t) : s ? s(a) : n(void 0, a, o) }) } } runSync(e, t) { let n, r = !1; return this.run(e, t, function (e, t) { cu(e), n = t, r = !0 }), ju("runSync", "run", r), n } stringify(e, t) { this.freeze(); const n = Gu(t), r = this.compiler || this.Compiler; return Bu("stringify", r), Hu(e), r(e, n) } use(e, ...t) { const n = this.attachers, r = this.namespace; if (Uu("use", this.frozen), null == e); else if ("function" == typeof e) a(e, t); else { if ("object" != typeof e) throw new TypeError("Expected usable value, not `" + e + "`"); Array.isArray(e) ? o(e) : i(e) } return this; function s(e) { if ("function" == typeof e) a(e, []); else { if ("object" != typeof e) throw new TypeError("Expected usable value, not `" + e + "`"); if (Array.isArray(e)) { const [t, ...n] = e; a(t, n) } else i(e) } } function i(e) { if (!("plugins" in e) && !("settings" in e)) throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"); o(e.plugins), e.settings && (r.settings = Tu(!0, r.settings, e.settings)) } function o(e) { let t = -1; if (null == e); else { if (!Array.isArray(e)) throw new TypeError("Expected a list of plugins, not `" + e + "`"); for (; ++t < e.length;)s(e[t]) } } function a(e, t) { let r = -1, s = -1; for (; ++r < n.length;)if (n[r][0] === e) { s = r; break } if (-1 === s) n.push([e, ...t]); else if (t.length > 0) { let [r, ...i] = t; const o = n[s][1]; Au(o) && Au(r) && (r = Tu(!0, o, r)), n[s] = [e, r, ...i] } } } } const Mu = (new wu).freeze(); function Fu(e, t) { if ("function" != typeof t) throw new TypeError("Cannot `" + e + "` without `parser`") } function Bu(e, t) { if ("function" != typeof t) throw new TypeError("Cannot `" + e + "` without `compiler`") } function Uu(e, t) { if (t) throw new Error("Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.") } function Hu(e) { if (!Au(e) || "string" != typeof e.type) throw new TypeError("Expected node, got `" + e + "`") } function ju(e, t, n) { if (!n) throw new Error("`" + e + "` finished async. Use `" + t + "` instead") } function Gu(e) { return function (e) { return Boolean(e && "object" == typeof e && "message" in e && "messages" in e) }(e) ? e : new xu(e) } const zu = [], Yu = { allowDangerousHtml: !0 }, qu = /^(https?|ircs?|mailto|xmpp)$/i, Vu = [{ from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" }, { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" }, { from: "allowNode", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "allowElement" }, { from: "allowedTypes", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "allowedElements" }, { from: "disallowedTypes", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "disallowedElements" }, { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" }, { from: "includeElementIndex", id: "#remove-includeelementindex" }, { from: "includeNodeIndex", id: "change-includenodeindex-to-includeelementindex" }, { from: "linkTarget", id: "remove-linktarget" }, { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" }, { from: "rawSourcePos", id: "#remove-rawsourcepos" }, { from: "renderers", id: "change-renderers-to-components", to: "components" }, { from: "source", id: "change-source-to-children", to: "children" }, { from: "sourcePos", id: "#remove-sourcepos" }, { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" }, { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }]; function $u(e) { const t = e.rehypePlugins || zu, n = e.remarkPlugins || zu, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...Yu } : Yu; return Mu().use(xc).use(n).use(lu, r).use(t) } function Wu(e) { const t = e.children || "", n = new xu; return "string" == typeof t && (n.value = t), n } function Ku(e, t) { const n = t.allowedElements, r = t.allowElement, s = t.components, i = t.disallowedElements, o = t.skipHtml, a = t.unwrapDisallowed, l = t.urlTransform || Qu; for (const c of Vu) Object.hasOwn(t, c.from) && Vi((c.from, c.to && c.to, c.id)); return t.className && (e = { type: "element", tagName: "div", properties: { className: t.className }, children: "root" === e.type ? e.children : [e] }), Zc(e, function (e, t, s) { if ("raw" === e.type && s && "number" == typeof t) return o ? s.children.splice(t, 1) : s.children[t] = { type: "text", value: e.value }, t; if ("element" === e.type) { let t; for (t in La) if (Object.hasOwn(La, t) && Object.hasOwn(e.properties, t)) { const n = e.properties[t], r = La[t]; (null === r || r.includes(e.tagName)) && (e.properties[t] = l(String(n || ""), t, e)) } } if ("element" === e.type) { let o = n ? !n.includes(e.tagName) : !!i && i.includes(e.tagName); if (!o && r && "number" == typeof t && (o = !r(e, t, s)), o && s && "number" == typeof t) return a && e.children ? s.children.splice(t, 1, ...e.children) : s.children.splice(t, 1), t } }), function (e, t) { if (!t || void 0 === t.Fragment) throw new TypeError("Expected `Fragment` in options"); const n = t.filePath || void 0; let r; if (t.development) { if ("function" != typeof t.jsxDEV) throw new TypeError("Expected `jsxDEV` in options when `development: true`"); r = function (e, t) { return function (n, r, s, i) { const o = Array.isArray(s.children), a = ha(n); return t(r, s, i, o, { columnNumber: a ? a.column - 1 : void 0, fileName: e, lineNumber: a ? a.line : void 0 }, void 0) } }(n, t.jsxDEV) } else { if ("function" != typeof t.jsx) throw new TypeError("Expected `jsx` in production options"); if ("function" != typeof t.jsxs) throw new TypeError("Expected `jsxs` in production options"); s = t.jsx, i = t.jsxs, r = function (e, t, n, r) { const o = Array.isArray(n.children) ? i : s; return r ? o(t, n, r) : o(t, n) } } var s, i; const o = { Fragment: t.Fragment, ancestors: [], components: t.components || {}, create: r, elementAttributeNameCase: t.elementAttributeNameCase || "react", evaluater: t.createEvaluater ? t.createEvaluater() : void 0, filePath: n, ignoreInvalidStyle: t.ignoreInvalidStyle || !1, passKeys: !1 !== t.passKeys, passNode: t.passNode || !1, schema: "svg" === t.space ? Mo : wo, stylePropertyNameCase: t.stylePropertyNameCase || "dom", tableCellAlignToStyle: !1 !== t.tableCellAlignToStyle }, a = ka(o, e, void 0); return a && "string" != typeof a ? a : o.create(e, o.Fragment, { children: a || void 0 }, void 0) }(e, { Fragment: T.Fragment, components: s, ignoreInvalidStyle: !0, jsx: T.jsx, jsxs: T.jsxs, passKeys: !0, passNode: !0 }) } function Qu(e) { const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), s = e.indexOf("/"); return -1 === t || -1 !== s && t > s || -1 !== n && t > n || -1 !== r && t > r || qu.test(e.slice(0, t)) ? e : "" } const Xu = Object.freeze(Object.defineProperty({ __proto__: null, MarkdownAsync: async function (e) { const t = $u(e), n = Wu(e); return Ku(await t.run(t.parse(n), n), e) }, MarkdownHooks: function (e) { const t = $u(e), [n, r] = React.useState(void 0), [s, i] = React.useState(void 0); if (React.useEffect(function () { const n = Wu(e); t.run(t.parse(n), n, function (e, t) { r(e), i(t) }) }, [e.children, e.rehypePlugins, e.remarkPlugins, e.remarkRehypeOptions]), n) throw n; return s ? Ku(s, e) : React.createElement(T.Fragment) }, default: function (e) { const t = $u(e), n = Wu(e); return Ku(t.runSync(t.parse(n), n), e) }, defaultUrlTransform: Qu }, Symbol.toStringTag, { value: "Module" })); function Ju(e, t) { const n = String(e); if ("string" != typeof t) throw new TypeError("Expected character"); let r = 0, s = n.indexOf(t); for (; -1 !== s;)r++, s = n.indexOf(t, s + t.length); return r } function Zu(e) { return "string" == typeof e ? new RegExp(function (e) { if ("string" != typeof e) throw new TypeError("Expected a string"); return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d") }(e), "g") : e } function eh(e) { return "function" == typeof e ? e : function () { return e } } const th = "phrasing", nh = ["autolink", "link", "image", "label"]; function rh(e) { this.enter({ type: "link", title: null, url: "", children: [] }, e) } function sh(e) { this.config.enter.autolinkProtocol.call(this, e) } function ih(e) { this.config.exit.autolinkProtocol.call(this, e) } function oh(e) { this.config.exit.data.call(this, e); const t = this.stack[this.stack.length - 1]; t.type, t.url = "http://" + this.sliceSerialize(e) } function ah(e) { this.config.exit.autolinkEmail.call(this, e) } function lh(e) { this.exit(e) } function ch(e) { !function (e, t, n) { const r = $c((n || {}).ignore || []), s = function (e) { const t = []; if (!Array.isArray(e)) throw new TypeError("Expected find and replace tuple or list of tuples"); const n = !e[0] || Array.isArray(e[0]) ? e : [e]; let r = -1; for (; ++r < n.length;) { const e = n[r]; t.push([Zu(e[0]), eh(e[1])]) } return t }(t); let i = -1; for (; ++i < s.length;)Jc(e, "text", o); function o(e, t) { let n, o = -1; for (; ++o < t.length;) { const e = t[o], s = n ? n.children : void 0; if (r(e, s ? s.indexOf(e) : void 0, n)) return; n = e } if (n) return function (e, t) { const n = t[t.length - 1], r = s[i][0], o = s[i][1]; let a = 0; const l = n.children.indexOf(e); let c = !1, u = []; r.lastIndex = 0; let h = r.exec(e.value); for (; h;) { const n = h.index, s = { index: h.index, input: h.input, stack: [...t, e] }; let i = o(...h, s); if ("string" == typeof i && (i = i.length > 0 ? { type: "text", value: i } : void 0), !1 === i ? r.lastIndex = n + 1 : (a !== n && u.push({ type: "text", value: e.value.slice(a, n) }), Array.isArray(i) ? u.push(...i) : i && u.push(i), a = n + h[0].length, c = !0), !r.global) break; h = r.exec(e.value) } return c ? (a < e.value.length && u.push({ type: "text", value: e.value.slice(a) }), n.children.splice(l, 1, ...u)) : u = [e], l + u.length }(e, t) } }(e, [[/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, uh], [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), hh]], { ignore: ["link", "linkReference"] }) } function uh(e, t, n, r, s) { let i = ""; if (!dh(s)) return !1; if (/^w/i.test(t) && (n = t + n, t = "", i = "http://"), !function (e) { const t = e.split("."); return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2]))) }(n)) return !1; const o = function (e) { const t = /[!"&'),.:;<>?\]}]+$/.exec(e); if (!t) return [e, void 0]; e = e.slice(0, t.index); let n = t[0], r = n.indexOf(")"); const s = Ju(e, "("); let i = Ju(e, ")"); for (; -1 !== r && s > i;)e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), i++; return [e, n] }(n + r); if (!o[0]) return !1; const a = { type: "link", title: null, url: i + t + o[0], children: [{ type: "text", value: t + o[0] }] }; return o[1] ? [a, { type: "text", value: o[1] }] : a } function hh(e, t, n, r) { return !(!dh(r, !0) || /[-\d_]$/.test(n)) && { type: "link", title: null, url: "mailto:" + t + "@" + n, children: [{ type: "text", value: t + "@" + n }] } } function dh(e, t) { const n = e.input.charCodeAt(e.index - 1); return (0 === e.index || il(n) || sl(n)) && (!t || 47 !== n) } function ph() { this.buffer() } function fh(e) { this.enter({ type: "footnoteReference", identifier: "", label: "" }, e) } function mh() { this.buffer() } function gh(e) { this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, e) } function Eh(e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.type, n.identifier = $a(this.sliceSerialize(e)).toLowerCase(), n.label = t } function Th(e) { this.exit(e) } function Ah(e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.type, n.identifier = $a(this.sliceSerialize(e)).toLowerCase(), n.label = t } function _h(e) { this.exit(e) } function yh(e, t, n, r) { const s = n.createTracker(r); let i = s.move("[^"); const o = n.enter("footnoteReference"), a = n.enter("reference"); return i += s.move(n.safe(n.associationId(e), { after: "]", before: i })), a(), o(), i += s.move("]"), i } function bh(e) { let t = !1; return e && e.firstLineBlank && (t = !0), { handlers: { footnoteDefinition: function (e, n, r, s) { const i = r.createTracker(s); let o = i.move("[^"); const a = r.enter("footnoteDefinition"), l = r.enter("label"); return o += i.move(r.safe(r.associationId(e), { before: o, after: "]" })), l(), o += i.move("]:"), e.children && e.children.length > 0 && (i.shift(4), o += i.move((t ? "\n" : " ") + r.indentLines(r.containerFlow(e, i.current()), t ? kh : Sh))), a(), o }, footnoteReference: yh }, unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }] } } function Sh(e, t, n) { return 0 === t ? e : kh(e, 0, n) } function kh(e, t, n) { return (n ? "" : "    ") + e } yh.peek = function () { return "[" }; const Ch = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"]; function Nh(e) { this.enter({ type: "delete", children: [] }, e) } function Ih(e) { this.exit(e) } function Oh(e, t, n, r) { const s = n.createTracker(r), i = n.enter("strikethrough"); let o = s.move("~~"); return o += n.containerPhrasing(e, { ...s.current(), before: o, after: "~" }), o += s.move("~~"), i(), o } function xh(e) { return e.length } function Rh(e) { return null == e ? "" : String(e) } function vh(e) { const t = "string" == typeof e ? e.codePointAt(0) : 0; return 67 === t || 99 === t ? 99 : 76 === t || 108 === t ? 108 : 82 === t || 114 === t ? 114 : 0 } Oh.peek = function () { return "~" }; const Dh = {}.hasOwnProperty; function Lh(e, t) { const n = t || {}; function r(t, ...n) { let s = r.invalid; const i = r.handlers; if (t && Dh.call(t, e)) { const n = String(t[e]); s = Dh.call(i, n) ? i[n] : r.unknown } if (s) return s.call(this, t, ...n) } return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r } function Ph(e, t, n) { return ">" + (n ? "" : " ") + e } function wh(e, t) { return Mh(e, t.inConstruct, !0) && !Mh(e, t.notInConstruct, !1) } function Mh(e, t, n) { if ("string" == typeof t && (t = [t]), !t || 0 === t.length) return n; let r = -1; for (; ++r < t.length;)if (e.includes(t[r])) return !0; return !1 } function Fh(e, t, n, r) { let s = -1; for (; ++s < n.unsafe.length;)if ("\n" === n.unsafe[s].character && wh(n.stack, n.unsafe[s])) return /[ \t]/.test(r.before) ? "" : " "; return "\\\n" } function Bh(e, t, n) { return (n ? "" : "    ") + e } function Uh(e) { const t = e.options.quote || '"'; if ('"' !== t && "'" !== t) throw new Error("Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"); return t } function Hh(e) { return "&#x" + e.toString(16).toUpperCase() + ";" } function jh(e, t, n) { const r = dl(e), s = dl(t); return void 0 === r ? void 0 === s ? "_" === n ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 } : 1 === s ? { inside: !0, outside: !0 } : { inside: !1, outside: !0 } : 1 === r ? void 0 === s ? { inside: !1, outside: !1 } : 1 === s ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 } : void 0 === s ? { inside: !1, outside: !1 } : 1 === s ? { inside: !0, outside: !1 } : { inside: !1, outside: !1 } } function Gh(e, t, n, r) { const s = function (e) { const t = e.options.emphasis || "*"; if ("*" !== t && "_" !== t) throw new Error("Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"); return t }(n), i = n.enter("emphasis"), o = n.createTracker(r), a = o.move(s); let l = o.move(n.containerPhrasing(e, { after: s, before: a, ...o.current() })); const c = l.charCodeAt(0), u = jh(r.before.charCodeAt(r.before.length - 1), c, s); u.inside && (l = Hh(c) + l.slice(1)); const h = l.charCodeAt(l.length - 1), d = jh(r.after.charCodeAt(0), h, s); d.inside && (l = l.slice(0, -1) + Hh(h)); const p = o.move(s); return i(), n.attentionEncodeSurroundingInfo = { after: d.outside, before: u.outside }, a + l + p } function zh(e) { return e.value || "" } function Yh(e, t, n, r) { const s = Uh(n), i = '"' === s ? "Quote" : "Apostrophe", o = n.enter("image"); let a = n.enter("label"); const l = n.createTracker(r); let c = l.move("!["); return c += l.move(n.safe(e.alt, { before: c, after: "]", ...l.current() })), c += l.move("]("), a(), !e.url && e.title || /[\0- \u007F]/.test(e.url) ? (a = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(n.safe(e.url, { before: c, after: ">", ...l.current() })), c += l.move(">")) : (a = n.enter("destinationRaw"), c += l.move(n.safe(e.url, { before: c, after: e.title ? " " : ")", ...l.current() }))), a(), e.title && (a = n.enter(`title${i}`), c += l.move(" " + s), c += l.move(n.safe(e.title, { before: c, after: s, ...l.current() })), c += l.move(s), a()), c += l.move(")"), o(), c } function qh(e, t, n, r) { const s = e.referenceType, i = n.enter("imageReference"); let o = n.enter("label"); const a = n.createTracker(r); let l = a.move("!["); const c = n.safe(e.alt, { before: l, after: "]", ...a.current() }); l += a.move(c + "]["), o(); const u = n.stack; n.stack = [], o = n.enter("reference"); const h = n.safe(n.associationId(e), { before: l, after: "]", ...a.current() }); return o(), n.stack = u, i(), "full" !== s && c && c === h ? "shortcut" === s ? l = l.slice(0, -1) : l += a.move("]") : l += a.move(h + "]"), l } function Vh(e, t, n) { let r = e.value || "", s = "`", i = -1; for (; new RegExp("(^|[^`])" + s + "([^`]|$)").test(r);)s += "`"; for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++i < n.unsafe.length;) { const e = n.unsafe[i], t = n.compilePattern(e); let s; if (e.atBreak) for (; s = t.exec(r);) { let e = s.index; 10 === r.charCodeAt(e) && 13 === r.charCodeAt(e - 1) && e--, r = r.slice(0, e) + " " + r.slice(s.index + 1) } } return s + r + s } function $h(e, t) { const n = wa(e); return Boolean(!t.options.resourceLink && e.url && !e.title && e.children && 1 === e.children.length && "text" === e.children[0].type && (n === e.url || "mailto:" + n === e.url) && /^[a-z][a-z+.-]+:/i.test(e.url) && !/[\0- <>\u007F]/.test(e.url)) } function Wh(e, t, n, r) { const s = Uh(n), i = '"' === s ? "Quote" : "Apostrophe", o = n.createTracker(r); let a, l; if ($h(e, n)) { const t = n.stack; n.stack = [], a = n.enter("autolink"); let r = o.move("<"); return r += o.move(n.containerPhrasing(e, { before: r, after: ">", ...o.current() })), r += o.move(">"), a(), n.stack = t, r } a = n.enter("link"), l = n.enter("label"); let c = o.move("["); return c += o.move(n.containerPhrasing(e, { before: c, after: "](", ...o.current() })), c += o.move("]("), l(), !e.url && e.title || /[\0- \u007F]/.test(e.url) ? (l = n.enter("destinationLiteral"), c += o.move("<"), c += o.move(n.safe(e.url, { before: c, after: ">", ...o.current() })), c += o.move(">")) : (l = n.enter("destinationRaw"), c += o.move(n.safe(e.url, { before: c, after: e.title ? " " : ")", ...o.current() }))), l(), e.title && (l = n.enter(`title${i}`), c += o.move(" " + s), c += o.move(n.safe(e.title, { before: c, after: s, ...o.current() })), c += o.move(s), l()), c += o.move(")"), a(), c } function Kh(e, t, n, r) { const s = e.referenceType, i = n.enter("linkReference"); let o = n.enter("label"); const a = n.createTracker(r); let l = a.move("["); const c = n.containerPhrasing(e, { before: l, after: "]", ...a.current() }); l += a.move(c + "]["), o(); const u = n.stack; n.stack = [], o = n.enter("reference"); const h = n.safe(n.associationId(e), { before: l, after: "]", ...a.current() }); return o(), n.stack = u, i(), "full" !== s && c && c === h ? "shortcut" === s ? l = l.slice(0, -1) : l += a.move("]") : l += a.move(h + "]"), l } function Qh(e) { const t = e.options.bullet || "*"; if ("*" !== t && "+" !== t && "-" !== t) throw new Error("Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"); return t } function Xh(e) { const t = e.options.rule || "*"; if ("*" !== t && "-" !== t && "_" !== t) throw new Error("Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"); return t } Gh.peek = function (e, t, n) { return n.options.emphasis || "*" }, zh.peek = function () { return "<" }, Yh.peek = function () { return "!" }, qh.peek = function () { return "!" }, Vh.peek = function () { return "`" }, Wh.peek = function (e, t, n) { return $h(e, n) ? "<" : "[" }, Kh.peek = function () { return "[" }; const Jh = $c(["break", "delete", "emphasis", "footnote", "footnoteReference", "image", "imageReference", "inlineCode", "inlineMath", "link", "linkReference", "mdxJsxTextElement", "mdxTextExpression", "strong", "text", "textDirective"]); function Zh(e, t, n, r) { const s = function (e) { const t = e.options.strong || "*"; if ("*" !== t && "_" !== t) throw new Error("Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"); return t }(n), i = n.enter("strong"), o = n.createTracker(r), a = o.move(s + s); let l = o.move(n.containerPhrasing(e, { after: s, before: a, ...o.current() })); const c = l.charCodeAt(0), u = jh(r.before.charCodeAt(r.before.length - 1), c, s); u.inside && (l = Hh(c) + l.slice(1)); const h = l.charCodeAt(l.length - 1), d = jh(r.after.charCodeAt(0), h, s); d.inside && (l = l.slice(0, -1) + Hh(h)); const p = o.move(s + s); return i(), n.attentionEncodeSurroundingInfo = { after: d.outside, before: u.outside }, a + l + p } Zh.peek = function (e, t, n) { return n.options.strong || "*" }; const ed = { blockquote: function (e, t, n, r) { const s = n.enter("blockquote"), i = n.createTracker(r); i.move("> "), i.shift(2); const o = n.indentLines(n.containerFlow(e, i.current()), Ph); return s(), o }, break: Fh, code: function (e, t, n, r) { const s = function (e) { const t = e.options.fence || "`"; if ("`" !== t && "~" !== t) throw new Error("Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"); return t }(n), i = e.value || "", o = "`" === s ? "GraveAccent" : "Tilde"; if (function (e, t) { return Boolean(!1 === t.options.fences && e.value && !e.lang && /[^ \r\n]/.test(e.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value)) }(e, n)) { const e = n.enter("codeIndented"), t = n.indentLines(i, Bh); return e(), t } const a = n.createTracker(r), l = s.repeat(Math.max(function (e, t) { const n = String(e); let r = n.indexOf(t), s = r, i = 0, o = 0; if ("string" != typeof t) throw new TypeError("Expected substring"); for (; -1 !== r;)r === s ? ++i > o && (o = i) : i = 1, s = r + t.length, r = n.indexOf(t, s); return o }(i, s) + 1, 3)), c = n.enter("codeFenced"); let u = a.move(l); if (e.lang) { const t = n.enter(`codeFencedLang${o}`); u += a.move(n.safe(e.lang, { before: u, after: " ", encode: ["`"], ...a.current() })), t() } if (e.lang && e.meta) { const t = n.enter(`codeFencedMeta${o}`); u += a.move(" "), u += a.move(n.safe(e.meta, { before: u, after: "\n", encode: ["`"], ...a.current() })), t() } return u += a.move("\n"), i && (u += a.move(i + "\n")), u += a.move(l), c(), u }, definition: function (e, t, n, r) { const s = Uh(n), i = '"' === s ? "Quote" : "Apostrophe", o = n.enter("definition"); let a = n.enter("label"); const l = n.createTracker(r); let c = l.move("["); return c += l.move(n.safe(n.associationId(e), { before: c, after: "]", ...l.current() })), c += l.move("]: "), a(), !e.url || /[\0- \u007F]/.test(e.url) ? (a = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(n.safe(e.url, { before: c, after: ">", ...l.current() })), c += l.move(">")) : (a = n.enter("destinationRaw"), c += l.move(n.safe(e.url, { before: c, after: e.title ? " " : "\n", ...l.current() }))), a(), e.title && (a = n.enter(`title${i}`), c += l.move(" " + s), c += l.move(n.safe(e.title, { before: c, after: s, ...l.current() })), c += l.move(s), a()), o(), c }, emphasis: Gh, hardBreak: Fh, heading: function (e, t, n, r) { const s = Math.max(Math.min(6, e.depth || 1), 1), i = n.createTracker(r); if (function (e, t) { let n = !1; return Zc(e, function (e) { if ("value" in e && /\r?\n|\r/.test(e.value) || "break" === e.type) return n = !0, Xc }), Boolean((!e.depth || e.depth < 3) && wa(e) && (t.options.setext || n)) }(e, n)) { const t = n.enter("headingSetext"), r = n.enter("phrasing"), o = n.containerPhrasing(e, { ...i.current(), before: "\n", after: "\n" }); return r(), t(), o + "\n" + (1 === s ? "=" : "-").repeat(o.length - (Math.max(o.lastIndexOf("\r"), o.lastIndexOf("\n")) + 1)) } const o = "#".repeat(s), a = n.enter("headingAtx"), l = n.enter("phrasing"); i.move(o + " "); let c = n.containerPhrasing(e, { before: "# ", after: "\n", ...i.current() }); return /^[\t ]/.test(c) && (c = Hh(c.charCodeAt(0)) + c.slice(1)), c = c ? o + " " + c : o, n.options.closeAtx && (c += " " + o), l(), a(), c }, html: zh, image: Yh, imageReference: qh, inlineCode: Vh, link: Wh, linkReference: Kh, list: function (e, t, n, r) { const s = n.enter("list"), i = n.bulletCurrent; let o = e.ordered ? function (e) { const t = e.options.bulletOrdered || "."; if ("." !== t && ")" !== t) throw new Error("Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"); return t }(n) : Qh(n); const a = e.ordered ? "." === o ? ")" : "." : function (e) { const t = Qh(e), n = e.options.bulletOther; if (!n) return "*" === t ? "-" : "*"; if ("*" !== n && "+" !== n && "-" !== n) throw new Error("Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"); if (n === t) throw new Error("Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"); return n }(n); let l = !(!t || !n.bulletLastUsed) && o === n.bulletLastUsed; if (!e.ordered) { const t = e.children ? e.children[0] : void 0; if ("*" !== o && "-" !== o || !t || t.children && t.children[0] || "list" !== n.stack[n.stack.length - 1] || "listItem" !== n.stack[n.stack.length - 2] || "list" !== n.stack[n.stack.length - 3] || "listItem" !== n.stack[n.stack.length - 4] || 0 !== n.indexStack[n.indexStack.length - 1] || 0 !== n.indexStack[n.indexStack.length - 2] || 0 !== n.indexStack[n.indexStack.length - 3] || (l = !0), Xh(n) === o && t) { let t = -1; for (; ++t < e.children.length;) { const n = e.children[t]; if (n && "listItem" === n.type && n.children && n.children[0] && "thematicBreak" === n.children[0].type) { l = !0; break } } } } l && (o = a), n.bulletCurrent = o; const c = n.containerFlow(e, r); return n.bulletLastUsed = o, n.bulletCurrent = i, s(), c }, listItem: function (e, t, n, r) { const s = function (e) { const t = e.options.listItemIndent || "one"; if ("tab" !== t && "one" !== t && "mixed" !== t) throw new Error("Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"); return t }(n); let i = n.bulletCurrent || Qh(n); t && "list" === t.type && t.ordered && (i = ("number" == typeof t.start && t.start > -1 ? t.start : 1) + (!1 === n.options.incrementListMarker ? 0 : t.children.indexOf(e)) + i); let o = i.length + 1; ("tab" === s || "mixed" === s && (t && "list" === t.type && t.spread || e.spread)) && (o = 4 * Math.ceil(o / 4)); const a = n.createTracker(r); a.move(i + " ".repeat(o - i.length)), a.shift(o); const l = n.enter("listItem"), c = n.indentLines(n.containerFlow(e, a.current()), function (e, t, n) { return t ? (n ? "" : " ".repeat(o)) + e : (n ? i : i + " ".repeat(o - i.length)) + e }); return l(), c }, paragraph: function (e, t, n, r) { const s = n.enter("paragraph"), i = n.enter("phrasing"), o = n.containerPhrasing(e, r); return i(), s(), o }, root: function (e, t, n, r) { return (e.children.some(function (e) { return Jh(e) }) ? n.containerPhrasing : n.containerFlow).call(n, e, r) }, strong: Zh, text: function (e, t, n, r) { return n.safe(e.value, r) }, thematicBreak: function (e, t, n) { const r = (Xh(n) + (n.options.ruleSpaces ? " " : "")).repeat(function (e) { const t = e.options.ruleRepetition || 3; if (t < 3) throw new Error("Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"); return t }(n)); return n.options.ruleSpaces ? r.slice(0, -1) : r } }; function td(e) { const t = e._align; this.enter({ type: "table", align: t.map(function (e) { return "none" === e ? null : e }), children: [] }, e), this.data.inTable = !0 } function nd(e) { this.exit(e), this.data.inTable = void 0 } function rd(e) { this.enter({ type: "tableRow", children: [] }, e) } function sd(e) { this.exit(e) } function id(e) { this.enter({ type: "tableCell", children: [] }, e) } function od(e) { let t = this.resume(); this.data.inTable && (t = t.replace(/\\([\\|])/g, ad)); const n = this.stack[this.stack.length - 1]; n.type, n.value = t, this.exit(e) } function ad(e, t) { return "|" === t ? t : e } function ld(e) { const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, s = t.stringLength, i = n ? " " : "|"; return { unsafe: [{ character: "\r", inConstruct: "tableCell" }, { character: "\n", inConstruct: "tableCell" }, { atBreak: !0, character: "|", after: "[\t :-]" }, { character: "|", inConstruct: "tableCell" }, { atBreak: !0, character: ":", after: "-" }, { atBreak: !0, character: "-", after: "[:|-]" }], handlers: { inlineCode: function (e, t, n) { let r = ed.inlineCode(e, t, n); return n.stack.includes("tableCell") && (r = r.replace(/\|/g, "\\$&")), r }, table: function (e, t, n, r) { return a(function (e, t, n) { const r = e.children; let s = -1; const i = [], o = t.enter("table"); for (; ++s < r.length;)i[s] = l(r[s], t, n); return o(), i }(e, n, r), e.align) }, tableCell: o, tableRow: function (e, t, n, r) { const s = a([l(e, n, r)]); return s.slice(0, s.indexOf("\n")) } } }; function o(e, t, n, r) { const s = n.enter("tableCell"), o = n.enter("phrasing"), a = n.containerPhrasing(e, { ...r, before: i, after: i }); return o(), s(), a } function a(e, t) { return function (e, t) { const n = t || {}, r = (n.align || []).concat(), s = n.stringLength || xh, i = [], o = [], a = [], l = []; let c = 0, u = -1; for (; ++u < e.length;) { const t = [], r = []; let i = -1; for (e[u].length > c && (c = e[u].length); ++i < e[u].length;) { const o = Rh(e[u][i]); if (!1 !== n.alignDelimiters) { const e = s(o); r[i] = e, (void 0 === l[i] || e > l[i]) && (l[i] = e) } t.push(o) } o[u] = t, a[u] = r } let h = -1; if ("object" == typeof r && "length" in r) for (; ++h < c;)i[h] = vh(r[h]); else { const e = vh(r); for (; ++h < c;)i[h] = e } h = -1; const d = [], p = []; for (; ++h < c;) { const e = i[h]; let t = "", r = ""; 99 === e ? (t = ":", r = ":") : 108 === e ? t = ":" : 114 === e && (r = ":"); let s = !1 === n.alignDelimiters ? 1 : Math.max(1, l[h] - t.length - r.length); const o = t + "-".repeat(s) + r; !1 !== n.alignDelimiters && (s = t.length + s + r.length, s > l[h] && (l[h] = s), p[h] = s), d[h] = o } o.splice(1, 0, d), a.splice(1, 0, p), u = -1; const f = []; for (; ++u < o.length;) { const e = o[u], t = a[u]; h = -1; const r = []; for (; ++h < c;) { const s = e[h] || ""; let o = "", a = ""; if (!1 !== n.alignDelimiters) { const e = l[h] - (t[h] || 0), n = i[h]; 114 === n ? o = " ".repeat(e) : 99 === n ? e % 2 ? (o = " ".repeat(e / 2 + .5), a = " ".repeat(e / 2 - .5)) : (o = " ".repeat(e / 2), a = o) : a = " ".repeat(e) } !1 === n.delimiterStart || h || r.push("|"), !1 === n.padding || !1 === n.alignDelimiters && "" === s || !1 === n.delimiterStart && !h || r.push(" "), !1 !== n.alignDelimiters && r.push(o), r.push(s), !1 !== n.alignDelimiters && r.push(a), !1 !== n.padding && r.push(" "), !1 === n.delimiterEnd && h === c - 1 || r.push("|") } f.push(!1 === n.delimiterEnd ? r.join("").replace(/ +$/, "") : r.join("")) } return f.join("\n") }(e, { align: t, alignDelimiters: r, padding: n, stringLength: s }) } function l(e, t, n) { const r = e.children; let s = -1; const i = [], a = t.enter("tableRow"); for (; ++s < r.length;)i[s] = o(r[s], 0, t, n); return a(), i } } function cd(e) { const t = this.stack[this.stack.length - 2]; t.type, t.checked = "taskListCheckValueChecked" === e.type } function ud(e) { const t = this.stack[this.stack.length - 2]; if (t && "listItem" === t.type && "boolean" == typeof t.checked) { const e = this.stack[this.stack.length - 1]; e.type; const n = e.children[0]; if (n && "text" === n.type) { const r = t.children; let s, i = -1; for (; ++i < r.length;) { const e = r[i]; if ("paragraph" === e.type) { s = e; break } } s === e && (n.value = n.value.slice(1), 0 === n.value.length ? e.children.shift() : e.position && n.position && "number" == typeof n.position.start.offset && (n.position.start.column++, n.position.start.offset++, e.position.start = Object.assign({}, n.position.start))) } } this.exit(e) } function hd(e, t, n, r) { const s = e.children[0], i = "boolean" == typeof e.checked && s && "paragraph" === s.type, o = "[" + (e.checked ? "x" : " ") + "] ", a = n.createTracker(r); i && a.move(o); let l = ed.listItem(e, t, n, { ...r, ...a.current() }); return i && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, function (e) { return e + o })), l } const dd = { tokenize: function (e, t, n) { let r = 0; return function t(i) { return (87 === i || 119 === i) && r < 3 ? (r++, e.consume(i), t) : 46 === i && 3 === r ? (e.consume(i), s) : n(i) }; function s(e) { return null === e ? n(e) : t(e) } }, partial: !0 }, pd = { tokenize: function (e, t, n) { let r, s, i; return o; function o(t) { return 46 === t || 95 === t ? e.check(md, l, a)(t) : null === t || nl(t) || il(t) || 45 !== t && sl(t) ? l(t) : (i = !0, e.consume(t), o) } function a(t) { return 95 === t ? r = !0 : (s = r, r = void 0), e.consume(t), o } function l(e) { return s || r || !i ? n(e) : t(e) } }, partial: !0 }, fd = { tokenize: function (e, t) { let n = 0, r = 0; return s; function s(o) { return 40 === o ? (n++, e.consume(o), s) : 41 === o && r < n ? i(o) : 33 === o || 34 === o || 38 === o || 39 === o || 41 === o || 42 === o || 44 === o || 46 === o || 58 === o || 59 === o || 60 === o || 63 === o || 93 === o || 95 === o || 126 === o ? e.check(md, t, i)(o) : null === o || nl(o) || il(o) ? t(o) : (e.consume(o), s) } function i(t) { return 41 === t && r++, e.consume(t), s } }, partial: !0 }, md = { tokenize: function (e, t, n) { return r; function r(o) { return 33 === o || 34 === o || 39 === o || 41 === o || 42 === o || 44 === o || 46 === o || 58 === o || 59 === o || 63 === o || 95 === o || 126 === o ? (e.consume(o), r) : 38 === o ? (e.consume(o), i) : 93 === o ? (e.consume(o), s) : 60 === o || null === o || nl(o) || il(o) ? t(o) : n(o) } function s(e) { return null === e || 40 === e || 91 === e || nl(e) || il(e) ? t(e) : r(e) } function i(e) { return Wa(e) ? o(e) : n(e) } function o(t) { return 59 === t ? (e.consume(t), r) : Wa(t) ? (e.consume(t), o) : n(t) } }, partial: !0 }, gd = { tokenize: function (e, t, n) { return function (t) { return e.consume(t), r }; function r(e) { return Ka(e) ? n(e) : t(e) } }, partial: !0 }, Ed = { name: "wwwAutolink", tokenize: function (e, t, n) { const r = this; return function (t) { return 87 !== t && 119 !== t || !bd.call(r, r.previous) || Nd(r.events) ? n(t) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(dd, e.attempt(pd, e.attempt(fd, s), n), n)(t)) }; function s(n) { return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(n) } }, previous: bd }, Td = { name: "protocolAutolink", tokenize: function (e, t, n) { const r = this; let s = "", i = !1; return function (t) { return 72 !== t && 104 !== t || !Sd.call(r, r.previous) || Nd(r.events) ? n(t) : (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), s += String.fromCodePoint(t), e.consume(t), o) }; function o(t) { if (Wa(t) && s.length < 5) return s += String.fromCodePoint(t), e.consume(t), o; if (58 === t) { const n = s.toLowerCase(); if ("http" === n || "https" === n) return e.consume(t), a } return n(t) } function a(t) { return 47 === t ? (e.consume(t), i ? l : (i = !0, a)) : n(t) } function l(t) { return null === t || Xa(t) || nl(t) || il(t) || sl(t) ? n(t) : e.attempt(pd, e.attempt(fd, c), n)(t) } function c(n) { return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(n) } }, previous: Sd }, Ad = { name: "emailAutolink", tokenize: function (e, t, n) { const r = this; let s, i; return function (t) { return Cd(t) && kd.call(r, r.previous) && !Nd(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), o(t)) : n(t) }; function o(t) { return Cd(t) ? (e.consume(t), o) : 64 === t ? (e.consume(t), a) : n(t) } function a(t) { return 46 === t ? e.check(gd, c, l)(t) : 45 === t || 95 === t || Ka(t) ? (i = !0, e.consume(t), a) : c(t) } function l(t) { return e.consume(t), s = !0, a } function c(o) { return i && s && Wa(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(o)) : n(o) } }, previous: kd }, _d = {}; let yd = 48; for (; yd < 123;)_d[yd] = Ad, yd++, 58 === yd ? yd = 65 : 91 === yd && (yd = 97); function bd(e) { return null === e || 40 === e || 42 === e || 95 === e || 91 === e || 93 === e || 126 === e || nl(e) } function Sd(e) { return !Wa(e) } function kd(e) { return !(47 === e || Cd(e)) } function Cd(e) { return 43 === e || 45 === e || 46 === e || 95 === e || Ka(e) } function Nd(e) { let t = e.length, n = !1; for (; t--;) { const r = e[t][1]; if (("labelLink" === r.type || "labelImage" === r.type) && !r._balanced) { n = !0; break } if (r._gfmAutolinkLiteralWalkedInto) { n = !1; break } } return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n } _d[43] = Ad, _d[45] = Ad, _d[46] = Ad, _d[95] = Ad, _d[72] = [Ad, Td], _d[104] = [Ad, Td], _d[87] = [Ad, Ed], _d[119] = [Ad, Ed]; const Id = { tokenize: function (e, t, n) { const r = this; return ll(e, function (e) { const s = r.events[r.events.length - 1]; return s && "gfmFootnoteDefinitionIndent" === s[1].type && 4 === s[2].sliceSerialize(s[1], !0).length ? t(e) : n(e) }, "gfmFootnoteDefinitionIndent", 5) }, partial: !0 }; function Od(e, t, n) { const r = this; let s = r.events.length; const i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []); let o; for (; s--;) { const e = r.events[s][1]; if ("labelImage" === e.type) { o = e; break } if ("gfmFootnoteCall" === e.type || "labelLink" === e.type || "label" === e.type || "image" === e.type || "link" === e.type) break } return function (s) { if (!o || !o._balanced) return n(s); const a = $a(r.sliceSerialize({ start: o.end, end: r.now() })); return 94 === a.codePointAt(0) && i.includes(a.slice(1)) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(s), e.exit("gfmFootnoteCallLabelMarker"), t(s)) : n(s) } } function xd(e, t) { let n = e.length; for (; n--;)if ("labelImage" === e[n][1].type && "enter" === e[n][0]) { e[n][1]; break } e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker"; const r = { type: "gfmFootnoteCall", start: Object.assign({}, e[n + 3][1].start), end: Object.assign({}, e[e.length - 1][1].end) }, s = { type: "gfmFootnoteCallMarker", start: Object.assign({}, e[n + 3][1].end), end: Object.assign({}, e[n + 3][1].end) }; s.end.column++, s.end.offset++, s.end._bufferIndex++; const i = { type: "gfmFootnoteCallString", start: Object.assign({}, s.end), end: Object.assign({}, e[e.length - 1][1].start) }, o = { type: "chunkString", contentType: "string", start: Object.assign({}, i.start), end: Object.assign({}, i.end) }, a = [e[n + 1], e[n + 2], ["enter", r, t], e[n + 3], e[n + 4], ["enter", s, t], ["exit", s, t], ["enter", i, t], ["enter", o, t], ["exit", o, t], ["exit", i, t], e[e.length - 2], e[e.length - 1], ["exit", r, t]]; return e.splice(n, e.length - n + 1, ...a), e } function Rd(e, t, n) { const r = this, s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []); let i, o = 0; return function (t) { return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(t), e.exit("gfmFootnoteCallLabelMarker"), a }; function a(t) { return 94 !== t ? n(t) : (e.enter("gfmFootnoteCallMarker"), e.consume(t), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", l) } function l(a) { if (o > 999 || 93 === a && !i || null === a || 91 === a || nl(a)) return n(a); if (93 === a) { e.exit("chunkString"); const i = e.exit("gfmFootnoteCallString"); return s.includes($a(r.sliceSerialize(i))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(a), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(a) } return nl(a) || (i = !0), o++, e.consume(a), 92 === a ? c : l } function c(t) { return 91 === t || 92 === t || 93 === t ? (e.consume(t), o++, l) : l(t) } } function vd(e, t, n) { const r = this, s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []); let i, o, a = 0; return function (t) { return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(t), e.exit("gfmFootnoteDefinitionLabelMarker"), l }; function l(t) { return 94 === t ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(t), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", c) : n(t) } function c(t) { if (a > 999 || 93 === t && !o || null === t || 91 === t || nl(t)) return n(t); if (93 === t) { e.exit("chunkString"); const n = e.exit("gfmFootnoteDefinitionLabelString"); return i = $a(r.sliceSerialize(n)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(t), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), h } return nl(t) || (o = !0), a++, e.consume(t), 92 === t ? u : c } function u(t) { return 91 === t || 92 === t || 93 === t ? (e.consume(t), a++, c) : c(t) } function h(t) { return 58 === t ? (e.enter("definitionMarker"), e.consume(t), e.exit("definitionMarker"), s.includes(i) || s.push(i), ll(e, d, "gfmFootnoteDefinitionWhitespace")) : n(t) } function d(e) { return t(e) } } function Dd(e, t, n) { return e.check(El, t, e.attempt(Id, t, n)) } function Ld(e) { e.exit("gfmFootnoteDefinition") } function Pd(e) { let t = (e || {}).singleTilde; const n = { name: "strikethrough", tokenize: function (e, n, r) { const s = this.previous, i = this.events; let o = 0; return function (t) { return 126 === s && "characterEscape" !== i[i.length - 1][1].type ? r(t) : (e.enter("strikethroughSequenceTemporary"), a(t)) }; function a(i) { const l = dl(s); if (126 === i) return o > 1 ? r(i) : (e.consume(i), o++, a); if (o < 2 && !t) return r(i); const c = e.exit("strikethroughSequenceTemporary"), u = dl(i); return c._open = !u || 2 === u && Boolean(l), c._close = !l || 2 === l && Boolean(u), n(i) } }, resolveAll: function (e, t) { let n = -1; for (; ++n < e.length;)if ("enter" === e[n][0] && "strikethroughSequenceTemporary" === e[n][1].type && e[n][1]._close) { let r = n; for (; r--;)if ("exit" === e[r][0] && "strikethroughSequenceTemporary" === e[r][1].type && e[r][1]._open && e[n][1].end.offset - e[n][1].start.offset === e[r][1].end.offset - e[r][1].start.offset) { e[n][1].type = "strikethroughSequence", e[r][1].type = "strikethroughSequence"; const s = { type: "strikethrough", start: Object.assign({}, e[r][1].start), end: Object.assign({}, e[n][1].end) }, i = { type: "strikethroughText", start: Object.assign({}, e[r][1].end), end: Object.assign({}, e[n][1].start) }, o = [["enter", s, t], ["enter", e[r][1], t], ["exit", e[r][1], t], ["enter", i, t]], a = t.parser.constructs.insideSpan.null; a && Ha(o, o.length, 0, pl(a, e.slice(r + 1, n), t)), Ha(o, o.length, 0, [["exit", i, t], ["enter", e[n][1], t], ["exit", e[n][1], t], ["exit", s, t]]), Ha(e, r - 1, n - r + 3, o), n = r + o.length - 2; break } } for (n = -1; ++n < e.length;)"strikethroughSequenceTemporary" === e[n][1].type && (e[n][1].type = "data"); return e } }; return null == t && (t = !0), { text: { 126: n }, insideSpan: { null: [n] }, attentionMarkers: { null: [126] } } } class wd { constructor() { this.map = [] } add(e, t, n) { !function (e, t, n, r) { let s = 0; if (0 !== n || 0 !== r.length) { for (; s < e.map.length;) { if (e.map[s][0] === t) return e.map[s][1] += n, void e.map[s][2].push(...r); s += 1 } e.map.push([t, n, r]) } }(this, e, t, n) } consume(e) { if (this.map.sort(function (e, t) { return e[0] - t[0] }), 0 === this.map.length) return; let t = this.map.length; const n = []; for (; t > 0;)t -= 1, n.push(e.slice(this.map[t][0] + this.map[t][1]), this.map[t][2]), e.length = this.map[t][0]; n.push(e.slice()), e.length = 0; let r = n.pop(); for (; r;) { for (const t of r) e.push(t); r = n.pop() } this.map.length = 0 } } function Md(e, t) { let n = !1; const r = []; for (; t < e.length;) { const s = e[t]; if (n) { if ("enter" === s[0]) "tableContent" === s[1].type && r.push("tableDelimiterMarker" === e[t + 1][1].type ? "left" : "none"); else if ("tableContent" === s[1].type) { if ("tableDelimiterMarker" === e[t - 1][1].type) { const e = r.length - 1; r[e] = "left" === r[e] ? "center" : "right" } } else if ("tableDelimiterRow" === s[1].type) break } else "enter" === s[0] && "tableDelimiterRow" === s[1].type && (n = !0); t += 1 } return r } function Fd(e, t, n) { const r = this; let s, i = 0, o = 0; return function (e) { let t = r.events.length - 1; for (; t > -1;) { const e = r.events[t][1].type; if ("lineEnding" !== e && "linePrefix" !== e) break; t-- } const s = t > -1 ? r.events[t][1].type : null, i = "tableHead" === s || "tableRow" === s ? _ : a; return i === _ && r.parser.lazy[r.now().line] ? n(e) : i(e) }; function a(t) { return e.enter("tableHead"), e.enter("tableRow"), function (e) { return 124 === e || (s = !0, o += 1), l(e) }(t) } function l(t) { return null === t ? n(t) : tl(t) ? o > 1 ? (o = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), h) : n(t) : rl(t) ? ll(e, l, "whitespace")(t) : (o += 1, s && (s = !1, i += 1), 124 === t ? (e.enter("tableCellDivider"), e.consume(t), e.exit("tableCellDivider"), s = !0, l) : (e.enter("data"), c(t))) } function c(t) { return null === t || 124 === t || nl(t) ? (e.exit("data"), l(t)) : (e.consume(t), 92 === t ? u : c) } function u(t) { return 92 === t || 124 === t ? (e.consume(t), c) : c(t) } function h(t) { return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(t) : (e.enter("tableDelimiterRow"), s = !1, rl(t) ? ll(e, d, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t) : d(t)) } function d(t) { return 45 === t || 58 === t ? f(t) : 124 === t ? (s = !0, e.enter("tableCellDivider"), e.consume(t), e.exit("tableCellDivider"), p) : A(t) } function p(t) { return rl(t) ? ll(e, f, "whitespace")(t) : f(t) } function f(t) { return 58 === t ? (o += 1, s = !0, e.enter("tableDelimiterMarker"), e.consume(t), e.exit("tableDelimiterMarker"), m) : 45 === t ? (o += 1, m(t)) : null === t || tl(t) ? T(t) : A(t) } function m(t) { return 45 === t ? (e.enter("tableDelimiterFiller"), g(t)) : A(t) } function g(t) { return 45 === t ? (e.consume(t), g) : 58 === t ? (s = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(t), e.exit("tableDelimiterMarker"), E) : (e.exit("tableDelimiterFiller"), E(t)) } function E(t) { return rl(t) ? ll(e, T, "whitespace")(t) : T(t) } function T(n) { return 124 === n ? d(n) : (null === n || tl(n)) && s && i === o ? (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(n)) : A(n) } function A(e) { return n(e) } function _(t) { return e.enter("tableRow"), y(t) } function y(n) { return 124 === n ? (e.enter("tableCellDivider"), e.consume(n), e.exit("tableCellDivider"), y) : null === n || tl(n) ? (e.exit("tableRow"), t(n)) : rl(n) ? ll(e, y, "whitespace")(n) : (e.enter("data"), b(n)) } function b(t) { return null === t || 124 === t || nl(t) ? (e.exit("data"), y(t)) : (e.consume(t), 92 === t ? S : b) } function S(t) { return 92 === t || 124 === t ? (e.consume(t), b) : b(t) } } function Bd(e, t) { let n, r, s, i = -1, o = !0, a = 0, l = [0, 0, 0, 0], c = [0, 0, 0, 0], u = !1, h = 0; const d = new wd; for (; ++i < e.length;) { const p = e[i], f = p[1]; "enter" === p[0] ? "tableHead" === f.type ? (u = !1, 0 !== h && (Hd(d, t, h, n, r), r = void 0, h = 0), n = { type: "table", start: Object.assign({}, f.start), end: Object.assign({}, f.end) }, d.add(i, 0, [["enter", n, t]])) : "tableRow" === f.type || "tableDelimiterRow" === f.type ? (o = !0, s = void 0, l = [0, 0, 0, 0], c = [0, i + 1, 0, 0], u && (u = !1, r = { type: "tableBody", start: Object.assign({}, f.start), end: Object.assign({}, f.end) }, d.add(i, 0, [["enter", r, t]])), a = "tableDelimiterRow" === f.type ? 2 : r ? 3 : 1) : !a || "data" !== f.type && "tableDelimiterMarker" !== f.type && "tableDelimiterFiller" !== f.type ? "tableCellDivider" === f.type && (o ? o = !1 : (0 !== l[1] && (c[0] = c[1], s = Ud(d, t, l, a, void 0, s)), l = c, c = [l[1], i, 0, 0])) : (o = !1, 0 === c[2] && (0 !== l[1] && (c[0] = c[1], s = Ud(d, t, l, a, void 0, s), l = [0, 0, 0, 0]), c[2] = i)) : "tableHead" === f.type ? (u = !0, h = i) : "tableRow" === f.type || "tableDelimiterRow" === f.type ? (h = i, 0 !== l[1] ? (c[0] = c[1], s = Ud(d, t, l, a, i, s)) : 0 !== c[1] && (s = Ud(d, t, c, a, i, s)), a = 0) : !a || "data" !== f.type && "tableDelimiterMarker" !== f.type && "tableDelimiterFiller" !== f.type || (c[3] = i) } for (0 !== h && Hd(d, t, h, n, r), d.consume(t.events), i = -1; ++i < t.events.length;) { const e = t.events[i]; "enter" === e[0] && "table" === e[1].type && (e[1]._align = Md(t.events, i)) } return e } function Ud(e, t, n, r, s, i) { const o = 1 === r ? "tableHeader" : 2 === r ? "tableDelimiter" : "tableData"; 0 !== n[0] && (i.end = Object.assign({}, jd(t.events, n[0])), e.add(n[0], 0, [["exit", i, t]])); const a = jd(t.events, n[1]); if (i = { type: o, start: Object.assign({}, a), end: Object.assign({}, a) }, e.add(n[1], 0, [["enter", i, t]]), 0 !== n[2]) { const s = jd(t.events, n[2]), i = jd(t.events, n[3]), o = { type: "tableContent", start: Object.assign({}, s), end: Object.assign({}, i) }; if (e.add(n[2], 0, [["enter", o, t]]), 2 !== r) { const r = t.events[n[2]], s = t.events[n[3]]; if (r[1].end = Object.assign({}, s[1].end), r[1].type = "chunkText", r[1].contentType = "text", n[3] > n[2] + 1) { const t = n[2] + 1, r = n[3] - n[2] - 1; e.add(t, r, []) } } e.add(n[3] + 1, 0, [["exit", o, t]]) } return void 0 !== s && (i.end = Object.assign({}, jd(t.events, s)), e.add(s, 0, [["exit", i, t]]), i = void 0), i } function Hd(e, t, n, r, s) { const i = [], o = jd(t.events, n); s && (s.end = Object.assign({}, o), i.push(["exit", s, t])), r.end = Object.assign({}, o), i.push(["exit", r, t]), e.add(n + 1, 0, i) } function jd(e, t) { const n = e[t], r = "enter" === n[0] ? "start" : "end"; return n[1][r] } const Gd = { name: "tasklistCheck", tokenize: function (e, t, n) { const r = this; return function (t) { return null === r.previous && r._gfmTasklistFirstContentOfListItem ? (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(t), e.exit("taskListCheckMarker"), s) : n(t) }; function s(t) { return nl(t) ? (e.enter("taskListCheckValueUnchecked"), e.consume(t), e.exit("taskListCheckValueUnchecked"), i) : 88 === t || 120 === t ? (e.enter("taskListCheckValueChecked"), e.consume(t), e.exit("taskListCheckValueChecked"), i) : n(t) } function i(t) { return 93 === t ? (e.enter("taskListCheckMarker"), e.consume(t), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), o) : n(t) } function o(r) { return tl(r) ? t(r) : rl(r) ? e.check({ tokenize: zd }, t, n)(r) : n(r) } } }; function zd(e, t, n) { return ll(e, function (e) { return null === e ? n(e) : t(e) }, "whitespace") } const Yd = {}, qd = Object.freeze(Object.defineProperty({ __proto__: null, default: function (e) { const t = e || Yd, n = this.data(), r = n.micromarkExtensions || (n.micromarkExtensions = []), s = n.fromMarkdownExtensions || (n.fromMarkdownExtensions = []), i = n.toMarkdownExtensions || (n.toMarkdownExtensions = []); r.push(function (e) { return za([{ text: _d }, { document: { 91: { name: "gfmFootnoteDefinition", tokenize: vd, continuation: { tokenize: Dd }, exit: Ld } }, text: { 91: { name: "gfmFootnoteCall", tokenize: Rd }, 93: { name: "gfmPotentialFootnoteCall", add: "after", tokenize: Od, resolveTo: xd } } }, Pd(e), { flow: { null: { name: "table", tokenize: Fd, resolveAll: Bd } } }, { text: { 91: Gd } }]) }(t)), s.push([{ transforms: [ch], enter: { literalAutolink: rh, literalAutolinkEmail: sh, literalAutolinkHttp: sh, literalAutolinkWww: sh }, exit: { literalAutolink: lh, literalAutolinkEmail: ah, literalAutolinkHttp: ih, literalAutolinkWww: oh } }, { enter: { gfmFootnoteCallString: ph, gfmFootnoteCall: fh, gfmFootnoteDefinitionLabelString: mh, gfmFootnoteDefinition: gh }, exit: { gfmFootnoteCallString: Eh, gfmFootnoteCall: Th, gfmFootnoteDefinitionLabelString: Ah, gfmFootnoteDefinition: _h } }, { canContainEols: ["delete"], enter: { strikethrough: Nh }, exit: { strikethrough: Ih } }, { enter: { table: td, tableData: id, tableHeader: id, tableRow: rd }, exit: { codeText: od, table: nd, tableData: sd, tableHeader: sd, tableRow: sd } }, { exit: { taskListCheckValueChecked: cd, taskListCheckValueUnchecked: cd, paragraph: ud } }]), i.push(function (e) { return { extensions: [{ unsafe: [{ character: "@", before: "[+\\-.\\w]", after: "[\\-.\\w]", inConstruct: th, notInConstruct: nh }, { character: ".", before: "[Ww]", after: "[\\-.\\w]", inConstruct: th, notInConstruct: nh }, { character: ":", before: "[ps]", after: "\\/", inConstruct: th, notInConstruct: nh }] }, bh(e), { unsafe: [{ character: "~", inConstruct: "phrasing", notInConstruct: Ch }], handlers: { delete: Oh } }, ld(e), { unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }], handlers: { listItem: hd } }] } }(t)) } }, Symbol.toStringTag, { value: "Module" })), Vd = /[#.]/g; function $d(e, t, n) { const r = n ? function (e) { const t = new Map; for (const n of e) t.set(n.toLowerCase(), n); return t }(n) : void 0; return function (n, s, ...i) { let o; if (null == n) { o = { type: "root", children: [] }; const e = s; i.unshift(e) } else { o = function (e, t) { const n = e || "", r = {}; let s, i, o = 0; for (; o < n.length;) { Vd.lastIndex = o; const e = Vd.exec(n), t = n.slice(o, e ? e.index : n.length); t && (s ? "#" === s ? r.id = t : Array.isArray(r.className) ? r.className.push(t) : r.className = [t] : i = t, o += t.length), e && (s = e[0], o++) } return { type: "element", tagName: i || t || "div", properties: r, children: [] } }(n, t); const a = o.tagName.toLowerCase(), l = r ? r.get(a) : void 0; if (o.tagName = l || a, function (e) { if (null === e || "object" != typeof e || Array.isArray(e)) return !0; if ("string" != typeof e.type) return !1; const t = e, n = Object.keys(e); for (const r of n) { const e = t[r]; if (e && "object" == typeof e) { if (!Array.isArray(e)) return !0; const t = e; for (const e of t) if ("number" != typeof e && "string" != typeof e) return !0 } } return !(!("children" in e) || !Array.isArray(e.children)) }(s)) i.unshift(s); else for (const [t, n] of Object.entries(s)) Wd(e, o.properties, t, n) } for (const e of i) Kd(o.children, e); return "element" === o.type && "template" === o.tagName && (o.content = { type: "root", children: o.children }, o.children = []), o } } function Wd(e, t, n, r) { const s = Do(e, n); let i; if (null != r) { if ("number" == typeof r) { if (Number.isNaN(r)) return; i = r } else i = "boolean" == typeof r ? r : "string" == typeof r ? s.spaceSeparated ? Fo(r) : s.commaSeparated ? $i(r) : s.commaOrSpaceSeparated ? Fo($i(r).join(" ")) : Qd(s, s.property, r) : Array.isArray(r) ? [...r] : "style" === s.property ? function (e) { const t = []; for (const [n, r] of Object.entries(e)) t.push([n, r].join(": ")); return t.join("; ") }(r) : String(r); if (Array.isArray(i)) { const e = []; for (const t of i) e.push(Qd(s, s.property, t)); i = e } "className" === s.property && Array.isArray(t.className) && (i = t.className.concat(i)), t[s.property] = i } } function Kd(e, t) { if (null == t); else if ("number" == typeof t || "string" == typeof t) e.push({ type: "text", value: String(t) }); else if (Array.isArray(t)) for (const n of t) Kd(e, n); else { if ("object" != typeof t || !("type" in t)) throw new Error("Expected node, nodes, or string, got `" + t + "`"); "root" === t.type ? Kd(e, t.children) : e.push(t) } } function Qd(e, t, n) { if ("string" == typeof n) { if (e.number && n && !Number.isNaN(Number(n))) return Number(n); if ((e.boolean || e.overloadedBoolean) && ("" === n || ro(n) === ro(t))) return !0 } return n } const Xd = $d(wo, "div"), Jd = $d(Mo, "g", ["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "solidColor", "textArea", "textPath"]); function Zd(e, t) { const n = e.indexOf("\r", t), r = e.indexOf("\n", t); return -1 === r ? n : -1 === n || n + 1 === r ? r : n < r ? n : r } const ep = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, tp = {}.hasOwnProperty, np = Object.prototype; function rp(e, t) { let n; switch (t.nodeName) { case "#comment": { const r = t; return n = { type: "comment", value: r.data }, ip(e, r, n), n } case "#document": case "#document-fragment": { const r = t, s = "mode" in r && ("quirks" === r.mode || "limited-quirks" === r.mode); if (n = { type: "root", children: sp(e, t.childNodes), data: { quirksMode: s } }, e.file && e.location) { const t = String(e.file), r = function (e) { const t = String(e), n = []; return { toOffset: function (e) { if (e && "number" == typeof e.line && "number" == typeof e.column && !Number.isNaN(e.line) && !Number.isNaN(e.column)) { for (; n.length < e.line;) { const e = n[n.length - 1], r = Zd(t, e), s = -1 === r ? t.length + 1 : r + 1; if (e === s) break; n.push(s) } const r = (e.line > 1 ? n[e.line - 2] : 0) + e.column - 1; if (r < n[e.line - 1]) return r } }, toPoint: function (e) { if ("number" == typeof e && e > -1 && e <= t.length) { let r = 0; for (; ;) { let s = n[r]; if (void 0 === s) { const e = Zd(t, n[r - 1]); s = -1 === e ? t.length + 1 : e + 1, n[r] = s } if (s > e) return { line: r + 1, column: e - (r > 0 ? n[r - 1] : 0) + 1, offset: e }; r++ } } } } }(t), s = r.toPoint(0), i = r.toPoint(t.length); n.position = { start: s, end: i } } return n } case "#documentType": return n = { type: "doctype" }, ip(e, t, n), n; case "#text": { const r = t; return n = { type: "text", value: r.value }, ip(e, r, n), n } default: return n = function (e, t) { const n = e.schema; e.schema = t.namespaceURI === ep.svg ? Mo : wo; let r = -1; const s = {}; for (; ++r < t.attrs.length;) { const e = t.attrs[r], n = (e.prefix ? e.prefix + ":" : "") + e.name; tp.call(np, n) || (s[n] = e.value) } const i = ("svg" === e.schema.space ? Jd : Xd)(t.tagName, s, sp(e, t.childNodes)); if (ip(e, t, i), "template" === i.tagName) { const n = t, r = n.sourceCodeLocation, s = r && r.startTag && op(r.startTag), o = r && r.endTag && op(r.endTag), a = rp(e, n.content); s && o && e.file && (a.position = { start: s.end, end: o.start }), i.content = a } return e.schema = n, i }(e, t), n } } function sp(e, t) { let n = -1; const r = []; for (; ++n < t.length;) { const s = rp(e, t[n]); r.push(s) } return r } function ip(e, t, n) { if ("sourceCodeLocation" in t && t.sourceCodeLocation && e.file) { const r = function (e, t, n) { const r = op(n); if ("element" === t.type) { const s = t.children[t.children.length - 1]; if (r && !n.endTag && s && s.position && s.position.end && (r.end = Object.assign({}, s.position.end)), e.verbose) { const r = {}; let s; if (n.attrs) for (s in n.attrs) tp.call(n.attrs, s) && (r[Do(e.schema, s).property] = op(n.attrs[s])); n.startTag; const i = op(n.startTag), o = n.endTag ? op(n.endTag) : void 0, a = { opening: i }; o && (a.closing = o), a.properties = r, t.data = { position: a } } } return r }(e, n, t.sourceCodeLocation); r && (e.location = !0, n.position = r) } } function op(e) { const t = ap({ line: e.startLine, column: e.startCol, offset: e.startOffset }), n = ap({ line: e.endLine, column: e.endCol, offset: e.endOffset }); return t || n ? { start: t, end: n } : void 0 } function ap(e) { return e.line && e.column ? e : void 0 } const lp = {}, cp = {}.hasOwnProperty, up = Lh("type", { handlers: { root: function (e, t) { const n = { nodeName: "#document", mode: (e.data || {}).quirksMode ? "quirks" : "no-quirks", childNodes: [] }; return n.childNodes = dp(e.children, n, t), pp(e, n), n }, element: function (e, t) { const n = t; let r = n; "element" === e.type && "svg" === e.tagName.toLowerCase() && "html" === n.space && (r = Mo); const s = []; let i; if (e.properties) for (i in e.properties) if ("children" !== i && cp.call(e.properties, i)) { const t = hp(r, i, e.properties[i]); t && s.push(t) } const o = r.space, a = { nodeName: e.tagName, tagName: e.tagName, attrs: s, namespaceURI: ep[o], childNodes: [], parentNode: null }; return a.childNodes = dp(e.children, a, r), pp(e, a), "template" === e.tagName && e.content && (a.content = function (e, t) { const n = { nodeName: "#document-fragment", childNodes: [] }; return n.childNodes = dp(e.children, n, t), pp(e, n), n }(e.content, r)), a }, text: function (e) { const t = { nodeName: "#text", value: e.value, parentNode: null }; return pp(e, t), t }, comment: function (e) { const t = { nodeName: "#comment", data: e.value, parentNode: null }; return pp(e, t), t }, doctype: function (e) { const t = { nodeName: "#documentType", name: "html", publicId: "", systemId: "", parentNode: null }; return pp(e, t), t } } }); function hp(e, t, n) { const r = Do(e, t); if (!1 === n || null == n || "number" == typeof n && Number.isNaN(n) || !n && r.boolean) return; Array.isArray(n) && (n = r.commaSeparated ? Wi(n) : Bo(n)); const s = { name: r.attribute, value: !0 === n ? "" : String(n) }; if (r.space && "html" !== r.space && "svg" !== r.space) { const e = s.name.indexOf(":"); e < 0 ? s.prefix = "" : (s.name = s.name.slice(e + 1), s.prefix = r.attribute.slice(0, e)), s.namespace = ep[r.space] } return s } function dp(e, t, n) { let r = -1; const s = []; if (e) for (; ++r < e.length;) { const i = up(e[r], n); i.parentNode = t, s.push(i) } return s } function pp(e, t) { const n = e.position; n && n.start && n.end && (n.start.offset, n.end.offset, t.sourceCodeLocation = { startLine: n.start.line, startCol: n.start.column, startOffset: n.start.offset, endLine: n.end.line, endCol: n.end.column, endOffset: n.end.offset }) } const fp = ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"], mp = new Set([65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111]), gp = ""; var Ep, Tp; (Tp = Ep || (Ep = {}))[Tp.EOF = -1] = "EOF", Tp[Tp.NULL = 0] = "NULL", Tp[Tp.TABULATION = 9] = "TABULATION", Tp[Tp.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", Tp[Tp.LINE_FEED = 10] = "LINE_FEED", Tp[Tp.FORM_FEED = 12] = "FORM_FEED", Tp[Tp.SPACE = 32] = "SPACE", Tp[Tp.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", Tp[Tp.QUOTATION_MARK = 34] = "QUOTATION_MARK", Tp[Tp.AMPERSAND = 38] = "AMPERSAND", Tp[Tp.APOSTROPHE = 39] = "APOSTROPHE", Tp[Tp.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", Tp[Tp.SOLIDUS = 47] = "SOLIDUS", Tp[Tp.DIGIT_0 = 48] = "DIGIT_0", Tp[Tp.DIGIT_9 = 57] = "DIGIT_9", Tp[Tp.SEMICOLON = 59] = "SEMICOLON", Tp[Tp.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", Tp[Tp.EQUALS_SIGN = 61] = "EQUALS_SIGN", Tp[Tp.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", Tp[Tp.QUESTION_MARK = 63] = "QUESTION_MARK", Tp[Tp.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", Tp[Tp.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", Tp[Tp.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", Tp[Tp.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", Tp[Tp.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", Tp[Tp.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z"; const Ap = "[CDATA[", _p = "doctype", yp = "script"; function bp(e) { return e >= 55296 && e <= 57343 } function Sp(e) { return 32 !== e && 10 !== e && 13 !== e && 9 !== e && 12 !== e && e >= 1 && e <= 31 || e >= 127 && e <= 159 } function kp(e) { return e >= 64976 && e <= 65007 || mp.has(e) } var Cp, Np, Ip, Op; (Np = Cp || (Cp = {})).controlCharacterInInputStream = "control-character-in-input-stream", Np.noncharacterInInputStream = "noncharacter-in-input-stream", Np.surrogateInInputStream = "surrogate-in-input-stream", Np.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", Np.endTagWithAttributes = "end-tag-with-attributes", Np.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", Np.unexpectedSolidusInTag = "unexpected-solidus-in-tag", Np.unexpectedNullCharacter = "unexpected-null-character", Np.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", Np.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", Np.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", Np.missingEndTagName = "missing-end-tag-name", Np.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", Np.unknownNamedCharacterReference = "unknown-named-character-reference", Np.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", Np.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", Np.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", Np.eofBeforeTagName = "eof-before-tag-name", Np.eofInTag = "eof-in-tag", Np.missingAttributeValue = "missing-attribute-value", Np.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", Np.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", Np.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", Np.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", Np.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", Np.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", Np.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", Np.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", Np.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", Np.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", Np.cdataInHtmlContent = "cdata-in-html-content", Np.incorrectlyOpenedComment = "incorrectly-opened-comment", Np.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", Np.eofInDoctype = "eof-in-doctype", Np.nestedComment = "nested-comment", Np.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", Np.eofInComment = "eof-in-comment", Np.incorrectlyClosedComment = "incorrectly-closed-comment", Np.eofInCdata = "eof-in-cdata", Np.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", Np.nullCharacterReference = "null-character-reference", Np.surrogateCharacterReference = "surrogate-character-reference", Np.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", Np.controlCharacterReference = "control-character-reference", Np.noncharacterCharacterReference = "noncharacter-character-reference", Np.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", Np.missingDoctypeName = "missing-doctype-name", Np.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", Np.duplicateAttribute = "duplicate-attribute", Np.nonConformingDoctype = "non-conforming-doctype", Np.missingDoctype = "missing-doctype", Np.misplacedDoctype = "misplaced-doctype", Np.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", Np.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", Np.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", Np.openElementsLeftAfterEof = "open-elements-left-after-eof", Np.abandonedHeadElementChild = "abandoned-head-element-child", Np.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", Np.nestedNoscriptInHead = "nested-noscript-in-head", Np.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text"; class xp { constructor(e) { this.handler = e, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = 65536, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1 } get col() { return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos) } get offset() { return this.droppedBufferSize + this.pos } getError(e, t) { const { line: n, col: r, offset: s } = this, i = r + t, o = s + t; return { code: e, startLine: n, endLine: n, startCol: i, endCol: i, startOffset: o, endOffset: o } } _err(e) { this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(e, 0))) } _addGap() { this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos } _processSurrogate(e) { if (this.pos !== this.html.length - 1) { const t = this.html.charCodeAt(this.pos + 1); if (function (e) { return e >= 56320 && e <= 57343 }(t)) return this.pos++, this._addGap(), 1024 * (e - 55296) + 9216 + t } else if (!this.lastChunkWritten) return this.endOfChunkHit = !0, Ep.EOF; return this._err(Cp.surrogateInInputStream), e } willDropParsedChunk() { return this.pos > this.bufferWaterline } dropParsedChunk() { this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0) } write(e, t) { this.html.length > 0 ? this.html += e : this.html = e, this.endOfChunkHit = !1, this.lastChunkWritten = t } insertHtmlAtCurrentPos(e) { this.html = this.html.substring(0, this.pos + 1) + e + this.html.substring(this.pos + 1), this.endOfChunkHit = !1 } startsWith(e, t) { if (this.pos + e.length > this.html.length) return this.endOfChunkHit = !this.lastChunkWritten, !1; if (t) return this.html.startsWith(e, this.pos); for (let n = 0; n < e.length; n++)if ((32 | this.html.charCodeAt(this.pos + n)) !== e.charCodeAt(n)) return !1; return !0 } peek(e) { const t = this.pos + e; if (t >= this.html.length) return this.endOfChunkHit = !this.lastChunkWritten, Ep.EOF; const n = this.html.charCodeAt(t); return n === Ep.CARRIAGE_RETURN ? Ep.LINE_FEED : n } advance() { if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length) return this.endOfChunkHit = !this.lastChunkWritten, Ep.EOF; let e = this.html.charCodeAt(this.pos); return e === Ep.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, Ep.LINE_FEED) : e === Ep.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, bp(e) && (e = this._processSurrogate(e)), null === this.handler.onParseError || e > 31 && e < 127 || e === Ep.LINE_FEED || e === Ep.CARRIAGE_RETURN || e > 159 && e < 64976 || this._checkForProblematicCharacters(e), e) } _checkForProblematicCharacters(e) { Sp(e) ? this._err(Cp.controlCharacterInInputStream) : kp(e) && this._err(Cp.noncharacterInInputStream) } retreat(e) { for (this.pos -= e; this.pos < this.lastGapPos;)this.lastGapPos = this.gapStack.pop(), this.pos--; this.isEol = !1 } } function Rp(e, t) { for (let n = e.attrs.length - 1; n >= 0; n--)if (e.attrs[n].name === t) return e.attrs[n].value; return null } (Op = Ip || (Ip = {}))[Op.CHARACTER = 0] = "CHARACTER", Op[Op.NULL_CHARACTER = 1] = "NULL_CHARACTER", Op[Op.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", Op[Op.START_TAG = 3] = "START_TAG", Op[Op.END_TAG = 4] = "END_TAG", Op[Op.COMMENT = 5] = "COMMENT", Op[Op.DOCTYPE = 6] = "DOCTYPE", Op[Op.EOF = 7] = "EOF", Op[Op.HIBERNATION = 8] = "HIBERNATION"; const vp = new Uint16Array('<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(e => e.charCodeAt(0))), Dp = new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]); var Lp, Pp, wp, Mp, Fp, Bp, Up, Hp, jp, Gp, zp, Yp, qp, Vp, $p, Wp, Kp, Qp; function Xp(e) { return e >= Lp.ZERO && e <= Lp.NINE } function Jp(e) { return e >= Lp.UPPER_A && e <= Lp.UPPER_F || e >= Lp.LOWER_A && e <= Lp.LOWER_F } function Zp(e) { return e === Lp.EQUALS || function (e) { return e >= Lp.UPPER_A && e <= Lp.UPPER_Z || e >= Lp.LOWER_A && e <= Lp.LOWER_Z || Xp(e) }(e) } (Pp = Lp || (Lp = {}))[Pp.NUM = 35] = "NUM", Pp[Pp.SEMI = 59] = "SEMI", Pp[Pp.EQUALS = 61] = "EQUALS", Pp[Pp.ZERO = 48] = "ZERO", Pp[Pp.NINE = 57] = "NINE", Pp[Pp.LOWER_A = 97] = "LOWER_A", Pp[Pp.LOWER_F = 102] = "LOWER_F", Pp[Pp.LOWER_X = 120] = "LOWER_X", Pp[Pp.LOWER_Z = 122] = "LOWER_Z", Pp[Pp.UPPER_A = 65] = "UPPER_A", Pp[Pp.UPPER_F = 70] = "UPPER_F", Pp[Pp.UPPER_Z = 90] = "UPPER_Z", (Mp = wp || (wp = {}))[Mp.VALUE_LENGTH = 49152] = "VALUE_LENGTH", Mp[Mp.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", Mp[Mp.JUMP_TABLE = 127] = "JUMP_TABLE", (Bp = Fp || (Fp = {}))[Bp.EntityStart = 0] = "EntityStart", Bp[Bp.NumericStart = 1] = "NumericStart", Bp[Bp.NumericDecimal = 2] = "NumericDecimal", Bp[Bp.NumericHex = 3] = "NumericHex", Bp[Bp.NamedEntity = 4] = "NamedEntity", (Hp = Up || (Up = {}))[Hp.Legacy = 0] = "Legacy", Hp[Hp.Strict = 1] = "Strict", Hp[Hp.Attribute = 2] = "Attribute"; class ef { constructor(e, t, n) { this.decodeTree = e, this.emitCodePoint = t, this.errors = n, this.state = Fp.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Up.Strict } startEntity(e) { this.decodeMode = e, this.state = Fp.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1 } write(e, t) { switch (this.state) { case Fp.EntityStart: return e.charCodeAt(t) === Lp.NUM ? (this.state = Fp.NumericStart, this.consumed += 1, this.stateNumericStart(e, t + 1)) : (this.state = Fp.NamedEntity, this.stateNamedEntity(e, t)); case Fp.NumericStart: return this.stateNumericStart(e, t); case Fp.NumericDecimal: return this.stateNumericDecimal(e, t); case Fp.NumericHex: return this.stateNumericHex(e, t); case Fp.NamedEntity: return this.stateNamedEntity(e, t) } } stateNumericStart(e, t) { return t >= e.length ? -1 : (32 | e.charCodeAt(t)) === Lp.LOWER_X ? (this.state = Fp.NumericHex, this.consumed += 1, this.stateNumericHex(e, t + 1)) : (this.state = Fp.NumericDecimal, this.stateNumericDecimal(e, t)) } addToNumericResult(e, t, n, r) { if (t !== n) { const s = n - t; this.result = this.result * Math.pow(r, s) + Number.parseInt(e.substr(t, s), r), this.consumed += s } } stateNumericHex(e, t) { const n = t; for (; t < e.length;) { const r = e.charCodeAt(t); if (!Xp(r) && !Jp(r)) return this.addToNumericResult(e, n, t, 16), this.emitNumericEntity(r, 3); t += 1 } return this.addToNumericResult(e, n, t, 16), -1 } stateNumericDecimal(e, t) { const n = t; for (; t < e.length;) { const r = e.charCodeAt(t); if (!Xp(r)) return this.addToNumericResult(e, n, t, 10), this.emitNumericEntity(r, 2); t += 1 } return this.addToNumericResult(e, n, t, 10), -1 } emitNumericEntity(e, t) { var n; if (this.consumed <= t) return null === (n = this.errors) || void 0 === n || n.absenceOfDigitsInNumericCharacterReference(this.consumed), 0; if (e === Lp.SEMI) this.consumed += 1; else if (this.decodeMode === Up.Strict) return 0; return this.emitCodePoint(function (e) { var t; return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : null !== (t = Dp.get(e)) && void 0 !== t ? t : e }(this.result), this.consumed), this.errors && (e !== Lp.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed } stateNamedEntity(e, t) { const { decodeTree: n } = this; let r = n[this.treeIndex], s = (r & wp.VALUE_LENGTH) >> 14; for (; t < e.length; t++, this.excess++) { const i = e.charCodeAt(t); if (this.treeIndex = tf(n, r, this.treeIndex + Math.max(1, s), i), this.treeIndex < 0) return 0 === this.result || this.decodeMode === Up.Attribute && (0 === s || Zp(i)) ? 0 : this.emitNotTerminatedNamedEntity(); if (r = n[this.treeIndex], s = (r & wp.VALUE_LENGTH) >> 14, 0 !== s) { if (i === Lp.SEMI) return this.emitNamedEntityData(this.treeIndex, s, this.consumed + this.excess); this.decodeMode !== Up.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0) } } return -1 } emitNotTerminatedNamedEntity() { var e; const { result: t, decodeTree: n } = this, r = (n[t] & wp.VALUE_LENGTH) >> 14; return this.emitNamedEntityData(t, r, this.consumed), null === (e = this.errors) || void 0 === e || e.missingSemicolonAfterCharacterReference(), this.consumed } emitNamedEntityData(e, t, n) { const { decodeTree: r } = this; return this.emitCodePoint(1 === t ? r[e] & ~wp.VALUE_LENGTH : r[e + 1], n), 3 === t && this.emitCodePoint(r[e + 2], n), n } end() { var e; switch (this.state) { case Fp.NamedEntity: return 0 === this.result || this.decodeMode === Up.Attribute && this.result !== this.treeIndex ? 0 : this.emitNotTerminatedNamedEntity(); case Fp.NumericDecimal: return this.emitNumericEntity(0, 2); case Fp.NumericHex: return this.emitNumericEntity(0, 3); case Fp.NumericStart: return null === (e = this.errors) || void 0 === e || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0; case Fp.EntityStart: return 0 } } } function tf(e, t, n, r) { const s = (t & wp.BRANCH_LENGTH) >> 7, i = t & wp.JUMP_TABLE; if (0 === s) return 0 !== i && r === i ? n : -1; if (i) { const t = r - i; return t < 0 || t >= s ? -1 : e[n + t] - 1 } let o = n, a = o + s - 1; for (; o <= a;) { const t = o + a >>> 1, n = e[t]; if (n < r) o = t + 1; else { if (!(n > r)) return e[t + s]; a = t - 1 } } return -1 } (Gp = jp || (jp = {})).HTML = "http://www.w3.org/1999/xhtml", Gp.MATHML = "http://www.w3.org/1998/Math/MathML", Gp.SVG = "http://www.w3.org/2000/svg", Gp.XLINK = "http://www.w3.org/1999/xlink", Gp.XML = "http://www.w3.org/XML/1998/namespace", Gp.XMLNS = "http://www.w3.org/2000/xmlns/", (Yp = zp || (zp = {})).TYPE = "type", Yp.ACTION = "action", Yp.ENCODING = "encoding", Yp.PROMPT = "prompt", Yp.NAME = "name", Yp.COLOR = "color", Yp.FACE = "face", Yp.SIZE = "size", (Vp = qp || (qp = {})).NO_QUIRKS = "no-quirks", Vp.QUIRKS = "quirks", Vp.LIMITED_QUIRKS = "limited-quirks", (Wp = $p || ($p = {})).A = "a", Wp.ADDRESS = "address", Wp.ANNOTATION_XML = "annotation-xml", Wp.APPLET = "applet", Wp.AREA = "area", Wp.ARTICLE = "article", Wp.ASIDE = "aside", Wp.B = "b", Wp.BASE = "base", Wp.BASEFONT = "basefont", Wp.BGSOUND = "bgsound", Wp.BIG = "big", Wp.BLOCKQUOTE = "blockquote", Wp.BODY = "body", Wp.BR = "br", Wp.BUTTON = "button", Wp.CAPTION = "caption", Wp.CENTER = "center", Wp.CODE = "code", Wp.COL = "col", Wp.COLGROUP = "colgroup", Wp.DD = "dd", Wp.DESC = "desc", Wp.DETAILS = "details", Wp.DIALOG = "dialog", Wp.DIR = "dir", Wp.DIV = "div", Wp.DL = "dl", Wp.DT = "dt", Wp.EM = "em", Wp.EMBED = "embed", Wp.FIELDSET = "fieldset", Wp.FIGCAPTION = "figcaption", Wp.FIGURE = "figure", Wp.FONT = "font", Wp.FOOTER = "footer", Wp.FOREIGN_OBJECT = "foreignObject", Wp.FORM = "form", Wp.FRAME = "frame", Wp.FRAMESET = "frameset", Wp.H1 = "h1", Wp.H2 = "h2", Wp.H3 = "h3", Wp.H4 = "h4", Wp.H5 = "h5", Wp.H6 = "h6", Wp.HEAD = "head", Wp.HEADER = "header", Wp.HGROUP = "hgroup", Wp.HR = "hr", Wp.HTML = "html", Wp.I = "i", Wp.IMG = "img", Wp.IMAGE = "image", Wp.INPUT = "input", Wp.IFRAME = "iframe", Wp.KEYGEN = "keygen", Wp.LABEL = "label", Wp.LI = "li", Wp.LINK = "link", Wp.LISTING = "listing", Wp.MAIN = "main", Wp.MALIGNMARK = "malignmark", Wp.MARQUEE = "marquee", Wp.MATH = "math", Wp.MENU = "menu", Wp.META = "meta", Wp.MGLYPH = "mglyph", Wp.MI = "mi", Wp.MO = "mo", Wp.MN = "mn", Wp.MS = "ms", Wp.MTEXT = "mtext", Wp.NAV = "nav", Wp.NOBR = "nobr", Wp.NOFRAMES = "noframes", Wp.NOEMBED = "noembed", Wp.NOSCRIPT = "noscript", Wp.OBJECT = "object", Wp.OL = "ol", Wp.OPTGROUP = "optgroup", Wp.OPTION = "option", Wp.P = "p", Wp.PARAM = "param", Wp.PLAINTEXT = "plaintext", Wp.PRE = "pre", Wp.RB = "rb", Wp.RP = "rp", Wp.RT = "rt", Wp.RTC = "rtc", Wp.RUBY = "ruby", Wp.S = "s", Wp.SCRIPT = "script", Wp.SEARCH = "search", Wp.SECTION = "section", Wp.SELECT = "select", Wp.SOURCE = "source", Wp.SMALL = "small", Wp.SPAN = "span", Wp.STRIKE = "strike", Wp.STRONG = "strong", Wp.STYLE = "style", Wp.SUB = "sub", Wp.SUMMARY = "summary", Wp.SUP = "sup", Wp.TABLE = "table", Wp.TBODY = "tbody", Wp.TEMPLATE = "template", Wp.TEXTAREA = "textarea", Wp.TFOOT = "tfoot", Wp.TD = "td", Wp.TH = "th", Wp.THEAD = "thead", Wp.TITLE = "title", Wp.TR = "tr", Wp.TRACK = "track", Wp.TT = "tt", Wp.U = "u", Wp.UL = "ul", Wp.SVG = "svg", Wp.VAR = "var", Wp.WBR = "wbr", Wp.XMP = "xmp", (Qp = Kp || (Kp = {}))[Qp.UNKNOWN = 0] = "UNKNOWN", Qp[Qp.A = 1] = "A", Qp[Qp.ADDRESS = 2] = "ADDRESS", Qp[Qp.ANNOTATION_XML = 3] = "ANNOTATION_XML", Qp[Qp.APPLET = 4] = "APPLET", Qp[Qp.AREA = 5] = "AREA", Qp[Qp.ARTICLE = 6] = "ARTICLE", Qp[Qp.ASIDE = 7] = "ASIDE", Qp[Qp.B = 8] = "B", Qp[Qp.BASE = 9] = "BASE", Qp[Qp.BASEFONT = 10] = "BASEFONT", Qp[Qp.BGSOUND = 11] = "BGSOUND", Qp[Qp.BIG = 12] = "BIG", Qp[Qp.BLOCKQUOTE = 13] = "BLOCKQUOTE", Qp[Qp.BODY = 14] = "BODY", Qp[Qp.BR = 15] = "BR", Qp[Qp.BUTTON = 16] = "BUTTON", Qp[Qp.CAPTION = 17] = "CAPTION", Qp[Qp.CENTER = 18] = "CENTER", Qp[Qp.CODE = 19] = "CODE", Qp[Qp.COL = 20] = "COL", Qp[Qp.COLGROUP = 21] = "COLGROUP", Qp[Qp.DD = 22] = "DD", Qp[Qp.DESC = 23] = "DESC", Qp[Qp.DETAILS = 24] = "DETAILS", Qp[Qp.DIALOG = 25] = "DIALOG", Qp[Qp.DIR = 26] = "DIR", Qp[Qp.DIV = 27] = "DIV", Qp[Qp.DL = 28] = "DL", Qp[Qp.DT = 29] = "DT", Qp[Qp.EM = 30] = "EM", Qp[Qp.EMBED = 31] = "EMBED", Qp[Qp.FIELDSET = 32] = "FIELDSET", Qp[Qp.FIGCAPTION = 33] = "FIGCAPTION", Qp[Qp.FIGURE = 34] = "FIGURE", Qp[Qp.FONT = 35] = "FONT", Qp[Qp.FOOTER = 36] = "FOOTER", Qp[Qp.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", Qp[Qp.FORM = 38] = "FORM", Qp[Qp.FRAME = 39] = "FRAME", Qp[Qp.FRAMESET = 40] = "FRAMESET", Qp[Qp.H1 = 41] = "H1", Qp[Qp.H2 = 42] = "H2", Qp[Qp.H3 = 43] = "H3", Qp[Qp.H4 = 44] = "H4", Qp[Qp.H5 = 45] = "H5", Qp[Qp.H6 = 46] = "H6", Qp[Qp.HEAD = 47] = "HEAD", Qp[Qp.HEADER = 48] = "HEADER", Qp[Qp.HGROUP = 49] = "HGROUP", Qp[Qp.HR = 50] = "HR", Qp[Qp.HTML = 51] = "HTML", Qp[Qp.I = 52] = "I", Qp[Qp.IMG = 53] = "IMG", Qp[Qp.IMAGE = 54] = "IMAGE", Qp[Qp.INPUT = 55] = "INPUT", Qp[Qp.IFRAME = 56] = "IFRAME", Qp[Qp.KEYGEN = 57] = "KEYGEN", Qp[Qp.LABEL = 58] = "LABEL", Qp[Qp.LI = 59] = "LI", Qp[Qp.LINK = 60] = "LINK", Qp[Qp.LISTING = 61] = "LISTING", Qp[Qp.MAIN = 62] = "MAIN", Qp[Qp.MALIGNMARK = 63] = "MALIGNMARK", Qp[Qp.MARQUEE = 64] = "MARQUEE", Qp[Qp.MATH = 65] = "MATH", Qp[Qp.MENU = 66] = "MENU", Qp[Qp.META = 67] = "META", Qp[Qp.MGLYPH = 68] = "MGLYPH", Qp[Qp.MI = 69] = "MI", Qp[Qp.MO = 70] = "MO", Qp[Qp.MN = 71] = "MN", Qp[Qp.MS = 72] = "MS", Qp[Qp.MTEXT = 73] = "MTEXT", Qp[Qp.NAV = 74] = "NAV", Qp[Qp.NOBR = 75] = "NOBR", Qp[Qp.NOFRAMES = 76] = "NOFRAMES", Qp[Qp.NOEMBED = 77] = "NOEMBED", Qp[Qp.NOSCRIPT = 78] = "NOSCRIPT", Qp[Qp.OBJECT = 79] = "OBJECT", Qp[Qp.OL = 80] = "OL", Qp[Qp.OPTGROUP = 81] = "OPTGROUP", Qp[Qp.OPTION = 82] = "OPTION", Qp[Qp.P = 83] = "P", Qp[Qp.PARAM = 84] = "PARAM", Qp[Qp.PLAINTEXT = 85] = "PLAINTEXT", Qp[Qp.PRE = 86] = "PRE", Qp[Qp.RB = 87] = "RB", Qp[Qp.RP = 88] = "RP", Qp[Qp.RT = 89] = "RT", Qp[Qp.RTC = 90] = "RTC", Qp[Qp.RUBY = 91] = "RUBY", Qp[Qp.S = 92] = "S", Qp[Qp.SCRIPT = 93] = "SCRIPT", Qp[Qp.SEARCH = 94] = "SEARCH", Qp[Qp.SECTION = 95] = "SECTION", Qp[Qp.SELECT = 96] = "SELECT", Qp[Qp.SOURCE = 97] = "SOURCE", Qp[Qp.SMALL = 98] = "SMALL", Qp[Qp.SPAN = 99] = "SPAN", Qp[Qp.STRIKE = 100] = "STRIKE", Qp[Qp.STRONG = 101] = "STRONG", Qp[Qp.STYLE = 102] = "STYLE", Qp[Qp.SUB = 103] = "SUB", Qp[Qp.SUMMARY = 104] = "SUMMARY", Qp[Qp.SUP = 105] = "SUP", Qp[Qp.TABLE = 106] = "TABLE", Qp[Qp.TBODY = 107] = "TBODY", Qp[Qp.TEMPLATE = 108] = "TEMPLATE", Qp[Qp.TEXTAREA = 109] = "TEXTAREA", Qp[Qp.TFOOT = 110] = "TFOOT", Qp[Qp.TD = 111] = "TD", Qp[Qp.TH = 112] = "TH", Qp[Qp.THEAD = 113] = "THEAD", Qp[Qp.TITLE = 114] = "TITLE", Qp[Qp.TR = 115] = "TR", Qp[Qp.TRACK = 116] = "TRACK", Qp[Qp.TT = 117] = "TT", Qp[Qp.U = 118] = "U", Qp[Qp.UL = 119] = "UL", Qp[Qp.SVG = 120] = "SVG", Qp[Qp.VAR = 121] = "VAR", Qp[Qp.WBR = 122] = "WBR", Qp[Qp.XMP = 123] = "XMP"; const nf = new Map([[$p.A, Kp.A], [$p.ADDRESS, Kp.ADDRESS], [$p.ANNOTATION_XML, Kp.ANNOTATION_XML], [$p.APPLET, Kp.APPLET], [$p.AREA, Kp.AREA], [$p.ARTICLE, Kp.ARTICLE], [$p.ASIDE, Kp.ASIDE], [$p.B, Kp.B], [$p.BASE, Kp.BASE], [$p.BASEFONT, Kp.BASEFONT], [$p.BGSOUND, Kp.BGSOUND], [$p.BIG, Kp.BIG], [$p.BLOCKQUOTE, Kp.BLOCKQUOTE], [$p.BODY, Kp.BODY], [$p.BR, Kp.BR], [$p.BUTTON, Kp.BUTTON], [$p.CAPTION, Kp.CAPTION], [$p.CENTER, Kp.CENTER], [$p.CODE, Kp.CODE], [$p.COL, Kp.COL], [$p.COLGROUP, Kp.COLGROUP], [$p.DD, Kp.DD], [$p.DESC, Kp.DESC], [$p.DETAILS, Kp.DETAILS], [$p.DIALOG, Kp.DIALOG], [$p.DIR, Kp.DIR], [$p.DIV, Kp.DIV], [$p.DL, Kp.DL], [$p.DT, Kp.DT], [$p.EM, Kp.EM], [$p.EMBED, Kp.EMBED], [$p.FIELDSET, Kp.FIELDSET], [$p.FIGCAPTION, Kp.FIGCAPTION], [$p.FIGURE, Kp.FIGURE], [$p.FONT, Kp.FONT], [$p.FOOTER, Kp.FOOTER], [$p.FOREIGN_OBJECT, Kp.FOREIGN_OBJECT], [$p.FORM, Kp.FORM], [$p.FRAME, Kp.FRAME], [$p.FRAMESET, Kp.FRAMESET], [$p.H1, Kp.H1], [$p.H2, Kp.H2], [$p.H3, Kp.H3], [$p.H4, Kp.H4], [$p.H5, Kp.H5], [$p.H6, Kp.H6], [$p.HEAD, Kp.HEAD], [$p.HEADER, Kp.HEADER], [$p.HGROUP, Kp.HGROUP], [$p.HR, Kp.HR], [$p.HTML, Kp.HTML], [$p.I, Kp.I], [$p.IMG, Kp.IMG], [$p.IMAGE, Kp.IMAGE], [$p.INPUT, Kp.INPUT], [$p.IFRAME, Kp.IFRAME], [$p.KEYGEN, Kp.KEYGEN], [$p.LABEL, Kp.LABEL], [$p.LI, Kp.LI], [$p.LINK, Kp.LINK], [$p.LISTING, Kp.LISTING], [$p.MAIN, Kp.MAIN], [$p.MALIGNMARK, Kp.MALIGNMARK], [$p.MARQUEE, Kp.MARQUEE], [$p.MATH, Kp.MATH], [$p.MENU, Kp.MENU], [$p.META, Kp.META], [$p.MGLYPH, Kp.MGLYPH], [$p.MI, Kp.MI], [$p.MO, Kp.MO], [$p.MN, Kp.MN], [$p.MS, Kp.MS], [$p.MTEXT, Kp.MTEXT], [$p.NAV, Kp.NAV], [$p.NOBR, Kp.NOBR], [$p.NOFRAMES, Kp.NOFRAMES], [$p.NOEMBED, Kp.NOEMBED], [$p.NOSCRIPT, Kp.NOSCRIPT], [$p.OBJECT, Kp.OBJECT], [$p.OL, Kp.OL], [$p.OPTGROUP, Kp.OPTGROUP], [$p.OPTION, Kp.OPTION], [$p.P, Kp.P], [$p.PARAM, Kp.PARAM], [$p.PLAINTEXT, Kp.PLAINTEXT], [$p.PRE, Kp.PRE], [$p.RB, Kp.RB], [$p.RP, Kp.RP], [$p.RT, Kp.RT], [$p.RTC, Kp.RTC], [$p.RUBY, Kp.RUBY], [$p.S, Kp.S], [$p.SCRIPT, Kp.SCRIPT], [$p.SEARCH, Kp.SEARCH], [$p.SECTION, Kp.SECTION], [$p.SELECT, Kp.SELECT], [$p.SOURCE, Kp.SOURCE], [$p.SMALL, Kp.SMALL], [$p.SPAN, Kp.SPAN], [$p.STRIKE, Kp.STRIKE], [$p.STRONG, Kp.STRONG], [$p.STYLE, Kp.STYLE], [$p.SUB, Kp.SUB], [$p.SUMMARY, Kp.SUMMARY], [$p.SUP, Kp.SUP], [$p.TABLE, Kp.TABLE], [$p.TBODY, Kp.TBODY], [$p.TEMPLATE, Kp.TEMPLATE], [$p.TEXTAREA, Kp.TEXTAREA], [$p.TFOOT, Kp.TFOOT], [$p.TD, Kp.TD], [$p.TH, Kp.TH], [$p.THEAD, Kp.THEAD], [$p.TITLE, Kp.TITLE], [$p.TR, Kp.TR], [$p.TRACK, Kp.TRACK], [$p.TT, Kp.TT], [$p.U, Kp.U], [$p.UL, Kp.UL], [$p.SVG, Kp.SVG], [$p.VAR, Kp.VAR], [$p.WBR, Kp.WBR], [$p.XMP, Kp.XMP]]); function rf(e) { var t; return null !== (t = nf.get(e)) && void 0 !== t ? t : Kp.UNKNOWN } const sf = Kp, of = { [jp.HTML]: new Set([sf.ADDRESS, sf.APPLET, sf.AREA, sf.ARTICLE, sf.ASIDE, sf.BASE, sf.BASEFONT, sf.BGSOUND, sf.BLOCKQUOTE, sf.BODY, sf.BR, sf.BUTTON, sf.CAPTION, sf.CENTER, sf.COL, sf.COLGROUP, sf.DD, sf.DETAILS, sf.DIR, sf.DIV, sf.DL, sf.DT, sf.EMBED, sf.FIELDSET, sf.FIGCAPTION, sf.FIGURE, sf.FOOTER, sf.FORM, sf.FRAME, sf.FRAMESET, sf.H1, sf.H2, sf.H3, sf.H4, sf.H5, sf.H6, sf.HEAD, sf.HEADER, sf.HGROUP, sf.HR, sf.HTML, sf.IFRAME, sf.IMG, sf.INPUT, sf.LI, sf.LINK, sf.LISTING, sf.MAIN, sf.MARQUEE, sf.MENU, sf.META, sf.NAV, sf.NOEMBED, sf.NOFRAMES, sf.NOSCRIPT, sf.OBJECT, sf.OL, sf.P, sf.PARAM, sf.PLAINTEXT, sf.PRE, sf.SCRIPT, sf.SECTION, sf.SELECT, sf.SOURCE, sf.STYLE, sf.SUMMARY, sf.TABLE, sf.TBODY, sf.TD, sf.TEMPLATE, sf.TEXTAREA, sf.TFOOT, sf.TH, sf.THEAD, sf.TITLE, sf.TR, sf.TRACK, sf.UL, sf.WBR, sf.XMP]), [jp.MATHML]: new Set([sf.MI, sf.MO, sf.MN, sf.MS, sf.MTEXT, sf.ANNOTATION_XML]), [jp.SVG]: new Set([sf.TITLE, sf.FOREIGN_OBJECT, sf.DESC]), [jp.XLINK]: new Set, [jp.XML]: new Set, [jp.XMLNS]: new Set }, af = new Set([sf.H1, sf.H2, sf.H3, sf.H4, sf.H5, sf.H6]); var lf, cf; $p.STYLE, $p.SCRIPT, $p.XMP, $p.IFRAME, $p.NOEMBED, $p.NOFRAMES, $p.PLAINTEXT, (cf = lf || (lf = {}))[cf.DATA = 0] = "DATA", cf[cf.RCDATA = 1] = "RCDATA", cf[cf.RAWTEXT = 2] = "RAWTEXT", cf[cf.SCRIPT_DATA = 3] = "SCRIPT_DATA", cf[cf.PLAINTEXT = 4] = "PLAINTEXT", cf[cf.TAG_OPEN = 5] = "TAG_OPEN", cf[cf.END_TAG_OPEN = 6] = "END_TAG_OPEN", cf[cf.TAG_NAME = 7] = "TAG_NAME", cf[cf.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", cf[cf.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", cf[cf.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", cf[cf.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", cf[cf.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", cf[cf.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", cf[cf.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", cf[cf.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", cf[cf.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", cf[cf.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", cf[cf.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", cf[cf.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", cf[cf.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", cf[cf.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", cf[cf.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", cf[cf.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", cf[cf.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", cf[cf.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", cf[cf.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", cf[cf.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", cf[cf.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", cf[cf.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", cf[cf.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", cf[cf.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", cf[cf.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", cf[cf.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", cf[cf.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", cf[cf.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", cf[cf.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", cf[cf.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", cf[cf.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", cf[cf.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", cf[cf.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", cf[cf.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", cf[cf.COMMENT_START = 42] = "COMMENT_START", cf[cf.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", cf[cf.COMMENT = 44] = "COMMENT", cf[cf.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", cf[cf.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", cf[cf.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", cf[cf.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", cf[cf.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", cf[cf.COMMENT_END = 50] = "COMMENT_END", cf[cf.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", cf[cf.DOCTYPE = 52] = "DOCTYPE", cf[cf.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", cf[cf.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", cf[cf.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", cf[cf.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", cf[cf.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", cf[cf.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", cf[cf.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", cf[cf.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", cf[cf.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", cf[cf.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", cf[cf.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", cf[cf.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", cf[cf.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", cf[cf.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", cf[cf.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", cf[cf.CDATA_SECTION = 68] = "CDATA_SECTION", cf[cf.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", cf[cf.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", cf[cf.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", cf[cf.AMBIGUOUS_AMPERSAND = 72] = "AMBIGUOUS_AMPERSAND"; const uf = { DATA: lf.DATA, RCDATA: lf.RCDATA, RAWTEXT: lf.RAWTEXT, SCRIPT_DATA: lf.SCRIPT_DATA, PLAINTEXT: lf.PLAINTEXT, CDATA_SECTION: lf.CDATA_SECTION }; function hf(e) { return e >= Ep.LATIN_CAPITAL_A && e <= Ep.LATIN_CAPITAL_Z } function df(e) { return function (e) { return e >= Ep.LATIN_SMALL_A && e <= Ep.LATIN_SMALL_Z }(e) || hf(e) } function pf(e) { return df(e) || function (e) { return e >= Ep.DIGIT_0 && e <= Ep.DIGIT_9 }(e) } function ff(e) { return e + 32 } function mf(e) { return e === Ep.SPACE || e === Ep.LINE_FEED || e === Ep.TABULATION || e === Ep.FORM_FEED } function gf(e) { return mf(e) || e === Ep.SOLIDUS || e === Ep.GREATER_THAN_SIGN } class Ef { constructor(e, t) { this.options = e, this.handler = t, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = lf.DATA, this.returnState = lf.DATA, this.entityStartPos = 0, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new xp(t), this.currentLocation = this.getCurrentLocation(-1), this.entityDecoder = new ef(vp, (e, t) => { this.preprocessor.pos = this.entityStartPos + t - 1, this._flushCodePointConsumedAsCharacterReference(e) }, t.onParseError ? { missingSemicolonAfterCharacterReference: () => { this._err(Cp.missingSemicolonAfterCharacterReference, 1) }, absenceOfDigitsInNumericCharacterReference: e => { this._err(Cp.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + e) }, validateNumericCharacterReference: e => { const t = function (e) { return e === Ep.NULL ? Cp.nullCharacterReference : e > 1114111 ? Cp.characterReferenceOutsideUnicodeRange : bp(e) ? Cp.surrogateCharacterReference : kp(e) ? Cp.noncharacterCharacterReference : Sp(e) || e === Ep.CARRIAGE_RETURN ? Cp.controlCharacterReference : null }(e); t && this._err(t, 1) } } : void 0) } _err(e, t = 0) { var n, r; null === (r = (n = this.handler).onParseError) || void 0 === r || r.call(n, this.preprocessor.getError(e, t)) } getCurrentLocation(e) { return this.options.sourceCodeLocationInfo ? { startLine: this.preprocessor.line, startCol: this.preprocessor.col - e, startOffset: this.preprocessor.offset - e, endLine: -1, endCol: -1, endOffset: -1 } : null } _runParsingLoop() { if (!this.inLoop) { for (this.inLoop = !0; this.active && !this.paused;) { this.consumedAfterSnapshot = 0; const e = this._consume(); this._ensureHibernation() || this._callState(e) } this.inLoop = !1 } } pause() { this.paused = !0 } resume(e) { if (!this.paused) throw new Error("Parser was already resumed"); this.paused = !1, this.inLoop || (this._runParsingLoop(), this.paused || null == e || e()) } write(e, t, n) { this.active = !0, this.preprocessor.write(e, t), this._runParsingLoop(), this.paused || null == n || n() } insertHtmlAtCurrentPos(e) { this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(e), this._runParsingLoop() } _ensureHibernation() { return !!this.preprocessor.endOfChunkHit && (this.preprocessor.retreat(this.consumedAfterSnapshot), this.consumedAfterSnapshot = 0, this.active = !1, !0) } _consume() { return this.consumedAfterSnapshot++, this.preprocessor.advance() } _advanceBy(e) { this.consumedAfterSnapshot += e; for (let t = 0; t < e; t++)this.preprocessor.advance() } _consumeSequenceIfMatch(e, t) { return !!this.preprocessor.startsWith(e, t) && (this._advanceBy(e.length - 1), !0) } _createStartTagToken() { this.currentToken = { type: Ip.START_TAG, tagName: "", tagID: Kp.UNKNOWN, selfClosing: !1, ackSelfClosing: !1, attrs: [], location: this.getCurrentLocation(1) } } _createEndTagToken() { this.currentToken = { type: Ip.END_TAG, tagName: "", tagID: Kp.UNKNOWN, selfClosing: !1, ackSelfClosing: !1, attrs: [], location: this.getCurrentLocation(2) } } _createCommentToken(e) { this.currentToken = { type: Ip.COMMENT, data: "", location: this.getCurrentLocation(e) } } _createDoctypeToken(e) { this.currentToken = { type: Ip.DOCTYPE, name: e, forceQuirks: !1, publicId: null, systemId: null, location: this.currentLocation } } _createCharacterToken(e, t) { this.currentCharacterToken = { type: e, chars: t, location: this.currentLocation } } _createAttr(e) { this.currentAttr = { name: e, value: "" }, this.currentLocation = this.getCurrentLocation(0) } _leaveAttrName() { var e, t; const n = this.currentToken; null === Rp(n, this.currentAttr.name) ? (n.attrs.push(this.currentAttr), n.location && this.currentLocation && ((null !== (e = (t = n.location).attrs) && void 0 !== e ? e : t.attrs = Object.create(null))[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue())) : this._err(Cp.duplicateAttribute) } _leaveAttrValue() { this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset) } prepareToken(e) { this._emitCurrentCharacterToken(e.location), this.currentToken = null, e.location && (e.location.endLine = this.preprocessor.line, e.location.endCol = this.preprocessor.col + 1, e.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1) } emitCurrentTagToken() { const e = this.currentToken; this.prepareToken(e), e.tagID = rf(e.tagName), e.type === Ip.START_TAG ? (this.lastStartTagName = e.tagName, this.handler.onStartTag(e)) : (e.attrs.length > 0 && this._err(Cp.endTagWithAttributes), e.selfClosing && this._err(Cp.endTagWithTrailingSolidus), this.handler.onEndTag(e)), this.preprocessor.dropParsedChunk() } emitCurrentComment(e) { this.prepareToken(e), this.handler.onComment(e), this.preprocessor.dropParsedChunk() } emitCurrentDoctype(e) { this.prepareToken(e), this.handler.onDoctype(e), this.preprocessor.dropParsedChunk() } _emitCurrentCharacterToken(e) { if (this.currentCharacterToken) { switch (e && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = e.startLine, this.currentCharacterToken.location.endCol = e.startCol, this.currentCharacterToken.location.endOffset = e.startOffset), this.currentCharacterToken.type) { case Ip.CHARACTER: this.handler.onCharacter(this.currentCharacterToken); break; case Ip.NULL_CHARACTER: this.handler.onNullCharacter(this.currentCharacterToken); break; case Ip.WHITESPACE_CHARACTER: this.handler.onWhitespaceCharacter(this.currentCharacterToken) }this.currentCharacterToken = null } } _emitEOFToken() { const e = this.getCurrentLocation(0); e && (e.endLine = e.startLine, e.endCol = e.startCol, e.endOffset = e.startOffset), this._emitCurrentCharacterToken(e), this.handler.onEof({ type: Ip.EOF, location: e }), this.active = !1 } _appendCharToCurrentCharacterToken(e, t) { if (this.currentCharacterToken) { if (this.currentCharacterToken.type === e) return void (this.currentCharacterToken.chars += t); this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk() } this._createCharacterToken(e, t) } _emitCodePoint(e) { const t = mf(e) ? Ip.WHITESPACE_CHARACTER : e === Ep.NULL ? Ip.NULL_CHARACTER : Ip.CHARACTER; this._appendCharToCurrentCharacterToken(t, String.fromCodePoint(e)) } _emitChars(e) { this._appendCharToCurrentCharacterToken(Ip.CHARACTER, e) } _startCharacterReference() { this.returnState = this.state, this.state = lf.CHARACTER_REFERENCE, this.entityStartPos = this.preprocessor.pos, this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? Up.Attribute : Up.Legacy) } _isCharacterReferenceInAttribute() { return this.returnState === lf.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === lf.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === lf.ATTRIBUTE_VALUE_UNQUOTED } _flushCodePointConsumedAsCharacterReference(e) { this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(e) : this._emitCodePoint(e) } _callState(e) { switch (this.state) { case lf.DATA: this._stateData(e); break; case lf.RCDATA: this._stateRcdata(e); break; case lf.RAWTEXT: this._stateRawtext(e); break; case lf.SCRIPT_DATA: this._stateScriptData(e); break; case lf.PLAINTEXT: this._statePlaintext(e); break; case lf.TAG_OPEN: this._stateTagOpen(e); break; case lf.END_TAG_OPEN: this._stateEndTagOpen(e); break; case lf.TAG_NAME: this._stateTagName(e); break; case lf.RCDATA_LESS_THAN_SIGN: this._stateRcdataLessThanSign(e); break; case lf.RCDATA_END_TAG_OPEN: this._stateRcdataEndTagOpen(e); break; case lf.RCDATA_END_TAG_NAME: this._stateRcdataEndTagName(e); break; case lf.RAWTEXT_LESS_THAN_SIGN: this._stateRawtextLessThanSign(e); break; case lf.RAWTEXT_END_TAG_OPEN: this._stateRawtextEndTagOpen(e); break; case lf.RAWTEXT_END_TAG_NAME: this._stateRawtextEndTagName(e); break; case lf.SCRIPT_DATA_LESS_THAN_SIGN: this._stateScriptDataLessThanSign(e); break; case lf.SCRIPT_DATA_END_TAG_OPEN: this._stateScriptDataEndTagOpen(e); break; case lf.SCRIPT_DATA_END_TAG_NAME: this._stateScriptDataEndTagName(e); break; case lf.SCRIPT_DATA_ESCAPE_START: this._stateScriptDataEscapeStart(e); break; case lf.SCRIPT_DATA_ESCAPE_START_DASH: this._stateScriptDataEscapeStartDash(e); break; case lf.SCRIPT_DATA_ESCAPED: this._stateScriptDataEscaped(e); break; case lf.SCRIPT_DATA_ESCAPED_DASH: this._stateScriptDataEscapedDash(e); break; case lf.SCRIPT_DATA_ESCAPED_DASH_DASH: this._stateScriptDataEscapedDashDash(e); break; case lf.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: this._stateScriptDataEscapedLessThanSign(e); break; case lf.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: this._stateScriptDataEscapedEndTagOpen(e); break; case lf.SCRIPT_DATA_ESCAPED_END_TAG_NAME: this._stateScriptDataEscapedEndTagName(e); break; case lf.SCRIPT_DATA_DOUBLE_ESCAPE_START: this._stateScriptDataDoubleEscapeStart(e); break; case lf.SCRIPT_DATA_DOUBLE_ESCAPED: this._stateScriptDataDoubleEscaped(e); break; case lf.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: this._stateScriptDataDoubleEscapedDash(e); break; case lf.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: this._stateScriptDataDoubleEscapedDashDash(e); break; case lf.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: this._stateScriptDataDoubleEscapedLessThanSign(e); break; case lf.SCRIPT_DATA_DOUBLE_ESCAPE_END: this._stateScriptDataDoubleEscapeEnd(e); break; case lf.BEFORE_ATTRIBUTE_NAME: this._stateBeforeAttributeName(e); break; case lf.ATTRIBUTE_NAME: this._stateAttributeName(e); break; case lf.AFTER_ATTRIBUTE_NAME: this._stateAfterAttributeName(e); break; case lf.BEFORE_ATTRIBUTE_VALUE: this._stateBeforeAttributeValue(e); break; case lf.ATTRIBUTE_VALUE_DOUBLE_QUOTED: this._stateAttributeValueDoubleQuoted(e); break; case lf.ATTRIBUTE_VALUE_SINGLE_QUOTED: this._stateAttributeValueSingleQuoted(e); break; case lf.ATTRIBUTE_VALUE_UNQUOTED: this._stateAttributeValueUnquoted(e); break; case lf.AFTER_ATTRIBUTE_VALUE_QUOTED: this._stateAfterAttributeValueQuoted(e); break; case lf.SELF_CLOSING_START_TAG: this._stateSelfClosingStartTag(e); break; case lf.BOGUS_COMMENT: this._stateBogusComment(e); break; case lf.MARKUP_DECLARATION_OPEN: this._stateMarkupDeclarationOpen(e); break; case lf.COMMENT_START: this._stateCommentStart(e); break; case lf.COMMENT_START_DASH: this._stateCommentStartDash(e); break; case lf.COMMENT: this._stateComment(e); break; case lf.COMMENT_LESS_THAN_SIGN: this._stateCommentLessThanSign(e); break; case lf.COMMENT_LESS_THAN_SIGN_BANG: this._stateCommentLessThanSignBang(e); break; case lf.COMMENT_LESS_THAN_SIGN_BANG_DASH: this._stateCommentLessThanSignBangDash(e); break; case lf.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: this._stateCommentLessThanSignBangDashDash(e); break; case lf.COMMENT_END_DASH: this._stateCommentEndDash(e); break; case lf.COMMENT_END: this._stateCommentEnd(e); break; case lf.COMMENT_END_BANG: this._stateCommentEndBang(e); break; case lf.DOCTYPE: this._stateDoctype(e); break; case lf.BEFORE_DOCTYPE_NAME: this._stateBeforeDoctypeName(e); break; case lf.DOCTYPE_NAME: this._stateDoctypeName(e); break; case lf.AFTER_DOCTYPE_NAME: this._stateAfterDoctypeName(e); break; case lf.AFTER_DOCTYPE_PUBLIC_KEYWORD: this._stateAfterDoctypePublicKeyword(e); break; case lf.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: this._stateBeforeDoctypePublicIdentifier(e); break; case lf.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: this._stateDoctypePublicIdentifierDoubleQuoted(e); break; case lf.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: this._stateDoctypePublicIdentifierSingleQuoted(e); break; case lf.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: this._stateAfterDoctypePublicIdentifier(e); break; case lf.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: this._stateBetweenDoctypePublicAndSystemIdentifiers(e); break; case lf.AFTER_DOCTYPE_SYSTEM_KEYWORD: this._stateAfterDoctypeSystemKeyword(e); break; case lf.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: this._stateBeforeDoctypeSystemIdentifier(e); break; case lf.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: this._stateDoctypeSystemIdentifierDoubleQuoted(e); break; case lf.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: this._stateDoctypeSystemIdentifierSingleQuoted(e); break; case lf.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: this._stateAfterDoctypeSystemIdentifier(e); break; case lf.BOGUS_DOCTYPE: this._stateBogusDoctype(e); break; case lf.CDATA_SECTION: this._stateCdataSection(e); break; case lf.CDATA_SECTION_BRACKET: this._stateCdataSectionBracket(e); break; case lf.CDATA_SECTION_END: this._stateCdataSectionEnd(e); break; case lf.CHARACTER_REFERENCE: this._stateCharacterReference(); break; case lf.AMBIGUOUS_AMPERSAND: this._stateAmbiguousAmpersand(e); break; default: throw new Error("Unknown state") } } _stateData(e) { switch (e) { case Ep.LESS_THAN_SIGN: this.state = lf.TAG_OPEN; break; case Ep.AMPERSAND: this._startCharacterReference(); break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), this._emitCodePoint(e); break; case Ep.EOF: this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateRcdata(e) { switch (e) { case Ep.AMPERSAND: this._startCharacterReference(); break; case Ep.LESS_THAN_SIGN: this.state = lf.RCDATA_LESS_THAN_SIGN; break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), this._emitChars(gp); break; case Ep.EOF: this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateRawtext(e) { switch (e) { case Ep.LESS_THAN_SIGN: this.state = lf.RAWTEXT_LESS_THAN_SIGN; break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), this._emitChars(gp); break; case Ep.EOF: this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateScriptData(e) { switch (e) { case Ep.LESS_THAN_SIGN: this.state = lf.SCRIPT_DATA_LESS_THAN_SIGN; break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), this._emitChars(gp); break; case Ep.EOF: this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _statePlaintext(e) { switch (e) { case Ep.NULL: this._err(Cp.unexpectedNullCharacter), this._emitChars(gp); break; case Ep.EOF: this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateTagOpen(e) { if (df(e)) this._createStartTagToken(), this.state = lf.TAG_NAME, this._stateTagName(e); else switch (e) { case Ep.EXCLAMATION_MARK: this.state = lf.MARKUP_DECLARATION_OPEN; break; case Ep.SOLIDUS: this.state = lf.END_TAG_OPEN; break; case Ep.QUESTION_MARK: this._err(Cp.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = lf.BOGUS_COMMENT, this._stateBogusComment(e); break; case Ep.EOF: this._err(Cp.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken(); break; default: this._err(Cp.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = lf.DATA, this._stateData(e) } } _stateEndTagOpen(e) { if (df(e)) this._createEndTagToken(), this.state = lf.TAG_NAME, this._stateTagName(e); else switch (e) { case Ep.GREATER_THAN_SIGN: this._err(Cp.missingEndTagName), this.state = lf.DATA; break; case Ep.EOF: this._err(Cp.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken(); break; default: this._err(Cp.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = lf.BOGUS_COMMENT, this._stateBogusComment(e) } } _stateTagName(e) { const t = this.currentToken; switch (e) { case Ep.SPACE: case Ep.LINE_FEED: case Ep.TABULATION: case Ep.FORM_FEED: this.state = lf.BEFORE_ATTRIBUTE_NAME; break; case Ep.SOLIDUS: this.state = lf.SELF_CLOSING_START_TAG; break; case Ep.GREATER_THAN_SIGN: this.state = lf.DATA, this.emitCurrentTagToken(); break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), t.tagName += gp; break; case Ep.EOF: this._err(Cp.eofInTag), this._emitEOFToken(); break; default: t.tagName += String.fromCodePoint(hf(e) ? ff(e) : e) } } _stateRcdataLessThanSign(e) { e === Ep.SOLIDUS ? this.state = lf.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = lf.RCDATA, this._stateRcdata(e)) } _stateRcdataEndTagOpen(e) { df(e) ? (this.state = lf.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(e)) : (this._emitChars("</"), this.state = lf.RCDATA, this._stateRcdata(e)) } handleSpecialEndTag(e) { if (!this.preprocessor.startsWith(this.lastStartTagName, !1)) return !this._ensureHibernation(); switch (this._createEndTagToken(), this.currentToken.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) { case Ep.SPACE: case Ep.LINE_FEED: case Ep.TABULATION: case Ep.FORM_FEED: return this._advanceBy(this.lastStartTagName.length), this.state = lf.BEFORE_ATTRIBUTE_NAME, !1; case Ep.SOLIDUS: return this._advanceBy(this.lastStartTagName.length), this.state = lf.SELF_CLOSING_START_TAG, !1; case Ep.GREATER_THAN_SIGN: return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = lf.DATA, !1; default: return !this._ensureHibernation() } } _stateRcdataEndTagName(e) { this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = lf.RCDATA, this._stateRcdata(e)) } _stateRawtextLessThanSign(e) { e === Ep.SOLIDUS ? this.state = lf.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = lf.RAWTEXT, this._stateRawtext(e)) } _stateRawtextEndTagOpen(e) { df(e) ? (this.state = lf.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(e)) : (this._emitChars("</"), this.state = lf.RAWTEXT, this._stateRawtext(e)) } _stateRawtextEndTagName(e) { this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = lf.RAWTEXT, this._stateRawtext(e)) } _stateScriptDataLessThanSign(e) { switch (e) { case Ep.SOLIDUS: this.state = lf.SCRIPT_DATA_END_TAG_OPEN; break; case Ep.EXCLAMATION_MARK: this.state = lf.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!"); break; default: this._emitChars("<"), this.state = lf.SCRIPT_DATA, this._stateScriptData(e) } } _stateScriptDataEndTagOpen(e) { df(e) ? (this.state = lf.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(e)) : (this._emitChars("</"), this.state = lf.SCRIPT_DATA, this._stateScriptData(e)) } _stateScriptDataEndTagName(e) { this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = lf.SCRIPT_DATA, this._stateScriptData(e)) } _stateScriptDataEscapeStart(e) { e === Ep.HYPHEN_MINUS ? (this.state = lf.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = lf.SCRIPT_DATA, this._stateScriptData(e)) } _stateScriptDataEscapeStartDash(e) { e === Ep.HYPHEN_MINUS ? (this.state = lf.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = lf.SCRIPT_DATA, this._stateScriptData(e)) } _stateScriptDataEscaped(e) { switch (e) { case Ep.HYPHEN_MINUS: this.state = lf.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-"); break; case Ep.LESS_THAN_SIGN: this.state = lf.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN; break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), this._emitChars(gp); break; case Ep.EOF: this._err(Cp.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateScriptDataEscapedDash(e) { switch (e) { case Ep.HYPHEN_MINUS: this.state = lf.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-"); break; case Ep.LESS_THAN_SIGN: this.state = lf.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN; break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), this.state = lf.SCRIPT_DATA_ESCAPED, this._emitChars(gp); break; case Ep.EOF: this._err(Cp.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break; default: this.state = lf.SCRIPT_DATA_ESCAPED, this._emitCodePoint(e) } } _stateScriptDataEscapedDashDash(e) { switch (e) { case Ep.HYPHEN_MINUS: this._emitChars("-"); break; case Ep.LESS_THAN_SIGN: this.state = lf.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN; break; case Ep.GREATER_THAN_SIGN: this.state = lf.SCRIPT_DATA, this._emitChars(">"); break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), this.state = lf.SCRIPT_DATA_ESCAPED, this._emitChars(gp); break; case Ep.EOF: this._err(Cp.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break; default: this.state = lf.SCRIPT_DATA_ESCAPED, this._emitCodePoint(e) } } _stateScriptDataEscapedLessThanSign(e) { e === Ep.SOLIDUS ? this.state = lf.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : df(e) ? (this._emitChars("<"), this.state = lf.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(e)) : (this._emitChars("<"), this.state = lf.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e)) } _stateScriptDataEscapedEndTagOpen(e) { df(e) ? (this.state = lf.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(e)) : (this._emitChars("</"), this.state = lf.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e)) } _stateScriptDataEscapedEndTagName(e) { this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = lf.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e)) } _stateScriptDataDoubleEscapeStart(e) { if (this.preprocessor.startsWith(yp, !1) && gf(this.preprocessor.peek(6))) { this._emitCodePoint(e); for (let e = 0; e < 6; e++)this._emitCodePoint(this._consume()); this.state = lf.SCRIPT_DATA_DOUBLE_ESCAPED } else this._ensureHibernation() || (this.state = lf.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e)) } _stateScriptDataDoubleEscaped(e) { switch (e) { case Ep.HYPHEN_MINUS: this.state = lf.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-"); break; case Ep.LESS_THAN_SIGN: this.state = lf.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<"); break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), this._emitChars(gp); break; case Ep.EOF: this._err(Cp.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateScriptDataDoubleEscapedDash(e) { switch (e) { case Ep.HYPHEN_MINUS: this.state = lf.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-"); break; case Ep.LESS_THAN_SIGN: this.state = lf.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<"); break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), this.state = lf.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(gp); break; case Ep.EOF: this._err(Cp.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break; default: this.state = lf.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(e) } } _stateScriptDataDoubleEscapedDashDash(e) { switch (e) { case Ep.HYPHEN_MINUS: this._emitChars("-"); break; case Ep.LESS_THAN_SIGN: this.state = lf.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<"); break; case Ep.GREATER_THAN_SIGN: this.state = lf.SCRIPT_DATA, this._emitChars(">"); break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), this.state = lf.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(gp); break; case Ep.EOF: this._err(Cp.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break; default: this.state = lf.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(e) } } _stateScriptDataDoubleEscapedLessThanSign(e) { e === Ep.SOLIDUS ? (this.state = lf.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = lf.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(e)) } _stateScriptDataDoubleEscapeEnd(e) { if (this.preprocessor.startsWith(yp, !1) && gf(this.preprocessor.peek(6))) { this._emitCodePoint(e); for (let e = 0; e < 6; e++)this._emitCodePoint(this._consume()); this.state = lf.SCRIPT_DATA_ESCAPED } else this._ensureHibernation() || (this.state = lf.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(e)) } _stateBeforeAttributeName(e) { switch (e) { case Ep.SPACE: case Ep.LINE_FEED: case Ep.TABULATION: case Ep.FORM_FEED: break; case Ep.SOLIDUS: case Ep.GREATER_THAN_SIGN: case Ep.EOF: this.state = lf.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(e); break; case Ep.EQUALS_SIGN: this._err(Cp.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = lf.ATTRIBUTE_NAME; break; default: this._createAttr(""), this.state = lf.ATTRIBUTE_NAME, this._stateAttributeName(e) } } _stateAttributeName(e) { switch (e) { case Ep.SPACE: case Ep.LINE_FEED: case Ep.TABULATION: case Ep.FORM_FEED: case Ep.SOLIDUS: case Ep.GREATER_THAN_SIGN: case Ep.EOF: this._leaveAttrName(), this.state = lf.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(e); break; case Ep.EQUALS_SIGN: this._leaveAttrName(), this.state = lf.BEFORE_ATTRIBUTE_VALUE; break; case Ep.QUOTATION_MARK: case Ep.APOSTROPHE: case Ep.LESS_THAN_SIGN: this._err(Cp.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(e); break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), this.currentAttr.name += gp; break; default: this.currentAttr.name += String.fromCodePoint(hf(e) ? ff(e) : e) } } _stateAfterAttributeName(e) { switch (e) { case Ep.SPACE: case Ep.LINE_FEED: case Ep.TABULATION: case Ep.FORM_FEED: break; case Ep.SOLIDUS: this.state = lf.SELF_CLOSING_START_TAG; break; case Ep.EQUALS_SIGN: this.state = lf.BEFORE_ATTRIBUTE_VALUE; break; case Ep.GREATER_THAN_SIGN: this.state = lf.DATA, this.emitCurrentTagToken(); break; case Ep.EOF: this._err(Cp.eofInTag), this._emitEOFToken(); break; default: this._createAttr(""), this.state = lf.ATTRIBUTE_NAME, this._stateAttributeName(e) } } _stateBeforeAttributeValue(e) { switch (e) { case Ep.SPACE: case Ep.LINE_FEED: case Ep.TABULATION: case Ep.FORM_FEED: break; case Ep.QUOTATION_MARK: this.state = lf.ATTRIBUTE_VALUE_DOUBLE_QUOTED; break; case Ep.APOSTROPHE: this.state = lf.ATTRIBUTE_VALUE_SINGLE_QUOTED; break; case Ep.GREATER_THAN_SIGN: this._err(Cp.missingAttributeValue), this.state = lf.DATA, this.emitCurrentTagToken(); break; default: this.state = lf.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(e) } } _stateAttributeValueDoubleQuoted(e) { switch (e) { case Ep.QUOTATION_MARK: this.state = lf.AFTER_ATTRIBUTE_VALUE_QUOTED; break; case Ep.AMPERSAND: this._startCharacterReference(); break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), this.currentAttr.value += gp; break; case Ep.EOF: this._err(Cp.eofInTag), this._emitEOFToken(); break; default: this.currentAttr.value += String.fromCodePoint(e) } } _stateAttributeValueSingleQuoted(e) { switch (e) { case Ep.APOSTROPHE: this.state = lf.AFTER_ATTRIBUTE_VALUE_QUOTED; break; case Ep.AMPERSAND: this._startCharacterReference(); break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), this.currentAttr.value += gp; break; case Ep.EOF: this._err(Cp.eofInTag), this._emitEOFToken(); break; default: this.currentAttr.value += String.fromCodePoint(e) } } _stateAttributeValueUnquoted(e) { switch (e) { case Ep.SPACE: case Ep.LINE_FEED: case Ep.TABULATION: case Ep.FORM_FEED: this._leaveAttrValue(), this.state = lf.BEFORE_ATTRIBUTE_NAME; break; case Ep.AMPERSAND: this._startCharacterReference(); break; case Ep.GREATER_THAN_SIGN: this._leaveAttrValue(), this.state = lf.DATA, this.emitCurrentTagToken(); break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), this.currentAttr.value += gp; break; case Ep.QUOTATION_MARK: case Ep.APOSTROPHE: case Ep.LESS_THAN_SIGN: case Ep.EQUALS_SIGN: case Ep.GRAVE_ACCENT: this._err(Cp.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(e); break; case Ep.EOF: this._err(Cp.eofInTag), this._emitEOFToken(); break; default: this.currentAttr.value += String.fromCodePoint(e) } } _stateAfterAttributeValueQuoted(e) { switch (e) { case Ep.SPACE: case Ep.LINE_FEED: case Ep.TABULATION: case Ep.FORM_FEED: this._leaveAttrValue(), this.state = lf.BEFORE_ATTRIBUTE_NAME; break; case Ep.SOLIDUS: this._leaveAttrValue(), this.state = lf.SELF_CLOSING_START_TAG; break; case Ep.GREATER_THAN_SIGN: this._leaveAttrValue(), this.state = lf.DATA, this.emitCurrentTagToken(); break; case Ep.EOF: this._err(Cp.eofInTag), this._emitEOFToken(); break; default: this._err(Cp.missingWhitespaceBetweenAttributes), this.state = lf.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(e) } } _stateSelfClosingStartTag(e) { switch (e) { case Ep.GREATER_THAN_SIGN: this.currentToken.selfClosing = !0, this.state = lf.DATA, this.emitCurrentTagToken(); break; case Ep.EOF: this._err(Cp.eofInTag), this._emitEOFToken(); break; default: this._err(Cp.unexpectedSolidusInTag), this.state = lf.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(e) } } _stateBogusComment(e) { const t = this.currentToken; switch (e) { case Ep.GREATER_THAN_SIGN: this.state = lf.DATA, this.emitCurrentComment(t); break; case Ep.EOF: this.emitCurrentComment(t), this._emitEOFToken(); break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), t.data += gp; break; default: t.data += String.fromCodePoint(e) } } _stateMarkupDeclarationOpen(e) { this._consumeSequenceIfMatch("--", !0) ? (this._createCommentToken(3), this.state = lf.COMMENT_START) : this._consumeSequenceIfMatch(_p, !1) ? (this.currentLocation = this.getCurrentLocation(8), this.state = lf.DOCTYPE) : this._consumeSequenceIfMatch(Ap, !0) ? this.inForeignNode ? this.state = lf.CDATA_SECTION : (this._err(Cp.cdataInHtmlContent), this._createCommentToken(8), this.currentToken.data = "[CDATA[", this.state = lf.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(Cp.incorrectlyOpenedComment), this._createCommentToken(2), this.state = lf.BOGUS_COMMENT, this._stateBogusComment(e)) } _stateCommentStart(e) { switch (e) { case Ep.HYPHEN_MINUS: this.state = lf.COMMENT_START_DASH; break; case Ep.GREATER_THAN_SIGN: { this._err(Cp.abruptClosingOfEmptyComment), this.state = lf.DATA; const e = this.currentToken; this.emitCurrentComment(e); break } default: this.state = lf.COMMENT, this._stateComment(e) } } _stateCommentStartDash(e) { const t = this.currentToken; switch (e) { case Ep.HYPHEN_MINUS: this.state = lf.COMMENT_END; break; case Ep.GREATER_THAN_SIGN: this._err(Cp.abruptClosingOfEmptyComment), this.state = lf.DATA, this.emitCurrentComment(t); break; case Ep.EOF: this._err(Cp.eofInComment), this.emitCurrentComment(t), this._emitEOFToken(); break; default: t.data += "-", this.state = lf.COMMENT, this._stateComment(e) } } _stateComment(e) { const t = this.currentToken; switch (e) { case Ep.HYPHEN_MINUS: this.state = lf.COMMENT_END_DASH; break; case Ep.LESS_THAN_SIGN: t.data += "<", this.state = lf.COMMENT_LESS_THAN_SIGN; break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), t.data += gp; break; case Ep.EOF: this._err(Cp.eofInComment), this.emitCurrentComment(t), this._emitEOFToken(); break; default: t.data += String.fromCodePoint(e) } } _stateCommentLessThanSign(e) { const t = this.currentToken; switch (e) { case Ep.EXCLAMATION_MARK: t.data += "!", this.state = lf.COMMENT_LESS_THAN_SIGN_BANG; break; case Ep.LESS_THAN_SIGN: t.data += "<"; break; default: this.state = lf.COMMENT, this._stateComment(e) } } _stateCommentLessThanSignBang(e) { e === Ep.HYPHEN_MINUS ? this.state = lf.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = lf.COMMENT, this._stateComment(e)) } _stateCommentLessThanSignBangDash(e) { e === Ep.HYPHEN_MINUS ? this.state = lf.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = lf.COMMENT_END_DASH, this._stateCommentEndDash(e)) } _stateCommentLessThanSignBangDashDash(e) { e !== Ep.GREATER_THAN_SIGN && e !== Ep.EOF && this._err(Cp.nestedComment), this.state = lf.COMMENT_END, this._stateCommentEnd(e) } _stateCommentEndDash(e) { const t = this.currentToken; switch (e) { case Ep.HYPHEN_MINUS: this.state = lf.COMMENT_END; break; case Ep.EOF: this._err(Cp.eofInComment), this.emitCurrentComment(t), this._emitEOFToken(); break; default: t.data += "-", this.state = lf.COMMENT, this._stateComment(e) } } _stateCommentEnd(e) { const t = this.currentToken; switch (e) { case Ep.GREATER_THAN_SIGN: this.state = lf.DATA, this.emitCurrentComment(t); break; case Ep.EXCLAMATION_MARK: this.state = lf.COMMENT_END_BANG; break; case Ep.HYPHEN_MINUS: t.data += "-"; break; case Ep.EOF: this._err(Cp.eofInComment), this.emitCurrentComment(t), this._emitEOFToken(); break; default: t.data += "--", this.state = lf.COMMENT, this._stateComment(e) } } _stateCommentEndBang(e) { const t = this.currentToken; switch (e) { case Ep.HYPHEN_MINUS: t.data += "--!", this.state = lf.COMMENT_END_DASH; break; case Ep.GREATER_THAN_SIGN: this._err(Cp.incorrectlyClosedComment), this.state = lf.DATA, this.emitCurrentComment(t); break; case Ep.EOF: this._err(Cp.eofInComment), this.emitCurrentComment(t), this._emitEOFToken(); break; default: t.data += "--!", this.state = lf.COMMENT, this._stateComment(e) } } _stateDoctype(e) { switch (e) { case Ep.SPACE: case Ep.LINE_FEED: case Ep.TABULATION: case Ep.FORM_FEED: this.state = lf.BEFORE_DOCTYPE_NAME; break; case Ep.GREATER_THAN_SIGN: this.state = lf.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(e); break; case Ep.EOF: { this._err(Cp.eofInDoctype), this._createDoctypeToken(null); const e = this.currentToken; e.forceQuirks = !0, this.emitCurrentDoctype(e), this._emitEOFToken(); break } default: this._err(Cp.missingWhitespaceBeforeDoctypeName), this.state = lf.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(e) } } _stateBeforeDoctypeName(e) { if (hf(e)) this._createDoctypeToken(String.fromCharCode(ff(e))), this.state = lf.DOCTYPE_NAME; else switch (e) { case Ep.SPACE: case Ep.LINE_FEED: case Ep.TABULATION: case Ep.FORM_FEED: break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), this._createDoctypeToken(gp), this.state = lf.DOCTYPE_NAME; break; case Ep.GREATER_THAN_SIGN: { this._err(Cp.missingDoctypeName), this._createDoctypeToken(null); const e = this.currentToken; e.forceQuirks = !0, this.emitCurrentDoctype(e), this.state = lf.DATA; break } case Ep.EOF: { this._err(Cp.eofInDoctype), this._createDoctypeToken(null); const e = this.currentToken; e.forceQuirks = !0, this.emitCurrentDoctype(e), this._emitEOFToken(); break } default: this._createDoctypeToken(String.fromCodePoint(e)), this.state = lf.DOCTYPE_NAME } } _stateDoctypeName(e) { const t = this.currentToken; switch (e) { case Ep.SPACE: case Ep.LINE_FEED: case Ep.TABULATION: case Ep.FORM_FEED: this.state = lf.AFTER_DOCTYPE_NAME; break; case Ep.GREATER_THAN_SIGN: this.state = lf.DATA, this.emitCurrentDoctype(t); break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), t.name += gp; break; case Ep.EOF: this._err(Cp.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: t.name += String.fromCodePoint(hf(e) ? ff(e) : e) } } _stateAfterDoctypeName(e) { const t = this.currentToken; switch (e) { case Ep.SPACE: case Ep.LINE_FEED: case Ep.TABULATION: case Ep.FORM_FEED: break; case Ep.GREATER_THAN_SIGN: this.state = lf.DATA, this.emitCurrentDoctype(t); break; case Ep.EOF: this._err(Cp.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._consumeSequenceIfMatch("public", !1) ? this.state = lf.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch("system", !1) ? this.state = lf.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(Cp.invalidCharacterSequenceAfterDoctypeName), t.forceQuirks = !0, this.state = lf.BOGUS_DOCTYPE, this._stateBogusDoctype(e)) } } _stateAfterDoctypePublicKeyword(e) { const t = this.currentToken; switch (e) { case Ep.SPACE: case Ep.LINE_FEED: case Ep.TABULATION: case Ep.FORM_FEED: this.state = lf.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER; break; case Ep.QUOTATION_MARK: this._err(Cp.missingWhitespaceAfterDoctypePublicKeyword), t.publicId = "", this.state = lf.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED; break; case Ep.APOSTROPHE: this._err(Cp.missingWhitespaceAfterDoctypePublicKeyword), t.publicId = "", this.state = lf.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED; break; case Ep.GREATER_THAN_SIGN: this._err(Cp.missingDoctypePublicIdentifier), t.forceQuirks = !0, this.state = lf.DATA, this.emitCurrentDoctype(t); break; case Ep.EOF: this._err(Cp.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(Cp.missingQuoteBeforeDoctypePublicIdentifier), t.forceQuirks = !0, this.state = lf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateBeforeDoctypePublicIdentifier(e) { const t = this.currentToken; switch (e) { case Ep.SPACE: case Ep.LINE_FEED: case Ep.TABULATION: case Ep.FORM_FEED: break; case Ep.QUOTATION_MARK: t.publicId = "", this.state = lf.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED; break; case Ep.APOSTROPHE: t.publicId = "", this.state = lf.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED; break; case Ep.GREATER_THAN_SIGN: this._err(Cp.missingDoctypePublicIdentifier), t.forceQuirks = !0, this.state = lf.DATA, this.emitCurrentDoctype(t); break; case Ep.EOF: this._err(Cp.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(Cp.missingQuoteBeforeDoctypePublicIdentifier), t.forceQuirks = !0, this.state = lf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateDoctypePublicIdentifierDoubleQuoted(e) { const t = this.currentToken; switch (e) { case Ep.QUOTATION_MARK: this.state = lf.AFTER_DOCTYPE_PUBLIC_IDENTIFIER; break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), t.publicId += gp; break; case Ep.GREATER_THAN_SIGN: this._err(Cp.abruptDoctypePublicIdentifier), t.forceQuirks = !0, this.emitCurrentDoctype(t), this.state = lf.DATA; break; case Ep.EOF: this._err(Cp.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: t.publicId += String.fromCodePoint(e) } } _stateDoctypePublicIdentifierSingleQuoted(e) { const t = this.currentToken; switch (e) { case Ep.APOSTROPHE: this.state = lf.AFTER_DOCTYPE_PUBLIC_IDENTIFIER; break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), t.publicId += gp; break; case Ep.GREATER_THAN_SIGN: this._err(Cp.abruptDoctypePublicIdentifier), t.forceQuirks = !0, this.emitCurrentDoctype(t), this.state = lf.DATA; break; case Ep.EOF: this._err(Cp.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: t.publicId += String.fromCodePoint(e) } } _stateAfterDoctypePublicIdentifier(e) { const t = this.currentToken; switch (e) { case Ep.SPACE: case Ep.LINE_FEED: case Ep.TABULATION: case Ep.FORM_FEED: this.state = lf.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS; break; case Ep.GREATER_THAN_SIGN: this.state = lf.DATA, this.emitCurrentDoctype(t); break; case Ep.QUOTATION_MARK: this._err(Cp.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), t.systemId = "", this.state = lf.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break; case Ep.APOSTROPHE: this._err(Cp.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), t.systemId = "", this.state = lf.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break; case Ep.EOF: this._err(Cp.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(Cp.missingQuoteBeforeDoctypeSystemIdentifier), t.forceQuirks = !0, this.state = lf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateBetweenDoctypePublicAndSystemIdentifiers(e) { const t = this.currentToken; switch (e) { case Ep.SPACE: case Ep.LINE_FEED: case Ep.TABULATION: case Ep.FORM_FEED: break; case Ep.GREATER_THAN_SIGN: this.emitCurrentDoctype(t), this.state = lf.DATA; break; case Ep.QUOTATION_MARK: t.systemId = "", this.state = lf.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break; case Ep.APOSTROPHE: t.systemId = "", this.state = lf.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break; case Ep.EOF: this._err(Cp.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(Cp.missingQuoteBeforeDoctypeSystemIdentifier), t.forceQuirks = !0, this.state = lf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateAfterDoctypeSystemKeyword(e) { const t = this.currentToken; switch (e) { case Ep.SPACE: case Ep.LINE_FEED: case Ep.TABULATION: case Ep.FORM_FEED: this.state = lf.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER; break; case Ep.QUOTATION_MARK: this._err(Cp.missingWhitespaceAfterDoctypeSystemKeyword), t.systemId = "", this.state = lf.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break; case Ep.APOSTROPHE: this._err(Cp.missingWhitespaceAfterDoctypeSystemKeyword), t.systemId = "", this.state = lf.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break; case Ep.GREATER_THAN_SIGN: this._err(Cp.missingDoctypeSystemIdentifier), t.forceQuirks = !0, this.state = lf.DATA, this.emitCurrentDoctype(t); break; case Ep.EOF: this._err(Cp.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(Cp.missingQuoteBeforeDoctypeSystemIdentifier), t.forceQuirks = !0, this.state = lf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateBeforeDoctypeSystemIdentifier(e) { const t = this.currentToken; switch (e) { case Ep.SPACE: case Ep.LINE_FEED: case Ep.TABULATION: case Ep.FORM_FEED: break; case Ep.QUOTATION_MARK: t.systemId = "", this.state = lf.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break; case Ep.APOSTROPHE: t.systemId = "", this.state = lf.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break; case Ep.GREATER_THAN_SIGN: this._err(Cp.missingDoctypeSystemIdentifier), t.forceQuirks = !0, this.state = lf.DATA, this.emitCurrentDoctype(t); break; case Ep.EOF: this._err(Cp.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(Cp.missingQuoteBeforeDoctypeSystemIdentifier), t.forceQuirks = !0, this.state = lf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateDoctypeSystemIdentifierDoubleQuoted(e) { const t = this.currentToken; switch (e) { case Ep.QUOTATION_MARK: this.state = lf.AFTER_DOCTYPE_SYSTEM_IDENTIFIER; break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), t.systemId += gp; break; case Ep.GREATER_THAN_SIGN: this._err(Cp.abruptDoctypeSystemIdentifier), t.forceQuirks = !0, this.emitCurrentDoctype(t), this.state = lf.DATA; break; case Ep.EOF: this._err(Cp.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: t.systemId += String.fromCodePoint(e) } } _stateDoctypeSystemIdentifierSingleQuoted(e) { const t = this.currentToken; switch (e) { case Ep.APOSTROPHE: this.state = lf.AFTER_DOCTYPE_SYSTEM_IDENTIFIER; break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter), t.systemId += gp; break; case Ep.GREATER_THAN_SIGN: this._err(Cp.abruptDoctypeSystemIdentifier), t.forceQuirks = !0, this.emitCurrentDoctype(t), this.state = lf.DATA; break; case Ep.EOF: this._err(Cp.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: t.systemId += String.fromCodePoint(e) } } _stateAfterDoctypeSystemIdentifier(e) { const t = this.currentToken; switch (e) { case Ep.SPACE: case Ep.LINE_FEED: case Ep.TABULATION: case Ep.FORM_FEED: break; case Ep.GREATER_THAN_SIGN: this.emitCurrentDoctype(t), this.state = lf.DATA; break; case Ep.EOF: this._err(Cp.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(Cp.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = lf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateBogusDoctype(e) { const t = this.currentToken; switch (e) { case Ep.GREATER_THAN_SIGN: this.emitCurrentDoctype(t), this.state = lf.DATA; break; case Ep.NULL: this._err(Cp.unexpectedNullCharacter); break; case Ep.EOF: this.emitCurrentDoctype(t), this._emitEOFToken() } } _stateCdataSection(e) { switch (e) { case Ep.RIGHT_SQUARE_BRACKET: this.state = lf.CDATA_SECTION_BRACKET; break; case Ep.EOF: this._err(Cp.eofInCdata), this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateCdataSectionBracket(e) { e === Ep.RIGHT_SQUARE_BRACKET ? this.state = lf.CDATA_SECTION_END : (this._emitChars("]"), this.state = lf.CDATA_SECTION, this._stateCdataSection(e)) } _stateCdataSectionEnd(e) { switch (e) { case Ep.GREATER_THAN_SIGN: this.state = lf.DATA; break; case Ep.RIGHT_SQUARE_BRACKET: this._emitChars("]"); break; default: this._emitChars("]]"), this.state = lf.CDATA_SECTION, this._stateCdataSection(e) } } _stateCharacterReference() { let e = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos); if (e < 0) { if (!this.preprocessor.lastChunkWritten) return this.active = !1, this.preprocessor.pos = this.preprocessor.html.length - 1, this.consumedAfterSnapshot = 0, void (this.preprocessor.endOfChunkHit = !0); e = this.entityDecoder.end() } 0 === e ? (this.preprocessor.pos = this.entityStartPos, this._flushCodePointConsumedAsCharacterReference(Ep.AMPERSAND), this.state = !this._isCharacterReferenceInAttribute() && pf(this.preprocessor.peek(1)) ? lf.AMBIGUOUS_AMPERSAND : this.returnState) : this.state = this.returnState } _stateAmbiguousAmpersand(e) { pf(e) ? this._flushCodePointConsumedAsCharacterReference(e) : (e === Ep.SEMICOLON && this._err(Cp.unknownNamedCharacterReference), this.state = this.returnState, this._callState(e)) } } const Tf = new Set([Kp.DD, Kp.DT, Kp.LI, Kp.OPTGROUP, Kp.OPTION, Kp.P, Kp.RB, Kp.RP, Kp.RT, Kp.RTC]), Af = new Set([...Tf, Kp.CAPTION, Kp.COLGROUP, Kp.TBODY, Kp.TD, Kp.TFOOT, Kp.TH, Kp.THEAD, Kp.TR]), _f = new Set([Kp.APPLET, Kp.CAPTION, Kp.HTML, Kp.MARQUEE, Kp.OBJECT, Kp.TABLE, Kp.TD, Kp.TEMPLATE, Kp.TH]), yf = new Set([..._f, Kp.OL, Kp.UL]), bf = new Set([..._f, Kp.BUTTON]), Sf = new Set([Kp.ANNOTATION_XML, Kp.MI, Kp.MN, Kp.MO, Kp.MS, Kp.MTEXT]), kf = new Set([Kp.DESC, Kp.FOREIGN_OBJECT, Kp.TITLE]), Cf = new Set([Kp.TR, Kp.TEMPLATE, Kp.HTML]), Nf = new Set([Kp.TBODY, Kp.TFOOT, Kp.THEAD, Kp.TEMPLATE, Kp.HTML]), If = new Set([Kp.TABLE, Kp.TEMPLATE, Kp.HTML]), Of = new Set([Kp.TD, Kp.TH]); class xf { get currentTmplContentOrNode() { return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current } constructor(e, t, n) { this.treeAdapter = t, this.handler = n, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = Kp.UNKNOWN, this.current = e } _indexOf(e) { return this.items.lastIndexOf(e, this.stackTop) } _isInTemplate() { return this.currentTagId === Kp.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === jp.HTML } _updateCurrentElement() { this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop] } push(e, t) { this.stackTop++, this.items[this.stackTop] = e, this.current = e, this.tagIDs[this.stackTop] = t, this.currentTagId = t, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(e, t, !0) } pop() { const e = this.current; this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(e, !0) } replace(e, t) { const n = this._indexOf(e); this.items[n] = t, n === this.stackTop && (this.current = t) } insertAfter(e, t, n) { const r = this._indexOf(e) + 1; this.items.splice(r, 0, t), this.tagIDs.splice(r, 0, n), this.stackTop++, r === this.stackTop && this._updateCurrentElement(), this.current && void 0 !== this.currentTagId && this.handler.onItemPush(this.current, this.currentTagId, r === this.stackTop) } popUntilTagNamePopped(e) { let t = this.stackTop + 1; do { t = this.tagIDs.lastIndexOf(e, t - 1) } while (t > 0 && this.treeAdapter.getNamespaceURI(this.items[t]) !== jp.HTML); this.shortenToLength(Math.max(t, 0)) } shortenToLength(e) { for (; this.stackTop >= e;) { const t = this.current; this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, this.stackTop < e) } } popUntilElementPopped(e) { const t = this._indexOf(e); this.shortenToLength(Math.max(t, 0)) } popUntilPopped(e, t) { const n = this._indexOfTagNames(e, t); this.shortenToLength(Math.max(n, 0)) } popUntilNumberedHeaderPopped() { this.popUntilPopped(af, jp.HTML) } popUntilTableCellPopped() { this.popUntilPopped(Of, jp.HTML) } popAllUpToHtmlElement() { this.tmplCount = 0, this.shortenToLength(1) } _indexOfTagNames(e, t) { for (let n = this.stackTop; n >= 0; n--)if (e.has(this.tagIDs[n]) && this.treeAdapter.getNamespaceURI(this.items[n]) === t) return n; return -1 } clearBackTo(e, t) { const n = this._indexOfTagNames(e, t); this.shortenToLength(n + 1) } clearBackToTableContext() { this.clearBackTo(If, jp.HTML) } clearBackToTableBodyContext() { this.clearBackTo(Nf, jp.HTML) } clearBackToTableRowContext() { this.clearBackTo(Cf, jp.HTML) } remove(e) { const t = this._indexOf(e); t >= 0 && (t === this.stackTop ? this.pop() : (this.items.splice(t, 1), this.tagIDs.splice(t, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(e, !1))) } tryPeekProperlyNestedBodyElement() { return this.stackTop >= 1 && this.tagIDs[1] === Kp.BODY ? this.items[1] : null } contains(e) { return this._indexOf(e) > -1 } getCommonAncestor(e) { const t = this._indexOf(e) - 1; return t >= 0 ? this.items[t] : null } isRootHtmlElementCurrent() { return 0 === this.stackTop && this.tagIDs[0] === Kp.HTML } hasInDynamicScope(e, t) { for (let n = this.stackTop; n >= 0; n--) { const r = this.tagIDs[n]; switch (this.treeAdapter.getNamespaceURI(this.items[n])) { case jp.HTML: if (r === e) return !0; if (t.has(r)) return !1; break; case jp.SVG: if (kf.has(r)) return !1; break; case jp.MATHML: if (Sf.has(r)) return !1 } } return !0 } hasInScope(e) { return this.hasInDynamicScope(e, _f) } hasInListItemScope(e) { return this.hasInDynamicScope(e, yf) } hasInButtonScope(e) { return this.hasInDynamicScope(e, bf) } hasNumberedHeaderInScope() { for (let e = this.stackTop; e >= 0; e--) { const t = this.tagIDs[e]; switch (this.treeAdapter.getNamespaceURI(this.items[e])) { case jp.HTML: if (af.has(t)) return !0; if (_f.has(t)) return !1; break; case jp.SVG: if (kf.has(t)) return !1; break; case jp.MATHML: if (Sf.has(t)) return !1 } } return !0 } hasInTableScope(e) { for (let t = this.stackTop; t >= 0; t--)if (this.treeAdapter.getNamespaceURI(this.items[t]) === jp.HTML) switch (this.tagIDs[t]) { case e: return !0; case Kp.TABLE: case Kp.HTML: return !1 }return !0 } hasTableBodyContextInTableScope() { for (let e = this.stackTop; e >= 0; e--)if (this.treeAdapter.getNamespaceURI(this.items[e]) === jp.HTML) switch (this.tagIDs[e]) { case Kp.TBODY: case Kp.THEAD: case Kp.TFOOT: return !0; case Kp.TABLE: case Kp.HTML: return !1 }return !0 } hasInSelectScope(e) { for (let t = this.stackTop; t >= 0; t--)if (this.treeAdapter.getNamespaceURI(this.items[t]) === jp.HTML) switch (this.tagIDs[t]) { case e: return !0; case Kp.OPTION: case Kp.OPTGROUP: break; default: return !1 }return !0 } generateImpliedEndTags() { for (; void 0 !== this.currentTagId && Tf.has(this.currentTagId);)this.pop() } generateImpliedEndTagsThoroughly() { for (; void 0 !== this.currentTagId && Af.has(this.currentTagId);)this.pop() } generateImpliedEndTagsWithExclusion(e) { for (; void 0 !== this.currentTagId && this.currentTagId !== e && Af.has(this.currentTagId);)this.pop() } } var Rf, vf; (vf = Rf || (Rf = {}))[vf.Marker = 0] = "Marker", vf[vf.Element = 1] = "Element"; const Df = { type: Rf.Marker }; class Lf { constructor(e) { this.treeAdapter = e, this.entries = [], this.bookmark = null } _getNoahArkConditionCandidates(e, t) { const n = [], r = t.length, s = this.treeAdapter.getTagName(e), i = this.treeAdapter.getNamespaceURI(e); for (let o = 0; o < this.entries.length; o++) { const e = this.entries[o]; if (e.type === Rf.Marker) break; const { element: t } = e; if (this.treeAdapter.getTagName(t) === s && this.treeAdapter.getNamespaceURI(t) === i) { const e = this.treeAdapter.getAttrList(t); e.length === r && n.push({ idx: o, attrs: e }) } } return n } _ensureNoahArkCondition(e) { if (this.entries.length < 3) return; const t = this.treeAdapter.getAttrList(e), n = this._getNoahArkConditionCandidates(e, t); if (n.length < 3) return; const r = new Map(t.map(e => [e.name, e.value])); let s = 0; for (let i = 0; i < n.length; i++) { const e = n[i]; e.attrs.every(e => r.get(e.name) === e.value) && (s += 1, s >= 3 && this.entries.splice(e.idx, 1)) } } insertMarker() { this.entries.unshift(Df) } pushElement(e, t) { this._ensureNoahArkCondition(e), this.entries.unshift({ type: Rf.Element, element: e, token: t }) } insertElementAfterBookmark(e, t) { const n = this.entries.indexOf(this.bookmark); this.entries.splice(n, 0, { type: Rf.Element, element: e, token: t }) } removeEntry(e) { const t = this.entries.indexOf(e); -1 !== t && this.entries.splice(t, 1) } clearToLastMarker() { const e = this.entries.indexOf(Df); -1 === e ? this.entries.length = 0 : this.entries.splice(0, e + 1) } getElementEntryInScopeWithTagName(e) { const t = this.entries.find(t => t.type === Rf.Marker || this.treeAdapter.getTagName(t.element) === e); return t && t.type === Rf.Element ? t : null } getElementEntry(e) { return this.entries.find(t => t.type === Rf.Element && t.element === e) } } const Pf = { createDocument: () => ({ nodeName: "#document", mode: qp.NO_QUIRKS, childNodes: [] }), createDocumentFragment: () => ({ nodeName: "#document-fragment", childNodes: [] }), createElement: (e, t, n) => ({ nodeName: e, tagName: e, attrs: n, namespaceURI: t, childNodes: [], parentNode: null }), createCommentNode: e => ({ nodeName: "#comment", data: e, parentNode: null }), createTextNode: e => ({ nodeName: "#text", value: e, parentNode: null }), appendChild(e, t) { e.childNodes.push(t), t.parentNode = e }, insertBefore(e, t, n) { const r = e.childNodes.indexOf(n); e.childNodes.splice(r, 0, t), t.parentNode = e }, setTemplateContent(e, t) { e.content = t }, getTemplateContent: e => e.content, setDocumentType(e, t, n, r) { const s = e.childNodes.find(e => "#documentType" === e.nodeName); if (s) s.name = t, s.publicId = n, s.systemId = r; else { const s = { nodeName: "#documentType", name: t, publicId: n, systemId: r, parentNode: null }; Pf.appendChild(e, s) } }, setDocumentMode(e, t) { e.mode = t }, getDocumentMode: e => e.mode, detachNode(e) { if (e.parentNode) { const t = e.parentNode.childNodes.indexOf(e); e.parentNode.childNodes.splice(t, 1), e.parentNode = null } }, insertText(e, t) { if (e.childNodes.length > 0) { const n = e.childNodes[e.childNodes.length - 1]; if (Pf.isTextNode(n)) return void (n.value += t) } Pf.appendChild(e, Pf.createTextNode(t)) }, insertTextBefore(e, t, n) { const r = e.childNodes[e.childNodes.indexOf(n) - 1]; r && Pf.isTextNode(r) ? r.value += t : Pf.insertBefore(e, Pf.createTextNode(t), n) }, adoptAttributes(e, t) { const n = new Set(e.attrs.map(e => e.name)); for (let r = 0; r < t.length; r++)n.has(t[r].name) || e.attrs.push(t[r]) }, getFirstChild: e => e.childNodes[0], getChildNodes: e => e.childNodes, getParentNode: e => e.parentNode, getAttrList: e => e.attrs, getTagName: e => e.tagName, getNamespaceURI: e => e.namespaceURI, getTextNodeContent: e => e.value, getCommentNodeContent: e => e.data, getDocumentTypeNodeName: e => e.name, getDocumentTypeNodePublicId: e => e.publicId, getDocumentTypeNodeSystemId: e => e.systemId, isTextNode: e => "#text" === e.nodeName, isCommentNode: e => "#comment" === e.nodeName, isDocumentTypeNode: e => "#documentType" === e.nodeName, isElementNode: e => Object.prototype.hasOwnProperty.call(e, "tagName"), setNodeSourceCodeLocation(e, t) { e.sourceCodeLocation = t }, getNodeSourceCodeLocation: e => e.sourceCodeLocation, updateNodeSourceCodeLocation(e, t) { e.sourceCodeLocation = { ...e.sourceCodeLocation, ...t } } }, wf = "html", Mf = ["+//silmaril//dtd html pro v0r11 19970101//", "-//as//dtd html 3.0 aswedit + extensions//", "-//advasoft ltd//dtd html 3.0 aswedit + extensions//", "-//ietf//dtd html 2.0 level 1//", "-//ietf//dtd html 2.0 level 2//", "-//ietf//dtd html 2.0 strict level 1//", "-//ietf//dtd html 2.0 strict level 2//", "-//ietf//dtd html 2.0 strict//", "-//ietf//dtd html 2.0//", "-//ietf//dtd html 2.1e//", "-//ietf//dtd html 3.0//", "-//ietf//dtd html 3.2 final//", "-//ietf//dtd html 3.2//", "-//ietf//dtd html 3//", "-//ietf//dtd html level 0//", "-//ietf//dtd html level 1//", "-//ietf//dtd html level 2//", "-//ietf//dtd html level 3//", "-//ietf//dtd html strict level 0//", "-//ietf//dtd html strict level 1//", "-//ietf//dtd html strict level 2//", "-//ietf//dtd html strict level 3//", "-//ietf//dtd html strict//", "-//ietf//dtd html//", "-//metrius//dtd metrius presentational//", "-//microsoft//dtd internet explorer 2.0 html strict//", "-//microsoft//dtd internet explorer 2.0 html//", "-//microsoft//dtd internet explorer 2.0 tables//", "-//microsoft//dtd internet explorer 3.0 html strict//", "-//microsoft//dtd internet explorer 3.0 html//", "-//microsoft//dtd internet explorer 3.0 tables//", "-//netscape comm. corp.//dtd html//", "-//netscape comm. corp.//dtd strict html//", "-//o'reilly and associates//dtd html 2.0//", "-//o'reilly and associates//dtd html extended 1.0//", "-//o'reilly and associates//dtd html extended relaxed 1.0//", "-//sq//dtd html 2.0 hotmetal + extensions//", "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//", "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//", "-//spyglass//dtd html 2.0 extended//", "-//sun microsystems corp.//dtd hotjava html//", "-//sun microsystems corp.//dtd hotjava strict html//", "-//w3c//dtd html 3 1995-03-24//", "-//w3c//dtd html 3.2 draft//", "-//w3c//dtd html 3.2 final//", "-//w3c//dtd html 3.2//", "-//w3c//dtd html 3.2s draft//", "-//w3c//dtd html 4.0 frameset//", "-//w3c//dtd html 4.0 transitional//", "-//w3c//dtd html experimental 19960712//", "-//w3c//dtd html experimental 970421//", "-//w3c//dtd w3 html//", "-//w3o//dtd w3 html 3.0//", "-//webtechs//dtd mozilla html 2.0//", "-//webtechs//dtd mozilla html//"], Ff = [...Mf, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"], Bf = new Set(["-//w3o//dtd w3 html strict 3.0//en//", "-/w3c/dtd html 4.0 transitional/en", "html"]), Uf = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], Hf = [...Uf, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"]; function jf(e, t) { return t.some(t => e.startsWith(t)) } const Gf = new Map(["attributeName", "attributeType", "baseFrequency", "baseProfile", "calcMode", "clipPathUnits", "diffuseConstant", "edgeMode", "filterUnits", "glyphRef", "gradientTransform", "gradientUnits", "kernelMatrix", "kernelUnitLength", "keyPoints", "keySplines", "keyTimes", "lengthAdjust", "limitingConeAngle", "markerHeight", "markerUnits", "markerWidth", "maskContentUnits", "maskUnits", "numOctaves", "pathLength", "patternContentUnits", "patternTransform", "patternUnits", "pointsAtX", "pointsAtY", "pointsAtZ", "preserveAlpha", "preserveAspectRatio", "primitiveUnits", "refX", "refY", "repeatCount", "repeatDur", "requiredExtensions", "requiredFeatures", "specularConstant", "specularExponent", "spreadMethod", "startOffset", "stdDeviation", "stitchTiles", "surfaceScale", "systemLanguage", "tableValues", "targetX", "targetY", "textLength", "viewBox", "viewTarget", "xChannelSelector", "yChannelSelector", "zoomAndPan"].map(e => [e.toLowerCase(), e])), zf = new Map([["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: jp.XLINK }], ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: jp.XLINK }], ["xlink:href", { prefix: "xlink", name: "href", namespace: jp.XLINK }], ["xlink:role", { prefix: "xlink", name: "role", namespace: jp.XLINK }], ["xlink:show", { prefix: "xlink", name: "show", namespace: jp.XLINK }], ["xlink:title", { prefix: "xlink", name: "title", namespace: jp.XLINK }], ["xlink:type", { prefix: "xlink", name: "type", namespace: jp.XLINK }], ["xml:lang", { prefix: "xml", name: "lang", namespace: jp.XML }], ["xml:space", { prefix: "xml", name: "space", namespace: jp.XML }], ["xmlns", { prefix: "", name: "xmlns", namespace: jp.XMLNS }], ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: jp.XMLNS }]]), Yf = new Map(["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "textPath"].map(e => [e.toLowerCase(), e])), qf = new Set([Kp.B, Kp.BIG, Kp.BLOCKQUOTE, Kp.BODY, Kp.BR, Kp.CENTER, Kp.CODE, Kp.DD, Kp.DIV, Kp.DL, Kp.DT, Kp.EM, Kp.EMBED, Kp.H1, Kp.H2, Kp.H3, Kp.H4, Kp.H5, Kp.H6, Kp.HEAD, Kp.HR, Kp.I, Kp.IMG, Kp.LI, Kp.LISTING, Kp.MENU, Kp.META, Kp.NOBR, Kp.OL, Kp.P, Kp.PRE, Kp.RUBY, Kp.S, Kp.SMALL, Kp.SPAN, Kp.STRONG, Kp.STRIKE, Kp.SUB, Kp.SUP, Kp.TABLE, Kp.TT, Kp.U, Kp.UL, Kp.VAR]); function Vf(e) { for (let t = 0; t < e.attrs.length; t++)if ("definitionurl" === e.attrs[t].name) { e.attrs[t].name = "definitionURL"; break } } function $f(e) { for (let t = 0; t < e.attrs.length; t++) { const n = Gf.get(e.attrs[t].name); null != n && (e.attrs[t].name = n) } } function Wf(e) { for (let t = 0; t < e.attrs.length; t++) { const n = zf.get(e.attrs[t].name); n && (e.attrs[t].prefix = n.prefix, e.attrs[t].name = n.name, e.attrs[t].namespace = n.namespace) } } var Kf, Qf; (Qf = Kf || (Kf = {}))[Qf.INITIAL = 0] = "INITIAL", Qf[Qf.BEFORE_HTML = 1] = "BEFORE_HTML", Qf[Qf.BEFORE_HEAD = 2] = "BEFORE_HEAD", Qf[Qf.IN_HEAD = 3] = "IN_HEAD", Qf[Qf.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", Qf[Qf.AFTER_HEAD = 5] = "AFTER_HEAD", Qf[Qf.IN_BODY = 6] = "IN_BODY", Qf[Qf.TEXT = 7] = "TEXT", Qf[Qf.IN_TABLE = 8] = "IN_TABLE", Qf[Qf.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", Qf[Qf.IN_CAPTION = 10] = "IN_CAPTION", Qf[Qf.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", Qf[Qf.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", Qf[Qf.IN_ROW = 13] = "IN_ROW", Qf[Qf.IN_CELL = 14] = "IN_CELL", Qf[Qf.IN_SELECT = 15] = "IN_SELECT", Qf[Qf.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", Qf[Qf.IN_TEMPLATE = 17] = "IN_TEMPLATE", Qf[Qf.AFTER_BODY = 18] = "AFTER_BODY", Qf[Qf.IN_FRAMESET = 19] = "IN_FRAMESET", Qf[Qf.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", Qf[Qf.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", Qf[Qf.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET"; const Xf = { startLine: -1, startCol: -1, startOffset: -1, endLine: -1, endCol: -1, endOffset: -1 }, Jf = new Set([Kp.TABLE, Kp.TBODY, Kp.TFOOT, Kp.THEAD, Kp.TR]), Zf = { scriptingEnabled: !0, sourceCodeLocationInfo: !1, treeAdapter: Pf, onParseError: null }; class em { constructor(e, t, n = null, r = null) { this.fragmentContext = n, this.scriptHandler = r, this.currentToken = null, this.stopped = !1, this.insertionMode = Kf.INITIAL, this.originalInsertionMode = Kf.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = { ...Zf, ...e }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = null != t ? t : this.treeAdapter.createDocument(), this.tokenizer = new Ef(this.options, this), this.activeFormattingElements = new Lf(this.treeAdapter), this.fragmentContextID = n ? rf(this.treeAdapter.getTagName(n)) : Kp.UNKNOWN, this._setContextModes(null != n ? n : this.document, this.fragmentContextID), this.openElements = new xf(this.document, this.treeAdapter, this) } static parse(e, t) { const n = new this(t); return n.tokenizer.write(e, !0), n.document } static getFragmentParser(e, t) { const n = { ...Zf, ...t }; null != e || (e = n.treeAdapter.createElement($p.TEMPLATE, jp.HTML, [])); const r = n.treeAdapter.createElement("documentmock", jp.HTML, []), s = new this(n, r, e); return s.fragmentContextID === Kp.TEMPLATE && s.tmplInsertionModeStack.unshift(Kf.IN_TEMPLATE), s._initTokenizerForFragmentParsing(), s._insertFakeRootElement(), s._resetInsertionMode(), s._findFormInFragmentContext(), s } getFragment() { const e = this.treeAdapter.getFirstChild(this.document), t = this.treeAdapter.createDocumentFragment(); return this._adoptNodes(e, t), t } _err(e, t, n) { var r; if (!this.onParseError) return; const s = null !== (r = e.location) && void 0 !== r ? r : Xf, i = { code: t, startLine: s.startLine, startCol: s.startCol, startOffset: s.startOffset, endLine: n ? s.startLine : s.endLine, endCol: n ? s.startCol : s.endCol, endOffset: n ? s.startOffset : s.endOffset }; this.onParseError(i) } onItemPush(e, t, n) { var r, s; null === (s = (r = this.treeAdapter).onItemPush) || void 0 === s || s.call(r, e), n && this.openElements.stackTop > 0 && this._setContextModes(e, t) } onItemPop(e, t) { var n, r; if (this.options.sourceCodeLocationInfo && this._setEndLocation(e, this.currentToken), null === (r = (n = this.treeAdapter).onItemPop) || void 0 === r || r.call(n, e, this.openElements.current), t) { let e, t; 0 === this.openElements.stackTop && this.fragmentContext ? (e = this.fragmentContext, t = this.fragmentContextID) : ({ current: e, currentTagId: t } = this.openElements), this._setContextModes(e, t) } } _setContextModes(e, t) { const n = e === this.document || e && this.treeAdapter.getNamespaceURI(e) === jp.HTML; this.currentNotInHTML = !n, this.tokenizer.inForeignNode = !n && void 0 !== e && void 0 !== t && !this._isIntegrationPoint(t, e) } _switchToTextParsing(e, t) { this._insertElement(e, jp.HTML), this.tokenizer.state = t, this.originalInsertionMode = this.insertionMode, this.insertionMode = Kf.TEXT } switchToPlaintextParsing() { this.insertionMode = Kf.TEXT, this.originalInsertionMode = Kf.IN_BODY, this.tokenizer.state = uf.PLAINTEXT } _getAdjustedCurrentElement() { return 0 === this.openElements.stackTop && this.fragmentContext ? this.fragmentContext : this.openElements.current } _findFormInFragmentContext() { let e = this.fragmentContext; for (; e;) { if (this.treeAdapter.getTagName(e) === $p.FORM) { this.formElement = e; break } e = this.treeAdapter.getParentNode(e) } } _initTokenizerForFragmentParsing() { if (this.fragmentContext && this.treeAdapter.getNamespaceURI(this.fragmentContext) === jp.HTML) switch (this.fragmentContextID) { case Kp.TITLE: case Kp.TEXTAREA: this.tokenizer.state = uf.RCDATA; break; case Kp.STYLE: case Kp.XMP: case Kp.IFRAME: case Kp.NOEMBED: case Kp.NOFRAMES: case Kp.NOSCRIPT: this.tokenizer.state = uf.RAWTEXT; break; case Kp.SCRIPT: this.tokenizer.state = uf.SCRIPT_DATA; break; case Kp.PLAINTEXT: this.tokenizer.state = uf.PLAINTEXT } } _setDocumentType(e) { const t = e.name || "", n = e.publicId || "", r = e.systemId || ""; if (this.treeAdapter.setDocumentType(this.document, t, n, r), e.location) { const t = this.treeAdapter.getChildNodes(this.document).find(e => this.treeAdapter.isDocumentTypeNode(e)); t && this.treeAdapter.setNodeSourceCodeLocation(t, e.location) } } _attachElementToTree(e, t) { if (this.options.sourceCodeLocationInfo) { const n = t && { ...t, startTag: t }; this.treeAdapter.setNodeSourceCodeLocation(e, n) } if (this._shouldFosterParentOnInsertion()) this._fosterParentElement(e); else { const t = this.openElements.currentTmplContentOrNode; this.treeAdapter.appendChild(null != t ? t : this.document, e) } } _appendElement(e, t) { const n = this.treeAdapter.createElement(e.tagName, t, e.attrs); this._attachElementToTree(n, e.location) } _insertElement(e, t) { const n = this.treeAdapter.createElement(e.tagName, t, e.attrs); this._attachElementToTree(n, e.location), this.openElements.push(n, e.tagID) } _insertFakeElement(e, t) { const n = this.treeAdapter.createElement(e, jp.HTML, []); this._attachElementToTree(n, null), this.openElements.push(n, t) } _insertTemplate(e) { const t = this.treeAdapter.createElement(e.tagName, jp.HTML, e.attrs), n = this.treeAdapter.createDocumentFragment(); this.treeAdapter.setTemplateContent(t, n), this._attachElementToTree(t, e.location), this.openElements.push(t, e.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(n, null) } _insertFakeRootElement() { const e = this.treeAdapter.createElement($p.HTML, jp.HTML, []); this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(e, null), this.treeAdapter.appendChild(this.openElements.current, e), this.openElements.push(e, Kp.HTML) } _appendCommentNode(e, t) { const n = this.treeAdapter.createCommentNode(e.data); this.treeAdapter.appendChild(t, n), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(n, e.location) } _insertCharacters(e) { let t, n; if (this._shouldFosterParentOnInsertion() ? (({ parent: t, beforeElement: n } = this._findFosterParentingLocation()), n ? this.treeAdapter.insertTextBefore(t, e.chars, n) : this.treeAdapter.insertText(t, e.chars)) : (t = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(t, e.chars)), !e.location) return; const r = this.treeAdapter.getChildNodes(t), s = n ? r.lastIndexOf(n) : r.length, i = r[s - 1]; if (this.treeAdapter.getNodeSourceCodeLocation(i)) { const { endLine: t, endCol: n, endOffset: r } = e.location; this.treeAdapter.updateNodeSourceCodeLocation(i, { endLine: t, endCol: n, endOffset: r }) } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(i, e.location) } _adoptNodes(e, t) { for (let n = this.treeAdapter.getFirstChild(e); n; n = this.treeAdapter.getFirstChild(e))this.treeAdapter.detachNode(n), this.treeAdapter.appendChild(t, n) } _setEndLocation(e, t) { if (this.treeAdapter.getNodeSourceCodeLocation(e) && t.location) { const n = t.location, r = this.treeAdapter.getTagName(e), s = t.type === Ip.END_TAG && r === t.tagName ? { endTag: { ...n }, endLine: n.endLine, endCol: n.endCol, endOffset: n.endOffset } : { endLine: n.startLine, endCol: n.startCol, endOffset: n.startOffset }; this.treeAdapter.updateNodeSourceCodeLocation(e, s) } } shouldProcessStartTagTokenInForeignContent(e) { if (!this.currentNotInHTML) return !1; let t, n; return 0 === this.openElements.stackTop && this.fragmentContext ? (t = this.fragmentContext, n = this.fragmentContextID) : ({ current: t, currentTagId: n } = this.openElements), (e.tagID !== Kp.SVG || this.treeAdapter.getTagName(t) !== $p.ANNOTATION_XML || this.treeAdapter.getNamespaceURI(t) !== jp.MATHML) && (this.tokenizer.inForeignNode || (e.tagID === Kp.MGLYPH || e.tagID === Kp.MALIGNMARK) && void 0 !== n && !this._isIntegrationPoint(n, t, jp.HTML)) } _processToken(e) { switch (e.type) { case Ip.CHARACTER: this.onCharacter(e); break; case Ip.NULL_CHARACTER: this.onNullCharacter(e); break; case Ip.COMMENT: this.onComment(e); break; case Ip.DOCTYPE: this.onDoctype(e); break; case Ip.START_TAG: this._processStartTag(e); break; case Ip.END_TAG: this.onEndTag(e); break; case Ip.EOF: this.onEof(e); break; case Ip.WHITESPACE_CHARACTER: this.onWhitespaceCharacter(e) } } _isIntegrationPoint(e, t, n) { return function (e, t, n, r) { return (!r || r === jp.HTML) && function (e, t, n) { if (t === jp.MATHML && e === Kp.ANNOTATION_XML) for (let r = 0; r < n.length; r++)if (n[r].name === zp.ENCODING) { const e = n[r].value.toLowerCase(); return "text/html" === e || "application/xhtml+xml" === e } return t === jp.SVG && (e === Kp.FOREIGN_OBJECT || e === Kp.DESC || e === Kp.TITLE) }(e, t, n) || (!r || r === jp.MATHML) && function (e, t) { return t === jp.MATHML && (e === Kp.MI || e === Kp.MO || e === Kp.MN || e === Kp.MS || e === Kp.MTEXT) }(e, t) }(e, this.treeAdapter.getNamespaceURI(t), this.treeAdapter.getAttrList(t), n) } _reconstructActiveFormattingElements() { const e = this.activeFormattingElements.entries.length; if (e) { const t = this.activeFormattingElements.entries.findIndex(e => e.type === Rf.Marker || this.openElements.contains(e.element)); for (let n = -1 === t ? e - 1 : t - 1; n >= 0; n--) { const e = this.activeFormattingElements.entries[n]; this._insertElement(e.token, this.treeAdapter.getNamespaceURI(e.element)), e.element = this.openElements.current } } } _closeTableCell() { this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = Kf.IN_ROW } _closePElement() { this.openElements.generateImpliedEndTagsWithExclusion(Kp.P), this.openElements.popUntilTagNamePopped(Kp.P) } _resetInsertionMode() { for (let e = this.openElements.stackTop; e >= 0; e--)switch (0 === e && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[e]) { case Kp.TR: return void (this.insertionMode = Kf.IN_ROW); case Kp.TBODY: case Kp.THEAD: case Kp.TFOOT: return void (this.insertionMode = Kf.IN_TABLE_BODY); case Kp.CAPTION: return void (this.insertionMode = Kf.IN_CAPTION); case Kp.COLGROUP: return void (this.insertionMode = Kf.IN_COLUMN_GROUP); case Kp.TABLE: return void (this.insertionMode = Kf.IN_TABLE); case Kp.BODY: return void (this.insertionMode = Kf.IN_BODY); case Kp.FRAMESET: return void (this.insertionMode = Kf.IN_FRAMESET); case Kp.SELECT: return void this._resetInsertionModeForSelect(e); case Kp.TEMPLATE: return void (this.insertionMode = this.tmplInsertionModeStack[0]); case Kp.HTML: return void (this.insertionMode = this.headElement ? Kf.AFTER_HEAD : Kf.BEFORE_HEAD); case Kp.TD: case Kp.TH: if (e > 0) return void (this.insertionMode = Kf.IN_CELL); break; case Kp.HEAD: if (e > 0) return void (this.insertionMode = Kf.IN_HEAD) }this.insertionMode = Kf.IN_BODY } _resetInsertionModeForSelect(e) { if (e > 0) for (let t = e - 1; t > 0; t--) { const e = this.openElements.tagIDs[t]; if (e === Kp.TEMPLATE) break; if (e === Kp.TABLE) return void (this.insertionMode = Kf.IN_SELECT_IN_TABLE) } this.insertionMode = Kf.IN_SELECT } _isElementCausesFosterParenting(e) { return Jf.has(e) } _shouldFosterParentOnInsertion() { return this.fosterParentingEnabled && void 0 !== this.openElements.currentTagId && this._isElementCausesFosterParenting(this.openElements.currentTagId) } _findFosterParentingLocation() { for (let e = this.openElements.stackTop; e >= 0; e--) { const t = this.openElements.items[e]; switch (this.openElements.tagIDs[e]) { case Kp.TEMPLATE: if (this.treeAdapter.getNamespaceURI(t) === jp.HTML) return { parent: this.treeAdapter.getTemplateContent(t), beforeElement: null }; break; case Kp.TABLE: { const n = this.treeAdapter.getParentNode(t); return n ? { parent: n, beforeElement: t } : { parent: this.openElements.items[e - 1], beforeElement: null } } } } return { parent: this.openElements.items[0], beforeElement: null } } _fosterParentElement(e) { const t = this._findFosterParentingLocation(); t.beforeElement ? this.treeAdapter.insertBefore(t.parent, e, t.beforeElement) : this.treeAdapter.appendChild(t.parent, e) } _isSpecialElement(e, t) { const n = this.treeAdapter.getNamespaceURI(e); return of[n].has(t) } onCharacter(e) { if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) !function (e, t) { e._insertCharacters(t), e.framesetOk = !1 }(this, e); else switch (this.insertionMode) { case Kf.INITIAL: um(this, e); break; case Kf.BEFORE_HTML: hm(this, e); break; case Kf.BEFORE_HEAD: dm(this, e); break; case Kf.IN_HEAD: mm(this, e); break; case Kf.IN_HEAD_NO_SCRIPT: gm(this, e); break; case Kf.AFTER_HEAD: Em(this, e); break; case Kf.IN_BODY: case Kf.IN_CAPTION: case Kf.IN_CELL: case Kf.IN_TEMPLATE: _m(this, e); break; case Kf.TEXT: case Kf.IN_SELECT: case Kf.IN_SELECT_IN_TABLE: this._insertCharacters(e); break; case Kf.IN_TABLE: case Kf.IN_TABLE_BODY: case Kf.IN_ROW: xm(this, e); break; case Kf.IN_TABLE_TEXT: Pm(this, e); break; case Kf.IN_COLUMN_GROUP: Bm(this, e); break; case Kf.AFTER_BODY: $m(this, e); break; case Kf.AFTER_AFTER_BODY: Wm(this, e) } } onNullCharacter(e) { if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) !function (e, t) { t.chars = gp, e._insertCharacters(t) }(this, e); else switch (this.insertionMode) { case Kf.INITIAL: um(this, e); break; case Kf.BEFORE_HTML: hm(this, e); break; case Kf.BEFORE_HEAD: dm(this, e); break; case Kf.IN_HEAD: mm(this, e); break; case Kf.IN_HEAD_NO_SCRIPT: gm(this, e); break; case Kf.AFTER_HEAD: Em(this, e); break; case Kf.TEXT: this._insertCharacters(e); break; case Kf.IN_TABLE: case Kf.IN_TABLE_BODY: case Kf.IN_ROW: xm(this, e); break; case Kf.IN_COLUMN_GROUP: Bm(this, e); break; case Kf.AFTER_BODY: $m(this, e); break; case Kf.AFTER_AFTER_BODY: Wm(this, e) } } onComment(e) { if (this.skipNextNewLine = !1, this.currentNotInHTML) lm(this, e); else switch (this.insertionMode) { case Kf.INITIAL: case Kf.BEFORE_HTML: case Kf.BEFORE_HEAD: case Kf.IN_HEAD: case Kf.IN_HEAD_NO_SCRIPT: case Kf.AFTER_HEAD: case Kf.IN_BODY: case Kf.IN_TABLE: case Kf.IN_CAPTION: case Kf.IN_COLUMN_GROUP: case Kf.IN_TABLE_BODY: case Kf.IN_ROW: case Kf.IN_CELL: case Kf.IN_SELECT: case Kf.IN_SELECT_IN_TABLE: case Kf.IN_TEMPLATE: case Kf.IN_FRAMESET: case Kf.AFTER_FRAMESET: lm(this, e); break; case Kf.IN_TABLE_TEXT: wm(this, e); break; case Kf.AFTER_BODY: !function (e, t) { e._appendCommentNode(t, e.openElements.items[0]) }(this, e); break; case Kf.AFTER_AFTER_BODY: case Kf.AFTER_AFTER_FRAMESET: !function (e, t) { e._appendCommentNode(t, e.document) }(this, e) } } onDoctype(e) { switch (this.skipNextNewLine = !1, this.insertionMode) { case Kf.INITIAL: !function (e, t) { e._setDocumentType(t); const n = t.forceQuirks ? qp.QUIRKS : function (e) { if (e.name !== wf) return qp.QUIRKS; const { systemId: t } = e; if (t && "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd" === t.toLowerCase()) return qp.QUIRKS; let { publicId: n } = e; if (null !== n) { if (n = n.toLowerCase(), Bf.has(n)) return qp.QUIRKS; let e = null === t ? Ff : Mf; if (jf(n, e)) return qp.QUIRKS; if (e = null === t ? Uf : Hf, jf(n, e)) return qp.LIMITED_QUIRKS } return qp.NO_QUIRKS }(t); (function (e) { return e.name === wf && null === e.publicId && (null === e.systemId || "about:legacy-compat" === e.systemId) })(t) || e._err(t, Cp.nonConformingDoctype), e.treeAdapter.setDocumentMode(e.document, n), e.insertionMode = Kf.BEFORE_HTML }(this, e); break; case Kf.BEFORE_HEAD: case Kf.IN_HEAD: case Kf.IN_HEAD_NO_SCRIPT: case Kf.AFTER_HEAD: this._err(e, Cp.misplacedDoctype); break; case Kf.IN_TABLE_TEXT: wm(this, e) } } onStartTag(e) { this.skipNextNewLine = !1, this.currentToken = e, this._processStartTag(e), e.selfClosing && !e.ackSelfClosing && this._err(e, Cp.nonVoidHtmlElementStartTagWithTrailingSolidus) } _processStartTag(e) { this.shouldProcessStartTagTokenInForeignContent(e) ? function (e, t) { if (function (e) { const t = e.tagID; return t === Kp.FONT && e.attrs.some(({ name: e }) => e === zp.COLOR || e === zp.SIZE || e === zp.FACE) || qf.has(t) }(t)) Km(e), e._startTagOutsideForeignContent(t); else { const n = e._getAdjustedCurrentElement(), r = e.treeAdapter.getNamespaceURI(n); r === jp.MATHML ? Vf(t) : r === jp.SVG && (function (e) { const t = Yf.get(e.tagName); null != t && (e.tagName = t, e.tagID = rf(e.tagName)) }(t), $f(t)), Wf(t), t.selfClosing ? e._appendElement(t, r) : e._insertElement(t, r), t.ackSelfClosing = !0 } }(this, e) : this._startTagOutsideForeignContent(e) } _startTagOutsideForeignContent(e) { switch (this.insertionMode) { case Kf.INITIAL: um(this, e); break; case Kf.BEFORE_HTML: !function (e, t) { t.tagID === Kp.HTML ? (e._insertElement(t, jp.HTML), e.insertionMode = Kf.BEFORE_HEAD) : hm(e, t) }(this, e); break; case Kf.BEFORE_HEAD: !function (e, t) { switch (t.tagID) { case Kp.HTML: Cm(e, t); break; case Kp.HEAD: e._insertElement(t, jp.HTML), e.headElement = e.openElements.current, e.insertionMode = Kf.IN_HEAD; break; default: dm(e, t) } }(this, e); break; case Kf.IN_HEAD: pm(this, e); break; case Kf.IN_HEAD_NO_SCRIPT: !function (e, t) { switch (t.tagID) { case Kp.HTML: Cm(e, t); break; case Kp.BASEFONT: case Kp.BGSOUND: case Kp.HEAD: case Kp.LINK: case Kp.META: case Kp.NOFRAMES: case Kp.STYLE: pm(e, t); break; case Kp.NOSCRIPT: e._err(t, Cp.nestedNoscriptInHead); break; default: gm(e, t) } }(this, e); break; case Kf.AFTER_HEAD: !function (e, t) { switch (t.tagID) { case Kp.HTML: Cm(e, t); break; case Kp.BODY: e._insertElement(t, jp.HTML), e.framesetOk = !1, e.insertionMode = Kf.IN_BODY; break; case Kp.FRAMESET: e._insertElement(t, jp.HTML), e.insertionMode = Kf.IN_FRAMESET; break; case Kp.BASE: case Kp.BASEFONT: case Kp.BGSOUND: case Kp.LINK: case Kp.META: case Kp.NOFRAMES: case Kp.SCRIPT: case Kp.STYLE: case Kp.TEMPLATE: case Kp.TITLE: e._err(t, Cp.abandonedHeadElementChild), e.openElements.push(e.headElement, Kp.HEAD), pm(e, t), e.openElements.remove(e.headElement); break; case Kp.HEAD: e._err(t, Cp.misplacedStartTagForHeadElement); break; default: Em(e, t) } }(this, e); break; case Kf.IN_BODY: Cm(this, e); break; case Kf.IN_TABLE: Rm(this, e); break; case Kf.IN_TABLE_TEXT: wm(this, e); break; case Kf.IN_CAPTION: !function (e, t) { const n = t.tagID; Mm.has(n) ? e.openElements.hasInTableScope(Kp.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(Kp.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = Kf.IN_TABLE, Rm(e, t)) : Cm(e, t) }(this, e); break; case Kf.IN_COLUMN_GROUP: Fm(this, e); break; case Kf.IN_TABLE_BODY: Um(this, e); break; case Kf.IN_ROW: jm(this, e); break; case Kf.IN_CELL: !function (e, t) { const n = t.tagID; Mm.has(n) ? (e.openElements.hasInTableScope(Kp.TD) || e.openElements.hasInTableScope(Kp.TH)) && (e._closeTableCell(), jm(e, t)) : Cm(e, t) }(this, e); break; case Kf.IN_SELECT: zm(this, e); break; case Kf.IN_SELECT_IN_TABLE: !function (e, t) { const n = t.tagID; n === Kp.CAPTION || n === Kp.TABLE || n === Kp.TBODY || n === Kp.TFOOT || n === Kp.THEAD || n === Kp.TR || n === Kp.TD || n === Kp.TH ? (e.openElements.popUntilTagNamePopped(Kp.SELECT), e._resetInsertionMode(), e._processStartTag(t)) : zm(e, t) }(this, e); break; case Kf.IN_TEMPLATE: !function (e, t) { switch (t.tagID) { case Kp.BASE: case Kp.BASEFONT: case Kp.BGSOUND: case Kp.LINK: case Kp.META: case Kp.NOFRAMES: case Kp.SCRIPT: case Kp.STYLE: case Kp.TEMPLATE: case Kp.TITLE: pm(e, t); break; case Kp.CAPTION: case Kp.COLGROUP: case Kp.TBODY: case Kp.TFOOT: case Kp.THEAD: e.tmplInsertionModeStack[0] = Kf.IN_TABLE, e.insertionMode = Kf.IN_TABLE, Rm(e, t); break; case Kp.COL: e.tmplInsertionModeStack[0] = Kf.IN_COLUMN_GROUP, e.insertionMode = Kf.IN_COLUMN_GROUP, Fm(e, t); break; case Kp.TR: e.tmplInsertionModeStack[0] = Kf.IN_TABLE_BODY, e.insertionMode = Kf.IN_TABLE_BODY, Um(e, t); break; case Kp.TD: case Kp.TH: e.tmplInsertionModeStack[0] = Kf.IN_ROW, e.insertionMode = Kf.IN_ROW, jm(e, t); break; default: e.tmplInsertionModeStack[0] = Kf.IN_BODY, e.insertionMode = Kf.IN_BODY, Cm(e, t) } }(this, e); break; case Kf.AFTER_BODY: !function (e, t) { t.tagID === Kp.HTML ? Cm(e, t) : $m(e, t) }(this, e); break; case Kf.IN_FRAMESET: !function (e, t) { switch (t.tagID) { case Kp.HTML: Cm(e, t); break; case Kp.FRAMESET: e._insertElement(t, jp.HTML); break; case Kp.FRAME: e._appendElement(t, jp.HTML), t.ackSelfClosing = !0; break; case Kp.NOFRAMES: pm(e, t) } }(this, e); break; case Kf.AFTER_FRAMESET: !function (e, t) { switch (t.tagID) { case Kp.HTML: Cm(e, t); break; case Kp.NOFRAMES: pm(e, t) } }(this, e); break; case Kf.AFTER_AFTER_BODY: !function (e, t) { t.tagID === Kp.HTML ? Cm(e, t) : Wm(e, t) }(this, e); break; case Kf.AFTER_AFTER_FRAMESET: !function (e, t) { switch (t.tagID) { case Kp.HTML: Cm(e, t); break; case Kp.NOFRAMES: pm(e, t) } }(this, e) } } onEndTag(e) { this.skipNextNewLine = !1, this.currentToken = e, this.currentNotInHTML ? function (e, t) { if (t.tagID === Kp.P || t.tagID === Kp.BR) return Km(e), void e._endTagOutsideForeignContent(t); for (let n = e.openElements.stackTop; n > 0; n--) { const r = e.openElements.items[n]; if (e.treeAdapter.getNamespaceURI(r) === jp.HTML) { e._endTagOutsideForeignContent(t); break } const s = e.treeAdapter.getTagName(r); if (s.toLowerCase() === t.tagName) { t.tagName = s, e.openElements.shortenToLength(n); break } } }(this, e) : this._endTagOutsideForeignContent(e) } _endTagOutsideForeignContent(e) { switch (this.insertionMode) { case Kf.INITIAL: um(this, e); break; case Kf.BEFORE_HTML: !function (e, t) { const n = t.tagID; n !== Kp.HTML && n !== Kp.HEAD && n !== Kp.BODY && n !== Kp.BR || hm(e, t) }(this, e); break; case Kf.BEFORE_HEAD: !function (e, t) { const n = t.tagID; n === Kp.HEAD || n === Kp.BODY || n === Kp.HTML || n === Kp.BR ? dm(e, t) : e._err(t, Cp.endTagWithoutMatchingOpenElement) }(this, e); break; case Kf.IN_HEAD: !function (e, t) { switch (t.tagID) { case Kp.HEAD: e.openElements.pop(), e.insertionMode = Kf.AFTER_HEAD; break; case Kp.BODY: case Kp.BR: case Kp.HTML: mm(e, t); break; case Kp.TEMPLATE: fm(e, t); break; default: e._err(t, Cp.endTagWithoutMatchingOpenElement) } }(this, e); break; case Kf.IN_HEAD_NO_SCRIPT: !function (e, t) { switch (t.tagID) { case Kp.NOSCRIPT: e.openElements.pop(), e.insertionMode = Kf.IN_HEAD; break; case Kp.BR: gm(e, t); break; default: e._err(t, Cp.endTagWithoutMatchingOpenElement) } }(this, e); break; case Kf.AFTER_HEAD: !function (e, t) { switch (t.tagID) { case Kp.BODY: case Kp.HTML: case Kp.BR: Em(e, t); break; case Kp.TEMPLATE: fm(e, t); break; default: e._err(t, Cp.endTagWithoutMatchingOpenElement) } }(this, e); break; case Kf.IN_BODY: Im(this, e); break; case Kf.TEXT: !function (e, t) { var n; t.tagID === Kp.SCRIPT && (null === (n = e.scriptHandler) || void 0 === n || n.call(e, e.openElements.current)), e.openElements.pop(), e.insertionMode = e.originalInsertionMode }(this, e); break; case Kf.IN_TABLE: vm(this, e); break; case Kf.IN_TABLE_TEXT: wm(this, e); break; case Kf.IN_CAPTION: !function (e, t) { const n = t.tagID; switch (n) { case Kp.CAPTION: case Kp.TABLE: e.openElements.hasInTableScope(Kp.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(Kp.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = Kf.IN_TABLE, n === Kp.TABLE && vm(e, t)); break; case Kp.BODY: case Kp.COL: case Kp.COLGROUP: case Kp.HTML: case Kp.TBODY: case Kp.TD: case Kp.TFOOT: case Kp.TH: case Kp.THEAD: case Kp.TR: break; default: Im(e, t) } }(this, e); break; case Kf.IN_COLUMN_GROUP: !function (e, t) { switch (t.tagID) { case Kp.COLGROUP: e.openElements.currentTagId === Kp.COLGROUP && (e.openElements.pop(), e.insertionMode = Kf.IN_TABLE); break; case Kp.TEMPLATE: fm(e, t); break; case Kp.COL: break; default: Bm(e, t) } }(this, e); break; case Kf.IN_TABLE_BODY: Hm(this, e); break; case Kf.IN_ROW: Gm(this, e); break; case Kf.IN_CELL: !function (e, t) { const n = t.tagID; switch (n) { case Kp.TD: case Kp.TH: e.openElements.hasInTableScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = Kf.IN_ROW); break; case Kp.TABLE: case Kp.TBODY: case Kp.TFOOT: case Kp.THEAD: case Kp.TR: e.openElements.hasInTableScope(n) && (e._closeTableCell(), Gm(e, t)); break; case Kp.BODY: case Kp.CAPTION: case Kp.COL: case Kp.COLGROUP: case Kp.HTML: break; default: Im(e, t) } }(this, e); break; case Kf.IN_SELECT: Ym(this, e); break; case Kf.IN_SELECT_IN_TABLE: !function (e, t) { const n = t.tagID; n === Kp.CAPTION || n === Kp.TABLE || n === Kp.TBODY || n === Kp.TFOOT || n === Kp.THEAD || n === Kp.TR || n === Kp.TD || n === Kp.TH ? e.openElements.hasInTableScope(n) && (e.openElements.popUntilTagNamePopped(Kp.SELECT), e._resetInsertionMode(), e.onEndTag(t)) : Ym(e, t) }(this, e); break; case Kf.IN_TEMPLATE: !function (e, t) { t.tagID === Kp.TEMPLATE && fm(e, t) }(this, e); break; case Kf.AFTER_BODY: Vm(this, e); break; case Kf.IN_FRAMESET: !function (e, t) { t.tagID !== Kp.FRAMESET || e.openElements.isRootHtmlElementCurrent() || (e.openElements.pop(), e.fragmentContext || e.openElements.currentTagId === Kp.FRAMESET || (e.insertionMode = Kf.AFTER_FRAMESET)) }(this, e); break; case Kf.AFTER_FRAMESET: !function (e, t) { t.tagID === Kp.HTML && (e.insertionMode = Kf.AFTER_AFTER_FRAMESET) }(this, e); break; case Kf.AFTER_AFTER_BODY: Wm(this, e) } } onEof(e) { switch (this.insertionMode) { case Kf.INITIAL: um(this, e); break; case Kf.BEFORE_HTML: hm(this, e); break; case Kf.BEFORE_HEAD: dm(this, e); break; case Kf.IN_HEAD: mm(this, e); break; case Kf.IN_HEAD_NO_SCRIPT: gm(this, e); break; case Kf.AFTER_HEAD: Em(this, e); break; case Kf.IN_BODY: case Kf.IN_TABLE: case Kf.IN_CAPTION: case Kf.IN_COLUMN_GROUP: case Kf.IN_TABLE_BODY: case Kf.IN_ROW: case Kf.IN_CELL: case Kf.IN_SELECT: case Kf.IN_SELECT_IN_TABLE: Om(this, e); break; case Kf.TEXT: !function (e, t) { e._err(t, Cp.eofInElementThatCanContainOnlyText), e.openElements.pop(), e.insertionMode = e.originalInsertionMode, e.onEof(t) }(this, e); break; case Kf.IN_TABLE_TEXT: wm(this, e); break; case Kf.IN_TEMPLATE: qm(this, e); break; case Kf.AFTER_BODY: case Kf.IN_FRAMESET: case Kf.AFTER_FRAMESET: case Kf.AFTER_AFTER_BODY: case Kf.AFTER_AFTER_FRAMESET: cm(this, e) } } onWhitespaceCharacter(e) { if (this.skipNextNewLine && (this.skipNextNewLine = !1, e.chars.charCodeAt(0) === Ep.LINE_FEED)) { if (1 === e.chars.length) return; e.chars = e.chars.substr(1) } if (this.tokenizer.inForeignNode) this._insertCharacters(e); else switch (this.insertionMode) { case Kf.IN_HEAD: case Kf.IN_HEAD_NO_SCRIPT: case Kf.AFTER_HEAD: case Kf.TEXT: case Kf.IN_COLUMN_GROUP: case Kf.IN_SELECT: case Kf.IN_SELECT_IN_TABLE: case Kf.IN_FRAMESET: case Kf.AFTER_FRAMESET: this._insertCharacters(e); break; case Kf.IN_BODY: case Kf.IN_CAPTION: case Kf.IN_CELL: case Kf.IN_TEMPLATE: case Kf.AFTER_BODY: case Kf.AFTER_AFTER_BODY: case Kf.AFTER_AFTER_FRAMESET: Am(this, e); break; case Kf.IN_TABLE: case Kf.IN_TABLE_BODY: case Kf.IN_ROW: xm(this, e); break; case Kf.IN_TABLE_TEXT: Lm(this, e) } } } function tm(e, t) { let n = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName); return n ? e.openElements.contains(n.element) ? e.openElements.hasInScope(t.tagID) || (n = null) : (e.activeFormattingElements.removeEntry(n), n = null) : Nm(e, t), n } function nm(e, t) { let n = null, r = e.openElements.stackTop; for (; r >= 0; r--) { const s = e.openElements.items[r]; if (s === t.element) break; e._isSpecialElement(s, e.openElements.tagIDs[r]) && (n = s) } return n || (e.openElements.shortenToLength(Math.max(r, 0)), e.activeFormattingElements.removeEntry(t)), n } function rm(e, t, n) { let r = t, s = e.openElements.getCommonAncestor(t); for (let i = 0, o = s; o !== n; i++, o = s) { s = e.openElements.getCommonAncestor(o); const n = e.activeFormattingElements.getElementEntry(o), a = n && i >= 3; !n || a ? (a && e.activeFormattingElements.removeEntry(n), e.openElements.remove(o)) : (o = sm(e, n), r === t && (e.activeFormattingElements.bookmark = n), e.treeAdapter.detachNode(r), e.treeAdapter.appendChild(o, r), r = o) } return r } function sm(e, t) { const n = e.treeAdapter.getNamespaceURI(t.element), r = e.treeAdapter.createElement(t.token.tagName, n, t.token.attrs); return e.openElements.replace(t.element, r), t.element = r, r } function im(e, t, n) { const r = rf(e.treeAdapter.getTagName(t)); if (e._isElementCausesFosterParenting(r)) e._fosterParentElement(n); else { const s = e.treeAdapter.getNamespaceURI(t); r === Kp.TEMPLATE && s === jp.HTML && (t = e.treeAdapter.getTemplateContent(t)), e.treeAdapter.appendChild(t, n) } } function om(e, t, n) { const r = e.treeAdapter.getNamespaceURI(n.element), { token: s } = n, i = e.treeAdapter.createElement(s.tagName, r, s.attrs); e._adoptNodes(t, i), e.treeAdapter.appendChild(t, i), e.activeFormattingElements.insertElementAfterBookmark(i, s), e.activeFormattingElements.removeEntry(n), e.openElements.remove(n.element), e.openElements.insertAfter(t, i, s.tagID) } function am(e, t) { for (let n = 0; n < 8; n++) { const n = tm(e, t); if (!n) break; const r = nm(e, n); if (!r) break; e.activeFormattingElements.bookmark = n; const s = rm(e, r, n.element), i = e.openElements.getCommonAncestor(n.element); e.treeAdapter.detachNode(s), i && im(e, i, s), om(e, r, n) } } function lm(e, t) { e._appendCommentNode(t, e.openElements.currentTmplContentOrNode) } function cm(e, t) { if (e.stopped = !0, t.location) { const n = e.fragmentContext ? 0 : 2; for (let r = e.openElements.stackTop; r >= n; r--)e._setEndLocation(e.openElements.items[r], t); if (!e.fragmentContext && e.openElements.stackTop >= 0) { const n = e.openElements.items[0], r = e.treeAdapter.getNodeSourceCodeLocation(n); if (r && !r.endTag && (e._setEndLocation(n, t), e.openElements.stackTop >= 1)) { const n = e.openElements.items[1], r = e.treeAdapter.getNodeSourceCodeLocation(n); r && !r.endTag && e._setEndLocation(n, t) } } } } function um(e, t) { e._err(t, Cp.missingDoctype, !0), e.treeAdapter.setDocumentMode(e.document, qp.QUIRKS), e.insertionMode = Kf.BEFORE_HTML, e._processToken(t) } function hm(e, t) { e._insertFakeRootElement(), e.insertionMode = Kf.BEFORE_HEAD, e._processToken(t) } function dm(e, t) { e._insertFakeElement($p.HEAD, Kp.HEAD), e.headElement = e.openElements.current, e.insertionMode = Kf.IN_HEAD, e._processToken(t) } function pm(e, t) { switch (t.tagID) { case Kp.HTML: Cm(e, t); break; case Kp.BASE: case Kp.BASEFONT: case Kp.BGSOUND: case Kp.LINK: case Kp.META: e._appendElement(t, jp.HTML), t.ackSelfClosing = !0; break; case Kp.TITLE: e._switchToTextParsing(t, uf.RCDATA); break; case Kp.NOSCRIPT: e.options.scriptingEnabled ? e._switchToTextParsing(t, uf.RAWTEXT) : (e._insertElement(t, jp.HTML), e.insertionMode = Kf.IN_HEAD_NO_SCRIPT); break; case Kp.NOFRAMES: case Kp.STYLE: e._switchToTextParsing(t, uf.RAWTEXT); break; case Kp.SCRIPT: e._switchToTextParsing(t, uf.SCRIPT_DATA); break; case Kp.TEMPLATE: e._insertTemplate(t), e.activeFormattingElements.insertMarker(), e.framesetOk = !1, e.insertionMode = Kf.IN_TEMPLATE, e.tmplInsertionModeStack.unshift(Kf.IN_TEMPLATE); break; case Kp.HEAD: e._err(t, Cp.misplacedStartTagForHeadElement); break; default: mm(e, t) } } function fm(e, t) { e.openElements.tmplCount > 0 ? (e.openElements.generateImpliedEndTagsThoroughly(), e.openElements.currentTagId !== Kp.TEMPLATE && e._err(t, Cp.closingOfElementWithOpenChildElements), e.openElements.popUntilTagNamePopped(Kp.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode()) : e._err(t, Cp.endTagWithoutMatchingOpenElement) } function mm(e, t) { e.openElements.pop(), e.insertionMode = Kf.AFTER_HEAD, e._processToken(t) } function gm(e, t) { const n = t.type === Ip.EOF ? Cp.openElementsLeftAfterEof : Cp.disallowedContentInNoscriptInHead; e._err(t, n), e.openElements.pop(), e.insertionMode = Kf.IN_HEAD, e._processToken(t) } function Em(e, t) { e._insertFakeElement($p.BODY, Kp.BODY), e.insertionMode = Kf.IN_BODY, Tm(e, t) } function Tm(e, t) { switch (t.type) { case Ip.CHARACTER: _m(e, t); break; case Ip.WHITESPACE_CHARACTER: Am(e, t); break; case Ip.COMMENT: lm(e, t); break; case Ip.START_TAG: Cm(e, t); break; case Ip.END_TAG: Im(e, t); break; case Ip.EOF: Om(e, t) } } function Am(e, t) { e._reconstructActiveFormattingElements(), e._insertCharacters(t) } function _m(e, t) { e._reconstructActiveFormattingElements(), e._insertCharacters(t), e.framesetOk = !1 } function ym(e, t) { e._reconstructActiveFormattingElements(), e._appendElement(t, jp.HTML), e.framesetOk = !1, t.ackSelfClosing = !0 } function bm(e) { const t = Rp(e, zp.TYPE); return null != t && "hidden" === t.toLowerCase() } function Sm(e, t) { e._switchToTextParsing(t, uf.RAWTEXT) } function km(e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, jp.HTML) } function Cm(e, t) { switch (t.tagID) { case Kp.I: case Kp.S: case Kp.B: case Kp.U: case Kp.EM: case Kp.TT: case Kp.BIG: case Kp.CODE: case Kp.FONT: case Kp.SMALL: case Kp.STRIKE: case Kp.STRONG: !function (e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, jp.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t) }(e, t); break; case Kp.A: !function (e, t) { const n = e.activeFormattingElements.getElementEntryInScopeWithTagName($p.A); n && (am(e, t), e.openElements.remove(n.element), e.activeFormattingElements.removeEntry(n)), e._reconstructActiveFormattingElements(), e._insertElement(t, jp.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t) }(e, t); break; case Kp.H1: case Kp.H2: case Kp.H3: case Kp.H4: case Kp.H5: case Kp.H6: !function (e, t) { e.openElements.hasInButtonScope(Kp.P) && e._closePElement(), void 0 !== e.openElements.currentTagId && af.has(e.openElements.currentTagId) && e.openElements.pop(), e._insertElement(t, jp.HTML) }(e, t); break; case Kp.P: case Kp.DL: case Kp.OL: case Kp.UL: case Kp.DIV: case Kp.DIR: case Kp.NAV: case Kp.MAIN: case Kp.MENU: case Kp.ASIDE: case Kp.CENTER: case Kp.FIGURE: case Kp.FOOTER: case Kp.HEADER: case Kp.HGROUP: case Kp.DIALOG: case Kp.DETAILS: case Kp.ADDRESS: case Kp.ARTICLE: case Kp.SEARCH: case Kp.SECTION: case Kp.SUMMARY: case Kp.FIELDSET: case Kp.BLOCKQUOTE: case Kp.FIGCAPTION: !function (e, t) { e.openElements.hasInButtonScope(Kp.P) && e._closePElement(), e._insertElement(t, jp.HTML) }(e, t); break; case Kp.LI: case Kp.DD: case Kp.DT: !function (e, t) { e.framesetOk = !1; const n = t.tagID; for (let r = e.openElements.stackTop; r >= 0; r--) { const t = e.openElements.tagIDs[r]; if (n === Kp.LI && t === Kp.LI || (n === Kp.DD || n === Kp.DT) && (t === Kp.DD || t === Kp.DT)) { e.openElements.generateImpliedEndTagsWithExclusion(t), e.openElements.popUntilTagNamePopped(t); break } if (t !== Kp.ADDRESS && t !== Kp.DIV && t !== Kp.P && e._isSpecialElement(e.openElements.items[r], t)) break } e.openElements.hasInButtonScope(Kp.P) && e._closePElement(), e._insertElement(t, jp.HTML) }(e, t); break; case Kp.BR: case Kp.IMG: case Kp.WBR: case Kp.AREA: case Kp.EMBED: case Kp.KEYGEN: ym(e, t); break; case Kp.HR: !function (e, t) { e.openElements.hasInButtonScope(Kp.P) && e._closePElement(), e._appendElement(t, jp.HTML), e.framesetOk = !1, t.ackSelfClosing = !0 }(e, t); break; case Kp.RB: case Kp.RTC: !function (e, t) { e.openElements.hasInScope(Kp.RUBY) && e.openElements.generateImpliedEndTags(), e._insertElement(t, jp.HTML) }(e, t); break; case Kp.RT: case Kp.RP: !function (e, t) { e.openElements.hasInScope(Kp.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(Kp.RTC), e._insertElement(t, jp.HTML) }(e, t); break; case Kp.PRE: case Kp.LISTING: !function (e, t) { e.openElements.hasInButtonScope(Kp.P) && e._closePElement(), e._insertElement(t, jp.HTML), e.skipNextNewLine = !0, e.framesetOk = !1 }(e, t); break; case Kp.XMP: !function (e, t) { e.openElements.hasInButtonScope(Kp.P) && e._closePElement(), e._reconstructActiveFormattingElements(), e.framesetOk = !1, e._switchToTextParsing(t, uf.RAWTEXT) }(e, t); break; case Kp.SVG: !function (e, t) { e._reconstructActiveFormattingElements(), $f(t), Wf(t), t.selfClosing ? e._appendElement(t, jp.SVG) : e._insertElement(t, jp.SVG), t.ackSelfClosing = !0 }(e, t); break; case Kp.HTML: !function (e, t) { 0 === e.openElements.tmplCount && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs) }(e, t); break; case Kp.BASE: case Kp.LINK: case Kp.META: case Kp.STYLE: case Kp.TITLE: case Kp.SCRIPT: case Kp.BGSOUND: case Kp.BASEFONT: case Kp.TEMPLATE: pm(e, t); break; case Kp.BODY: !function (e, t) { const n = e.openElements.tryPeekProperlyNestedBodyElement(); n && 0 === e.openElements.tmplCount && (e.framesetOk = !1, e.treeAdapter.adoptAttributes(n, t.attrs)) }(e, t); break; case Kp.FORM: !function (e, t) { const n = e.openElements.tmplCount > 0; e.formElement && !n || (e.openElements.hasInButtonScope(Kp.P) && e._closePElement(), e._insertElement(t, jp.HTML), n || (e.formElement = e.openElements.current)) }(e, t); break; case Kp.NOBR: !function (e, t) { e._reconstructActiveFormattingElements(), e.openElements.hasInScope(Kp.NOBR) && (am(e, t), e._reconstructActiveFormattingElements()), e._insertElement(t, jp.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t) }(e, t); break; case Kp.MATH: !function (e, t) { e._reconstructActiveFormattingElements(), Vf(t), Wf(t), t.selfClosing ? e._appendElement(t, jp.MATHML) : e._insertElement(t, jp.MATHML), t.ackSelfClosing = !0 }(e, t); break; case Kp.TABLE: !function (e, t) { e.treeAdapter.getDocumentMode(e.document) !== qp.QUIRKS && e.openElements.hasInButtonScope(Kp.P) && e._closePElement(), e._insertElement(t, jp.HTML), e.framesetOk = !1, e.insertionMode = Kf.IN_TABLE }(e, t); break; case Kp.INPUT: !function (e, t) { e._reconstructActiveFormattingElements(), e._appendElement(t, jp.HTML), bm(t) || (e.framesetOk = !1), t.ackSelfClosing = !0 }(e, t); break; case Kp.PARAM: case Kp.TRACK: case Kp.SOURCE: !function (e, t) { e._appendElement(t, jp.HTML), t.ackSelfClosing = !0 }(e, t); break; case Kp.IMAGE: !function (e, t) { t.tagName = $p.IMG, t.tagID = Kp.IMG, ym(e, t) }(e, t); break; case Kp.BUTTON: !function (e, t) { e.openElements.hasInScope(Kp.BUTTON) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(Kp.BUTTON)), e._reconstructActiveFormattingElements(), e._insertElement(t, jp.HTML), e.framesetOk = !1 }(e, t); break; case Kp.APPLET: case Kp.OBJECT: case Kp.MARQUEE: !function (e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, jp.HTML), e.activeFormattingElements.insertMarker(), e.framesetOk = !1 }(e, t); break; case Kp.IFRAME: !function (e, t) { e.framesetOk = !1, e._switchToTextParsing(t, uf.RAWTEXT) }(e, t); break; case Kp.SELECT: !function (e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, jp.HTML), e.framesetOk = !1, e.insertionMode = e.insertionMode === Kf.IN_TABLE || e.insertionMode === Kf.IN_CAPTION || e.insertionMode === Kf.IN_TABLE_BODY || e.insertionMode === Kf.IN_ROW || e.insertionMode === Kf.IN_CELL ? Kf.IN_SELECT_IN_TABLE : Kf.IN_SELECT }(e, t); break; case Kp.OPTION: case Kp.OPTGROUP: !function (e, t) { e.openElements.currentTagId === Kp.OPTION && e.openElements.pop(), e._reconstructActiveFormattingElements(), e._insertElement(t, jp.HTML) }(e, t); break; case Kp.NOEMBED: case Kp.NOFRAMES: Sm(e, t); break; case Kp.FRAMESET: !function (e, t) { const n = e.openElements.tryPeekProperlyNestedBodyElement(); e.framesetOk && n && (e.treeAdapter.detachNode(n), e.openElements.popAllUpToHtmlElement(), e._insertElement(t, jp.HTML), e.insertionMode = Kf.IN_FRAMESET) }(e, t); break; case Kp.TEXTAREA: !function (e, t) { e._insertElement(t, jp.HTML), e.skipNextNewLine = !0, e.tokenizer.state = uf.RCDATA, e.originalInsertionMode = e.insertionMode, e.framesetOk = !1, e.insertionMode = Kf.TEXT }(e, t); break; case Kp.NOSCRIPT: e.options.scriptingEnabled ? Sm(e, t) : km(e, t); break; case Kp.PLAINTEXT: !function (e, t) { e.openElements.hasInButtonScope(Kp.P) && e._closePElement(), e._insertElement(t, jp.HTML), e.tokenizer.state = uf.PLAINTEXT }(e, t); break; case Kp.COL: case Kp.TH: case Kp.TD: case Kp.TR: case Kp.HEAD: case Kp.FRAME: case Kp.TBODY: case Kp.TFOOT: case Kp.THEAD: case Kp.CAPTION: case Kp.COLGROUP: break; default: km(e, t) } } function Nm(e, t) { const n = t.tagName, r = t.tagID; for (let s = e.openElements.stackTop; s > 0; s--) { const t = e.openElements.items[s], i = e.openElements.tagIDs[s]; if (r === i && (r !== Kp.UNKNOWN || e.treeAdapter.getTagName(t) === n)) { e.openElements.generateImpliedEndTagsWithExclusion(r), e.openElements.stackTop >= s && e.openElements.shortenToLength(s); break } if (e._isSpecialElement(t, i)) break } } function Im(e, t) { switch (t.tagID) { case Kp.A: case Kp.B: case Kp.I: case Kp.S: case Kp.U: case Kp.EM: case Kp.TT: case Kp.BIG: case Kp.CODE: case Kp.FONT: case Kp.NOBR: case Kp.SMALL: case Kp.STRIKE: case Kp.STRONG: am(e, t); break; case Kp.P: !function (e) { e.openElements.hasInButtonScope(Kp.P) || e._insertFakeElement($p.P, Kp.P), e._closePElement() }(e); break; case Kp.DL: case Kp.UL: case Kp.OL: case Kp.DIR: case Kp.DIV: case Kp.NAV: case Kp.PRE: case Kp.MAIN: case Kp.MENU: case Kp.ASIDE: case Kp.BUTTON: case Kp.CENTER: case Kp.FIGURE: case Kp.FOOTER: case Kp.HEADER: case Kp.HGROUP: case Kp.DIALOG: case Kp.ADDRESS: case Kp.ARTICLE: case Kp.DETAILS: case Kp.SEARCH: case Kp.SECTION: case Kp.SUMMARY: case Kp.LISTING: case Kp.FIELDSET: case Kp.BLOCKQUOTE: case Kp.FIGCAPTION: !function (e, t) { const n = t.tagID; e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n)) }(e, t); break; case Kp.LI: !function (e) { e.openElements.hasInListItemScope(Kp.LI) && (e.openElements.generateImpliedEndTagsWithExclusion(Kp.LI), e.openElements.popUntilTagNamePopped(Kp.LI)) }(e); break; case Kp.DD: case Kp.DT: !function (e, t) { const n = t.tagID; e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTagsWithExclusion(n), e.openElements.popUntilTagNamePopped(n)) }(e, t); break; case Kp.H1: case Kp.H2: case Kp.H3: case Kp.H4: case Kp.H5: case Kp.H6: !function (e) { e.openElements.hasNumberedHeaderInScope() && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped()) }(e); break; case Kp.BR: !function (e) { e._reconstructActiveFormattingElements(), e._insertFakeElement($p.BR, Kp.BR), e.openElements.pop(), e.framesetOk = !1 }(e); break; case Kp.BODY: !function (e, t) { if (e.openElements.hasInScope(Kp.BODY) && (e.insertionMode = Kf.AFTER_BODY, e.options.sourceCodeLocationInfo)) { const n = e.openElements.tryPeekProperlyNestedBodyElement(); n && e._setEndLocation(n, t) } }(e, t); break; case Kp.HTML: !function (e, t) { e.openElements.hasInScope(Kp.BODY) && (e.insertionMode = Kf.AFTER_BODY, Vm(e, t)) }(e, t); break; case Kp.FORM: !function (e) { const t = e.openElements.tmplCount > 0, { formElement: n } = e; t || (e.formElement = null), (n || t) && e.openElements.hasInScope(Kp.FORM) && (e.openElements.generateImpliedEndTags(), t ? e.openElements.popUntilTagNamePopped(Kp.FORM) : n && e.openElements.remove(n)) }(e); break; case Kp.APPLET: case Kp.OBJECT: case Kp.MARQUEE: !function (e, t) { const n = t.tagID; e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker()) }(e, t); break; case Kp.TEMPLATE: fm(e, t); break; default: Nm(e, t) } } function Om(e, t) { e.tmplInsertionModeStack.length > 0 ? qm(e, t) : cm(e, t) } function xm(e, t) { if (void 0 !== e.openElements.currentTagId && Jf.has(e.openElements.currentTagId)) switch (e.pendingCharacterTokens.length = 0, e.hasNonWhitespacePendingCharacterToken = !1, e.originalInsertionMode = e.insertionMode, e.insertionMode = Kf.IN_TABLE_TEXT, t.type) { case Ip.CHARACTER: Pm(e, t); break; case Ip.WHITESPACE_CHARACTER: Lm(e, t) } else Dm(e, t) } function Rm(e, t) { switch (t.tagID) { case Kp.TD: case Kp.TH: case Kp.TR: !function (e, t) { e.openElements.clearBackToTableContext(), e._insertFakeElement($p.TBODY, Kp.TBODY), e.insertionMode = Kf.IN_TABLE_BODY, Um(e, t) }(e, t); break; case Kp.STYLE: case Kp.SCRIPT: case Kp.TEMPLATE: pm(e, t); break; case Kp.COL: !function (e, t) { e.openElements.clearBackToTableContext(), e._insertFakeElement($p.COLGROUP, Kp.COLGROUP), e.insertionMode = Kf.IN_COLUMN_GROUP, Fm(e, t) }(e, t); break; case Kp.FORM: !function (e, t) { e.formElement || 0 !== e.openElements.tmplCount || (e._insertElement(t, jp.HTML), e.formElement = e.openElements.current, e.openElements.pop()) }(e, t); break; case Kp.TABLE: !function (e, t) { e.openElements.hasInTableScope(Kp.TABLE) && (e.openElements.popUntilTagNamePopped(Kp.TABLE), e._resetInsertionMode(), e._processStartTag(t)) }(e, t); break; case Kp.TBODY: case Kp.TFOOT: case Kp.THEAD: !function (e, t) { e.openElements.clearBackToTableContext(), e._insertElement(t, jp.HTML), e.insertionMode = Kf.IN_TABLE_BODY }(e, t); break; case Kp.INPUT: !function (e, t) { bm(t) ? e._appendElement(t, jp.HTML) : Dm(e, t), t.ackSelfClosing = !0 }(e, t); break; case Kp.CAPTION: !function (e, t) { e.openElements.clearBackToTableContext(), e.activeFormattingElements.insertMarker(), e._insertElement(t, jp.HTML), e.insertionMode = Kf.IN_CAPTION }(e, t); break; case Kp.COLGROUP: !function (e, t) { e.openElements.clearBackToTableContext(), e._insertElement(t, jp.HTML), e.insertionMode = Kf.IN_COLUMN_GROUP }(e, t); break; default: Dm(e, t) } } function vm(e, t) { switch (t.tagID) { case Kp.TABLE: e.openElements.hasInTableScope(Kp.TABLE) && (e.openElements.popUntilTagNamePopped(Kp.TABLE), e._resetInsertionMode()); break; case Kp.TEMPLATE: fm(e, t); break; case Kp.BODY: case Kp.CAPTION: case Kp.COL: case Kp.COLGROUP: case Kp.HTML: case Kp.TBODY: case Kp.TD: case Kp.TFOOT: case Kp.TH: case Kp.THEAD: case Kp.TR: break; default: Dm(e, t) } } function Dm(e, t) { const n = e.fosterParentingEnabled; e.fosterParentingEnabled = !0, Tm(e, t), e.fosterParentingEnabled = n } function Lm(e, t) { e.pendingCharacterTokens.push(t) } function Pm(e, t) { e.pendingCharacterTokens.push(t), e.hasNonWhitespacePendingCharacterToken = !0 } function wm(e, t) { let n = 0; if (e.hasNonWhitespacePendingCharacterToken) for (; n < e.pendingCharacterTokens.length; n++)Dm(e, e.pendingCharacterTokens[n]); else for (; n < e.pendingCharacterTokens.length; n++)e._insertCharacters(e.pendingCharacterTokens[n]); e.insertionMode = e.originalInsertionMode, e._processToken(t) } const Mm = new Set([Kp.CAPTION, Kp.COL, Kp.COLGROUP, Kp.TBODY, Kp.TD, Kp.TFOOT, Kp.TH, Kp.THEAD, Kp.TR]); function Fm(e, t) { switch (t.tagID) { case Kp.HTML: Cm(e, t); break; case Kp.COL: e._appendElement(t, jp.HTML), t.ackSelfClosing = !0; break; case Kp.TEMPLATE: pm(e, t); break; default: Bm(e, t) } } function Bm(e, t) { e.openElements.currentTagId === Kp.COLGROUP && (e.openElements.pop(), e.insertionMode = Kf.IN_TABLE, e._processToken(t)) } function Um(e, t) { switch (t.tagID) { case Kp.TR: e.openElements.clearBackToTableBodyContext(), e._insertElement(t, jp.HTML), e.insertionMode = Kf.IN_ROW; break; case Kp.TH: case Kp.TD: e.openElements.clearBackToTableBodyContext(), e._insertFakeElement($p.TR, Kp.TR), e.insertionMode = Kf.IN_ROW, jm(e, t); break; case Kp.CAPTION: case Kp.COL: case Kp.COLGROUP: case Kp.TBODY: case Kp.TFOOT: case Kp.THEAD: e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = Kf.IN_TABLE, Rm(e, t)); break; default: Rm(e, t) } } function Hm(e, t) { const n = t.tagID; switch (t.tagID) { case Kp.TBODY: case Kp.TFOOT: case Kp.THEAD: e.openElements.hasInTableScope(n) && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = Kf.IN_TABLE); break; case Kp.TABLE: e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = Kf.IN_TABLE, vm(e, t)); break; case Kp.BODY: case Kp.CAPTION: case Kp.COL: case Kp.COLGROUP: case Kp.HTML: case Kp.TD: case Kp.TH: case Kp.TR: break; default: vm(e, t) } } function jm(e, t) { switch (t.tagID) { case Kp.TH: case Kp.TD: e.openElements.clearBackToTableRowContext(), e._insertElement(t, jp.HTML), e.insertionMode = Kf.IN_CELL, e.activeFormattingElements.insertMarker(); break; case Kp.CAPTION: case Kp.COL: case Kp.COLGROUP: case Kp.TBODY: case Kp.TFOOT: case Kp.THEAD: case Kp.TR: e.openElements.hasInTableScope(Kp.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = Kf.IN_TABLE_BODY, Um(e, t)); break; default: Rm(e, t) } } function Gm(e, t) { switch (t.tagID) { case Kp.TR: e.openElements.hasInTableScope(Kp.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = Kf.IN_TABLE_BODY); break; case Kp.TABLE: e.openElements.hasInTableScope(Kp.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = Kf.IN_TABLE_BODY, Hm(e, t)); break; case Kp.TBODY: case Kp.TFOOT: case Kp.THEAD: (e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(Kp.TR)) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = Kf.IN_TABLE_BODY, Hm(e, t)); break; case Kp.BODY: case Kp.CAPTION: case Kp.COL: case Kp.COLGROUP: case Kp.HTML: case Kp.TD: case Kp.TH: break; default: vm(e, t) } } function zm(e, t) { switch (t.tagID) { case Kp.HTML: Cm(e, t); break; case Kp.OPTION: e.openElements.currentTagId === Kp.OPTION && e.openElements.pop(), e._insertElement(t, jp.HTML); break; case Kp.OPTGROUP: e.openElements.currentTagId === Kp.OPTION && e.openElements.pop(), e.openElements.currentTagId === Kp.OPTGROUP && e.openElements.pop(), e._insertElement(t, jp.HTML); break; case Kp.HR: e.openElements.currentTagId === Kp.OPTION && e.openElements.pop(), e.openElements.currentTagId === Kp.OPTGROUP && e.openElements.pop(), e._appendElement(t, jp.HTML), t.ackSelfClosing = !0; break; case Kp.INPUT: case Kp.KEYGEN: case Kp.TEXTAREA: case Kp.SELECT: e.openElements.hasInSelectScope(Kp.SELECT) && (e.openElements.popUntilTagNamePopped(Kp.SELECT), e._resetInsertionMode(), t.tagID !== Kp.SELECT && e._processStartTag(t)); break; case Kp.SCRIPT: case Kp.TEMPLATE: pm(e, t) } } function Ym(e, t) { switch (t.tagID) { case Kp.OPTGROUP: e.openElements.stackTop > 0 && e.openElements.currentTagId === Kp.OPTION && e.openElements.tagIDs[e.openElements.stackTop - 1] === Kp.OPTGROUP && e.openElements.pop(), e.openElements.currentTagId === Kp.OPTGROUP && e.openElements.pop(); break; case Kp.OPTION: e.openElements.currentTagId === Kp.OPTION && e.openElements.pop(); break; case Kp.SELECT: e.openElements.hasInSelectScope(Kp.SELECT) && (e.openElements.popUntilTagNamePopped(Kp.SELECT), e._resetInsertionMode()); break; case Kp.TEMPLATE: fm(e, t) } } function qm(e, t) { e.openElements.tmplCount > 0 ? (e.openElements.popUntilTagNamePopped(Kp.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode(), e.onEof(t)) : cm(e, t) } function Vm(e, t) { var n; if (t.tagID === Kp.HTML) { if (e.fragmentContext || (e.insertionMode = Kf.AFTER_AFTER_BODY), e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === Kp.HTML) { e._setEndLocation(e.openElements.items[0], t); const r = e.openElements.items[1]; r && !(null === (n = e.treeAdapter.getNodeSourceCodeLocation(r)) || void 0 === n ? void 0 : n.endTag) && e._setEndLocation(r, t) } } else $m(e, t) } function $m(e, t) { e.insertionMode = Kf.IN_BODY, Tm(e, t) } function Wm(e, t) { e.insertionMode = Kf.IN_BODY, Tm(e, t) } function Km(e) { for (; e.treeAdapter.getNamespaceURI(e.openElements.current) !== jp.HTML && void 0 !== e.openElements.currentTagId && !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current);)e.openElements.pop() } $p.AREA, $p.BASE, $p.BASEFONT, $p.BGSOUND, $p.BR, $p.COL, $p.EMBED, $p.FRAME, $p.HR, $p.IMG, $p.INPUT, $p.KEYGEN, $p.LINK, $p.META, $p.PARAM, $p.SOURCE, $p.TRACK, $p.WBR; const Qm = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\t\n\f\r />])/gi, Xm = new Set(["mdxFlowExpression", "mdxJsxFlowElement", "mdxJsxTextElement", "mdxTextExpression", "mdxjsEsm"]), Jm = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 }; function Zm(e, t) { const n = function (e) { const t = "root" === e.type ? e.children[0] : e; return Boolean(t && ("doctype" === t.type || "element" === t.type && "html" === t.tagName.toLowerCase())) }(e), r = Lh("type", { handlers: { root: tg, element: ng, text: rg, comment: ig, doctype: sg, raw: og }, unknown: ag }), s = { parser: n ? new em(Jm) : em.getFragmentParser(void 0, Jm), handle(e) { r(e, s) }, stitches: !1, options: t || {} }; r(e, s), lg(s, ha()); const i = function (e, t) { const n = t || {}; return rp({ file: n.file || void 0, location: !1, schema: "svg" === n.space ? Mo : wo, verbose: n.verbose || !1 }, e) }(n ? s.parser.document : s.parser.getFragment(), { file: s.options.file }); return s.stitches && Zc(i, "comment", function (e, t, n) { const r = e; if (r.value.stitch && n && void 0 !== t) return n.children[t] = r.value.stitch, t }), "root" === i.type && 1 === i.children.length && i.children[0].type === e.type ? i.children[0] : i } function eg(e, t) { let n = -1; if (e) for (; ++n < e.length;)t.handle(e[n]) } function tg(e, t) { eg(e.children, t) } function ng(e, t) { !function (e, t) { const n = e.tagName.toLowerCase(); if (t.parser.tokenizer.state === uf.PLAINTEXT) return; lg(t, ha(e)); const r = t.parser.openElements.current; let s = "namespaceURI" in r ? r.namespaceURI : ep.html; s === ep.html && "svg" === n && (s = ep.svg); const i = (a = { ...e, children: [] }, up(a, "svg" === ({ space: s === ep.svg ? "svg" : "html" } || lp).space ? Mo : wo)), o = { type: Ip.START_TAG, tagName: n, tagID: rf(n), selfClosing: !1, ackSelfClosing: !1, attrs: "attrs" in i ? i.attrs : [], location: ug(e) }; var a; t.parser.currentToken = o, t.parser._processToken(t.parser.currentToken), t.parser.tokenizer.lastStartTagName = n }(e, t), eg(e.children, t), function (e, t) { const n = e.tagName.toLowerCase(); if (!t.parser.tokenizer.inForeignNode && fp.includes(n)) return; if (t.parser.tokenizer.state === uf.PLAINTEXT) return; lg(t, ua(e)); const r = { type: Ip.END_TAG, tagName: n, tagID: rf(n), selfClosing: !1, ackSelfClosing: !1, attrs: [], location: ug(e) }; t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken), n !== t.parser.tokenizer.lastStartTagName || t.parser.tokenizer.state !== uf.RCDATA && t.parser.tokenizer.state !== uf.RAWTEXT && t.parser.tokenizer.state !== uf.SCRIPT_DATA || (t.parser.tokenizer.state = uf.DATA) }(e, t) } function rg(e, t) { t.parser.tokenizer.state > 4 && (t.parser.tokenizer.state = 0); const n = { type: Ip.CHARACTER, chars: e.value, location: ug(e) }; lg(t, ha(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken) } function sg(e, t) { const n = { type: Ip.DOCTYPE, name: "html", forceQuirks: !1, publicId: "", systemId: "", location: ug(e) }; lg(t, ha(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken) } function ig(e, t) { const n = e.value, r = { type: Ip.COMMENT, data: n, location: ug(e) }; lg(t, ha(e)), t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken) } function og(e, t) { if (t.parser.tokenizer.preprocessor.html = "", t.parser.tokenizer.preprocessor.pos = -1, t.parser.tokenizer.preprocessor.lastGapPos = -2, t.parser.tokenizer.preprocessor.gapStack = [], t.parser.tokenizer.preprocessor.skipNextNewLine = !1, t.parser.tokenizer.preprocessor.lastChunkWritten = !1, t.parser.tokenizer.preprocessor.endOfChunkHit = !1, t.parser.tokenizer.preprocessor.isEol = !1, cg(t, ha(e)), t.parser.tokenizer.write(t.options.tagfilter ? e.value.replace(Qm, "&lt;$1$2") : e.value, !1), t.parser.tokenizer._runParsingLoop(), 72 === t.parser.tokenizer.state || 78 === t.parser.tokenizer.state) { t.parser.tokenizer.preprocessor.lastChunkWritten = !0; const e = t.parser.tokenizer._consume(); t.parser.tokenizer._callState(e) } } function ag(e, t) { const n = e; if (!t.options.passThrough || !t.options.passThrough.includes(n.type)) { let e = ""; throw Xm.has(n.type) && (e = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + n.type + "` node" + e) } !function (e, t) { t.stitches = !0; const n = function (e) { return Yc("children" in e ? { ...e, children: [] } : e) }(e); if ("children" in e && "children" in n) { const r = Zm({ type: "root", children: e.children }, t.options); n.children = r.children } ig({ type: "comment", value: { stitch: n } }, t) }(n, t) } function lg(e, t) { cg(e, t); const n = e.parser.tokenizer.currentCharacterToken; n && n.location && (n.location.endLine = e.parser.tokenizer.preprocessor.line, n.location.endCol = e.parser.tokenizer.preprocessor.col + 1, n.location.endOffset = e.parser.tokenizer.preprocessor.offset + 1, e.parser.currentToken = n, e.parser._processToken(e.parser.currentToken)), e.parser.tokenizer.paused = !1, e.parser.tokenizer.inLoop = !1, e.parser.tokenizer.active = !1, e.parser.tokenizer.returnState = uf.DATA, e.parser.tokenizer.charRefCode = -1, e.parser.tokenizer.consumedAfterSnapshot = -1, e.parser.tokenizer.currentLocation = null, e.parser.tokenizer.currentCharacterToken = null, e.parser.tokenizer.currentToken = null, e.parser.tokenizer.currentAttr = { name: "", value: "" } } function cg(e, t) { if (t && void 0 !== t.offset) { const n = { startLine: t.line, startCol: t.column, startOffset: t.offset, endLine: -1, endCol: -1, endOffset: -1 }; e.parser.tokenizer.preprocessor.lineStartPos = 1 - t.column, e.parser.tokenizer.preprocessor.droppedBufferSize = t.offset, e.parser.tokenizer.preprocessor.line = t.line, e.parser.tokenizer.currentLocation = n } } function ug(e) { const t = ha(e) || { line: void 0, column: void 0, offset: void 0 }, n = ua(e) || { line: void 0, column: void 0, offset: void 0 }; return { startLine: t.line, startCol: t.column, startOffset: t.offset, endLine: n.line, endCol: n.column, endOffset: n.offset } } const hg = Object.freeze(Object.defineProperty({ __proto__: null, default: function (e) { return function (t, n) { return Zm(t, { ...e, file: n }) } } }, Symbol.toStringTag, { value: "Module" })), dg = Object.freeze(Object.defineProperty({ __proto__: null, default: { brand: "", footer: { copyright: " {{year}} Cyber O-hm blog. MIT License." }, nav: { home: "Ch-iah", tutorials: "Ku-hak", admin: "Kon-l", categories: "Li-piat" }, home: { title: "Cyber O-hm blog", featured: "Cheng-son", latest: "Sing-sin Bn-chiu", readMore: "Kho Sing-s", noPosts: "Iu-be  bn-chiu", loading: "Tng teh liah...", failedToLoad: "Bn-chiu liah-b--tioh" }, post: { by: "Chok-chi:", published: "Hoat-piu", share: "Hun-hing", readArticle: "Kho bn-chiu ", featured: " Cheng-son", notFound: "Chhe-b bn-chiu" }, category: { postCount: "{{count}} phi", postCount_plural: "{{count}} phi", includingDrafts: "(lin chh-k)", noPosts: "Chhe-b bn-chiu." } } }, Symbol.toStringTag, { value: "Module" })), pg = Object.freeze(Object.defineProperty({ __proto__: null, default: { brand: "", footer: { copyright: " {{year}} Cyber  blog. MIT License." }, nav: { home: "", tutorials: "", admin: "", categories: "" }, home: { title: "Cyber  blog", featured: "", latest: "", readMore: "", noPosts: "", loading: "Tng teh ...", failedToLoad: "--tioh" }, post: { by: "", published: "", share: "", readArticle: " ", featured: " ", notFound: "" }, category: { postCount: "{{count}} ", postCount_plural: "{{count}} ", includingDrafts: "()", noPosts: "" } } }, Symbol.toStringTag, { value: "Module" }));</script>
    <style rel="stylesheet" crossorigin>
        @font-face {
            font-family: ChiayiCity;
            src: url(https://raw.githubusercontent.com/CyberOoHim/CyberOoHim.github.io/main/assets/fonts/ChiayiCity.ttf) format("truetype");
            font-weight: 400;
            font-style: normal;
            font-display: block
        }

        *,
        :before,
        :after {
            --tw-border-spacing-x: 0;
            --tw-border-spacing-y: 0;
            --tw-translate-x: 0;
            --tw-translate-y: 0;
            --tw-rotate: 0;
            --tw-skew-x: 0;
            --tw-skew-y: 0;
            --tw-scale-x: 1;
            --tw-scale-y: 1;
            --tw-pan-x: ;
            --tw-pan-y: ;
            --tw-pinch-zoom: ;
            --tw-scroll-snap-strictness: proximity;
            --tw-gradient-from-position: ;
            --tw-gradient-via-position: ;
            --tw-gradient-to-position: ;
            --tw-ordinal: ;
            --tw-slashed-zero: ;
            --tw-numeric-figure: ;
            --tw-numeric-spacing: ;
            --tw-numeric-fraction: ;
            --tw-ring-inset: ;
            --tw-ring-offset-width: 0px;
            --tw-ring-offset-color: #fff;
            --tw-ring-color: rgb(59 130 246 / .5);
            --tw-ring-offset-shadow: 0 0 #0000;
            --tw-ring-shadow: 0 0 #0000;
            --tw-shadow: 0 0 #0000;
            --tw-shadow-colored: 0 0 #0000;
            --tw-blur: ;
            --tw-brightness: ;
            --tw-contrast: ;
            --tw-grayscale: ;
            --tw-hue-rotate: ;
            --tw-invert: ;
            --tw-saturate: ;
            --tw-sepia: ;
            --tw-drop-shadow: ;
            --tw-backdrop-blur: ;
            --tw-backdrop-brightness: ;
            --tw-backdrop-contrast: ;
            --tw-backdrop-grayscale: ;
            --tw-backdrop-hue-rotate: ;
            --tw-backdrop-invert: ;
            --tw-backdrop-opacity: ;
            --tw-backdrop-saturate: ;
            --tw-backdrop-sepia: ;
            --tw-contain-size: ;
            --tw-contain-layout: ;
            --tw-contain-paint: ;
            --tw-contain-style:
        }

        ::backdrop {
            --tw-border-spacing-x: 0;
            --tw-border-spacing-y: 0;
            --tw-translate-x: 0;
            --tw-translate-y: 0;
            --tw-rotate: 0;
            --tw-skew-x: 0;
            --tw-skew-y: 0;
            --tw-scale-x: 1;
            --tw-scale-y: 1;
            --tw-pan-x: ;
            --tw-pan-y: ;
            --tw-pinch-zoom: ;
            --tw-scroll-snap-strictness: proximity;
            --tw-gradient-from-position: ;
            --tw-gradient-via-position: ;
            --tw-gradient-to-position: ;
            --tw-ordinal: ;
            --tw-slashed-zero: ;
            --tw-numeric-figure: ;
            --tw-numeric-spacing: ;
            --tw-numeric-fraction: ;
            --tw-ring-inset: ;
            --tw-ring-offset-width: 0px;
            --tw-ring-offset-color: #fff;
            --tw-ring-color: rgb(59 130 246 / .5);
            --tw-ring-offset-shadow: 0 0 #0000;
            --tw-ring-shadow: 0 0 #0000;
            --tw-shadow: 0 0 #0000;
            --tw-shadow-colored: 0 0 #0000;
            --tw-blur: ;
            --tw-brightness: ;
            --tw-contrast: ;
            --tw-grayscale: ;
            --tw-hue-rotate: ;
            --tw-invert: ;
            --tw-saturate: ;
            --tw-sepia: ;
            --tw-drop-shadow: ;
            --tw-backdrop-blur: ;
            --tw-backdrop-brightness: ;
            --tw-backdrop-contrast: ;
            --tw-backdrop-grayscale: ;
            --tw-backdrop-hue-rotate: ;
            --tw-backdrop-invert: ;
            --tw-backdrop-opacity: ;
            --tw-backdrop-saturate: ;
            --tw-backdrop-sepia: ;
            --tw-contain-size: ;
            --tw-contain-layout: ;
            --tw-contain-paint: ;
            --tw-contain-style:
        }

        *,
        :before,
        :after {
            box-sizing: border-box;
            border-width: 0;
            border-style: solid;
            border-color: #e5e7eb
        }

        :before,
        :after {
            --tw-content: ""
        }

        html,
        :host {
            line-height: 1.5;
            -webkit-text-size-adjust: 100%;
            -moz-tab-size: 4;
            -o-tab-size: 4;
            tab-size: 4;
            font-family: Huninn, Times New Roman, serif;
            font-feature-settings: normal;
            font-variation-settings: normal;
            -webkit-tap-highlight-color: transparent
        }

        body {
            margin: 0;
            line-height: inherit
        }

        hr {
            height: 0;
            color: inherit;
            border-top-width: 1px
        }

        abbr:where([title]) {
            -webkit-text-decoration: underline dotted;
            text-decoration: underline dotted
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            font-size: inherit;
            font-weight: inherit
        }

        a {
            color: inherit;
            text-decoration: inherit
        }

        b,
        strong {
            font-weight: bolder
        }

        code,
        kbd,
        samp,
        pre {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;
            font-feature-settings: normal;
            font-variation-settings: normal;
            font-size: 1em
        }

        small {
            font-size: 80%
        }

        sub,
        sup {
            font-size: 75%;
            line-height: 0;
            position: relative;
            vertical-align: baseline
        }

        sub {
            bottom: -.25em
        }

        sup {
            top: -.5em
        }

        table {
            text-indent: 0;
            border-color: inherit;
            border-collapse: collapse
        }

        button,
        input,
        optgroup,
        select,
        textarea {
            font-family: inherit;
            font-feature-settings: inherit;
            font-variation-settings: inherit;
            font-size: 100%;
            font-weight: inherit;
            line-height: inherit;
            letter-spacing: inherit;
            color: inherit;
            margin: 0;
            padding: 0
        }

        button,
        select {
            text-transform: none
        }

        button,
        input:where([type=button]),
        input:where([type=reset]),
        input:where([type=submit]) {
            -webkit-appearance: button;
            background-color: transparent;
            background-image: none
        }

        :-moz-focusring {
            outline: auto
        }

        :-moz-ui-invalid {
            box-shadow: none
        }

        progress {
            vertical-align: baseline
        }

        ::-webkit-inner-spin-button,
        ::-webkit-outer-spin-button {
            height: auto
        }

        [type=search] {
            -webkit-appearance: textfield;
            outline-offset: -2px
        }

        ::-webkit-search-decoration {
            -webkit-appearance: none
        }

        ::-webkit-file-upload-button {
            -webkit-appearance: button;
            font: inherit
        }

        summary {
            display: list-item
        }

        blockquote,
        dl,
        dd,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        hr,
        figure,
        p,
        pre {
            margin: 0
        }

        fieldset {
            margin: 0;
            padding: 0
        }

        legend {
            padding: 0
        }

        ol,
        ul,
        menu {
            list-style: none;
            margin: 0;
            padding: 0
        }

        dialog {
            padding: 0
        }

        textarea {
            resize: vertical
        }

        input::-moz-placeholder,
        textarea::-moz-placeholder {
            opacity: 1;
            color: #9ca3af
        }

        input::placeholder,
        textarea::placeholder {
            opacity: 1;
            color: #9ca3af
        }

        button,
        [role=button] {
            cursor: pointer
        }

        :disabled {
            cursor: default
        }

        img,
        svg,
        video,
        canvas,
        audio,
        iframe,
        embed,
        object {
            display: block;
            vertical-align: middle
        }

        img,
        video {
            max-width: 100%;
            height: auto
        }

        [hidden]:where(:not([hidden=until-found])) {
            display: none
        }

        :root {
            --text-base: 1rem;
            --text-scale: 1
        }

        [data-text-size=small] {
            --text-scale: .875
        }

        [data-text-size=medium] {
            --text-scale: 1
        }

        [data-text-size=large] {
            --text-scale: 1.125
        }

        [data-text-size=xlarge] {
            --text-scale: 1.25
        }

        [data-text-size=xxlarge] {
            --text-scale: 1.4
        }

        [data-text-size=xxxlarge] {
            --text-scale: 1.6
        }

        html {
            scroll-behavior: smooth
        }

        body {
            --tw-bg-opacity: 1;
            background-color: rgb(250 250 250 / var(--tw-bg-opacity, 1));
            font-family: Huninn, Times New Roman, serif;
            --tw-text-opacity: 1;
            color: rgb(31 41 55 / var(--tw-text-opacity, 1));
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .3s
        }

        body *::-moz-selection {
            --tw-bg-opacity: 1;
            background-color: rgb(15 118 110 / var(--tw-bg-opacity, 1));
            --tw-text-opacity: 1;
            color: rgb(255 255 255 / var(--tw-text-opacity, 1))
        }

        body *::selection {
            --tw-bg-opacity: 1;
            background-color: rgb(15 118 110 / var(--tw-bg-opacity, 1));
            --tw-text-opacity: 1;
            color: rgb(255 255 255 / var(--tw-text-opacity, 1))
        }

        body::-moz-selection {
            --tw-bg-opacity: 1;
            background-color: rgb(15 118 110 / var(--tw-bg-opacity, 1));
            --tw-text-opacity: 1;
            color: rgb(255 255 255 / var(--tw-text-opacity, 1))
        }

        body::selection {
            --tw-bg-opacity: 1;
            background-color: rgb(15 118 110 / var(--tw-bg-opacity, 1));
            --tw-text-opacity: 1;
            color: rgb(255 255 255 / var(--tw-text-opacity, 1))
        }

        body:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(15 17 21 / var(--tw-bg-opacity, 1));
            --tw-text-opacity: 1;
            color: rgb(243 244 246 / var(--tw-text-opacity, 1))
        }

        body {
            font-size: calc(1rem * var(--text-scale))
        }

        p,
        span,
        a,
        li,
        td,
        th,
        label,
        button {
            font-size: inherit
        }

        h1 {
            font-size: calc(3rem * var(--text-scale))
        }

        h2 {
            font-size: calc(2.25rem * var(--text-scale))
        }

        h3 {
            font-size: calc(1.75rem * var(--text-scale))
        }

        h4 {
            font-size: calc(1.5rem * var(--text-scale))
        }

        h5 {
            font-size: calc(1.25rem * var(--text-scale))
        }

        h6 {
            font-size: calc(1rem * var(--text-scale))
        }

        small,
        .text-xs {
            font-size: calc(.75rem * var(--text-scale))
        }

        .text-sm {
            font-size: calc(.875rem * var(--text-scale))
        }

        ruby {
            ruby-position: over;
            ruby-align: center
        }

        rt {
            font-size: .6em;
            font-weight: 400;
            opacity: .9
        }

        .prose {
            color: var(--tw-prose-body);
            max-width: 65ch
        }

        .prose :where(p):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.25em;
            margin-bottom: 1.25em
        }

        .prose :where([class~=lead]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-lead);
            font-size: 1.25em;
            line-height: 1.6;
            margin-top: 1.2em;
            margin-bottom: 1.2em
        }

        .prose :where(a):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-links);
            text-decoration: underline;
            font-weight: 500
        }

        .prose :where(strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-bold);
            font-weight: 600
        }

        .prose :where(a strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(blockquote strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(thead th strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: decimal;
            margin-top: 1.25em;
            margin-bottom: 1.25em;
            padding-inline-start: 1.625em
        }

        .prose :where(ol[type=A]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: upper-alpha
        }

        .prose :where(ol[type=a]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: lower-alpha
        }

        .prose :where(ol[type=A s]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: upper-alpha
        }

        .prose :where(ol[type=a s]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: lower-alpha
        }

        .prose :where(ol[type=I]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: upper-roman
        }

        .prose :where(ol[type=i]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: lower-roman
        }

        .prose :where(ol[type=I s]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: upper-roman
        }

        .prose :where(ol[type=i s]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: lower-roman
        }

        .prose :where(ol[type="1"]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: decimal
        }

        .prose :where(ul):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: disc;
            margin-top: 1.25em;
            margin-bottom: 1.25em;
            padding-inline-start: 1.625em
        }

        .prose :where(ol>li):not(:where([class~=not-prose], [class~=not-prose] *))::marker {
            font-weight: 400;
            color: var(--tw-prose-counters)
        }

        .prose :where(ul>li):not(:where([class~=not-prose], [class~=not-prose] *))::marker {
            color: var(--tw-prose-bullets)
        }

        .prose :where(dt):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-headings);
            font-weight: 600;
            margin-top: 1.25em
        }

        .prose :where(hr):not(:where([class~=not-prose], [class~=not-prose] *)) {
            border-color: var(--tw-prose-hr);
            border-top-width: 1px;
            margin-top: 3em;
            margin-bottom: 3em
        }

        .prose :where(blockquote):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-weight: 500;
            font-style: italic;
            color: var(--tw-prose-quotes);
            border-inline-start-width: .25rem;
            border-inline-start-color: var(--tw-prose-quote-borders);
            quotes: "" "" "" "";
            margin-top: 1.6em;
            margin-bottom: 1.6em;
            padding-inline-start: 1em
        }

        .prose :where(blockquote p:first-of-type):not(:where([class~=not-prose], [class~=not-prose] *)):before {
            content: open-quote
        }

        .prose :where(blockquote p:last-of-type):not(:where([class~=not-prose], [class~=not-prose] *)):after {
            content: close-quote
        }

        .prose :where(h1):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-headings);
            font-weight: 800;
            font-size: 2.25em;
            margin-top: 0;
            margin-bottom: .8888889em;
            line-height: 1.1111111
        }

        .prose :where(h1 strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-weight: 900;
            color: inherit
        }

        .prose :where(h2):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-headings);
            font-weight: 700;
            font-size: 1.5em;
            margin-top: 2em;
            margin-bottom: 1em;
            line-height: 1.3333333
        }

        .prose :where(h2 strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-weight: 800;
            color: inherit
        }

        .prose :where(h3):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-headings);
            font-weight: 600;
            font-size: 1.25em;
            margin-top: 1.6em;
            margin-bottom: .6em;
            line-height: 1.6
        }

        .prose :where(h3 strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-weight: 700;
            color: inherit
        }

        .prose :where(h4):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-headings);
            font-weight: 600;
            margin-top: 1.5em;
            margin-bottom: .5em;
            line-height: 1.5
        }

        .prose :where(h4 strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-weight: 700;
            color: inherit
        }

        .prose :where(img):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 2em;
            margin-bottom: 2em
        }

        .prose :where(picture):not(:where([class~=not-prose], [class~=not-prose] *)) {
            display: block;
            margin-top: 2em;
            margin-bottom: 2em
        }

        .prose :where(video):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 2em;
            margin-bottom: 2em
        }

        .prose :where(kbd):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-weight: 500;
            font-family: inherit;
            color: var(--tw-prose-kbd);
            box-shadow: 0 0 0 1px var(--tw-prose-kbd-shadows), 0 3px 0 var(--tw-prose-kbd-shadows);
            font-size: .875em;
            border-radius: .3125rem;
            padding-top: .1875em;
            padding-inline-end: .375em;
            padding-bottom: .1875em;
            padding-inline-start: .375em
        }

        .prose :where(code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-code);
            font-weight: 600;
            font-size: .875em
        }

        .prose :where(code):not(:where([class~=not-prose], [class~=not-prose] *)):before {
            content: "`"
        }

        .prose :where(code):not(:where([class~=not-prose], [class~=not-prose] *)):after {
            content: "`"
        }

        .prose :where(a code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(h1 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(h2 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit;
            font-size: .875em
        }

        .prose :where(h3 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit;
            font-size: .9em
        }

        .prose :where(h4 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(blockquote code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(thead th code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(pre):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-pre-code);
            background-color: var(--tw-prose-pre-bg);
            overflow-x: auto;
            font-weight: 400;
            font-size: .875em;
            line-height: 1.7142857;
            margin-top: 1.7142857em;
            margin-bottom: 1.7142857em;
            border-radius: .375rem;
            padding-top: .8571429em;
            padding-inline-end: 1.1428571em;
            padding-bottom: .8571429em;
            padding-inline-start: 1.1428571em
        }

        .prose :where(pre code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            background-color: transparent;
            border-width: 0;
            border-radius: 0;
            padding: 0;
            font-weight: inherit;
            color: inherit;
            font-size: inherit;
            font-family: inherit;
            line-height: inherit
        }

        .prose :where(pre code):not(:where([class~=not-prose], [class~=not-prose] *)):before {
            content: none
        }

        .prose :where(pre code):not(:where([class~=not-prose], [class~=not-prose] *)):after {
            content: none
        }

        .prose :where(table):not(:where([class~=not-prose], [class~=not-prose] *)) {
            width: 100%;
            table-layout: auto;
            margin-top: 2em;
            margin-bottom: 2em;
            font-size: .875em;
            line-height: 1.7142857
        }

        .prose :where(thead):not(:where([class~=not-prose], [class~=not-prose] *)) {
            border-bottom-width: 1px;
            border-bottom-color: var(--tw-prose-th-borders)
        }

        .prose :where(thead th):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-headings);
            font-weight: 600;
            vertical-align: bottom;
            padding-inline-end: .5714286em;
            padding-bottom: .5714286em;
            padding-inline-start: .5714286em
        }

        .prose :where(tbody tr):not(:where([class~=not-prose], [class~=not-prose] *)) {
            border-bottom-width: 1px;
            border-bottom-color: var(--tw-prose-td-borders)
        }

        .prose :where(tbody tr:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            border-bottom-width: 0
        }

        .prose :where(tbody td):not(:where([class~=not-prose], [class~=not-prose] *)) {
            vertical-align: baseline
        }

        .prose :where(tfoot):not(:where([class~=not-prose], [class~=not-prose] *)) {
            border-top-width: 1px;
            border-top-color: var(--tw-prose-th-borders)
        }

        .prose :where(tfoot td):not(:where([class~=not-prose], [class~=not-prose] *)) {
            vertical-align: top
        }

        .prose :where(th, td):not(:where([class~=not-prose], [class~=not-prose] *)) {
            text-align: start
        }

        .prose :where(figure>*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0;
            margin-bottom: 0
        }

        .prose :where(figcaption):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-captions);
            font-size: .875em;
            line-height: 1.4285714;
            margin-top: .8571429em
        }

        .prose {
            --tw-prose-body: #374151;
            --tw-prose-headings: #111827;
            --tw-prose-lead: #4b5563;
            --tw-prose-links: #111827;
            --tw-prose-bold: #111827;
            --tw-prose-counters: #6b7280;
            --tw-prose-bullets: #d1d5db;
            --tw-prose-hr: #e5e7eb;
            --tw-prose-quotes: #111827;
            --tw-prose-quote-borders: #e5e7eb;
            --tw-prose-captions: #6b7280;
            --tw-prose-kbd: #111827;
            --tw-prose-kbd-shadows: rgb(17 24 39 / 10%);
            --tw-prose-code: #111827;
            --tw-prose-pre-code: #e5e7eb;
            --tw-prose-pre-bg: #1f2937;
            --tw-prose-th-borders: #d1d5db;
            --tw-prose-td-borders: #e5e7eb;
            --tw-prose-invert-body: #d1d5db;
            --tw-prose-invert-headings: #fff;
            --tw-prose-invert-lead: #9ca3af;
            --tw-prose-invert-links: #fff;
            --tw-prose-invert-bold: #fff;
            --tw-prose-invert-counters: #9ca3af;
            --tw-prose-invert-bullets: #4b5563;
            --tw-prose-invert-hr: #374151;
            --tw-prose-invert-quotes: #f3f4f6;
            --tw-prose-invert-quote-borders: #374151;
            --tw-prose-invert-captions: #9ca3af;
            --tw-prose-invert-kbd: #fff;
            --tw-prose-invert-kbd-shadows: rgb(255 255 255 / 10%);
            --tw-prose-invert-code: #fff;
            --tw-prose-invert-pre-code: #d1d5db;
            --tw-prose-invert-pre-bg: rgb(0 0 0 / 50%);
            --tw-prose-invert-th-borders: #4b5563;
            --tw-prose-invert-td-borders: #374151;
            font-size: 1rem;
            line-height: 1.75
        }

        .prose :where(picture>img):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0;
            margin-bottom: 0
        }

        .prose :where(li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .5em;
            margin-bottom: .5em
        }

        .prose :where(ol>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: .375em
        }

        .prose :where(ul>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: .375em
        }

        .prose :where(.prose>ul>li p):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .75em;
            margin-bottom: .75em
        }

        .prose :where(.prose>ul>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.25em
        }

        .prose :where(.prose>ul>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 1.25em
        }

        .prose :where(.prose>ol>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.25em
        }

        .prose :where(.prose>ol>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 1.25em
        }

        .prose :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .75em;
            margin-bottom: .75em
        }

        .prose :where(dl):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.25em;
            margin-bottom: 1.25em
        }

        .prose :where(dd):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .5em;
            padding-inline-start: 1.625em
        }

        .prose :where(hr+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose :where(h2+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose :where(h3+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose :where(h4+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose :where(thead th:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: 0
        }

        .prose :where(thead th:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-end: 0
        }

        .prose :where(tbody td, tfoot td):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-top: .5714286em;
            padding-inline-end: .5714286em;
            padding-bottom: .5714286em;
            padding-inline-start: .5714286em
        }

        .prose :where(tbody td:first-child, tfoot td:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: 0
        }

        .prose :where(tbody td:last-child, tfoot td:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-end: 0
        }

        .prose :where(figure):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 2em;
            margin-bottom: 2em
        }

        .prose :where(.prose>:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose :where(.prose>:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 0
        }

        .prose-lg {
            font-size: 1.125rem;
            line-height: 1.7777778
        }

        .prose-lg :where(p):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em;
            margin-bottom: 1.3333333em
        }

        .prose-lg :where([class~=lead]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: 1.2222222em;
            line-height: 1.4545455;
            margin-top: 1.0909091em;
            margin-bottom: 1.0909091em
        }

        .prose-lg :where(blockquote):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.6666667em;
            margin-bottom: 1.6666667em;
            padding-inline-start: 1em
        }

        .prose-lg :where(h1):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: 2.6666667em;
            margin-top: 0;
            margin-bottom: .8333333em;
            line-height: 1
        }

        .prose-lg :where(h2):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: 1.6666667em;
            margin-top: 1.8666667em;
            margin-bottom: 1.0666667em;
            line-height: 1.3333333
        }

        .prose-lg :where(h3):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: 1.3333333em;
            margin-top: 1.6666667em;
            margin-bottom: .6666667em;
            line-height: 1.5
        }

        .prose-lg :where(h4):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.7777778em;
            margin-bottom: .4444444em;
            line-height: 1.5555556
        }

        .prose-lg :where(img):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.7777778em;
            margin-bottom: 1.7777778em
        }

        .prose-lg :where(picture):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.7777778em;
            margin-bottom: 1.7777778em
        }

        .prose-lg :where(picture>img):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0;
            margin-bottom: 0
        }

        .prose-lg :where(video):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.7777778em;
            margin-bottom: 1.7777778em
        }

        .prose-lg :where(kbd):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .8888889em;
            border-radius: .3125rem;
            padding-top: .2222222em;
            padding-inline-end: .4444444em;
            padding-bottom: .2222222em;
            padding-inline-start: .4444444em
        }

        .prose-lg :where(code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .8888889em
        }

        .prose-lg :where(h2 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .8666667em
        }

        .prose-lg :where(h3 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .875em
        }

        .prose-lg :where(pre):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .8888889em;
            line-height: 1.75;
            margin-top: 2em;
            margin-bottom: 2em;
            border-radius: .375rem;
            padding-top: 1em;
            padding-inline-end: 1.5em;
            padding-bottom: 1em;
            padding-inline-start: 1.5em
        }

        .prose-lg :where(ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em;
            margin-bottom: 1.3333333em;
            padding-inline-start: 1.5555556em
        }

        .prose-lg :where(ul):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em;
            margin-bottom: 1.3333333em;
            padding-inline-start: 1.5555556em
        }

        .prose-lg :where(li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .6666667em;
            margin-bottom: .6666667em
        }

        .prose-lg :where(ol>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: .4444444em
        }

        .prose-lg :where(ul>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: .4444444em
        }

        .prose-lg :where(.prose-lg>ul>li p):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .8888889em;
            margin-bottom: .8888889em
        }

        .prose-lg :where(.prose-lg>ul>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em
        }

        .prose-lg :where(.prose-lg>ul>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 1.3333333em
        }

        .prose-lg :where(.prose-lg>ol>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em
        }

        .prose-lg :where(.prose-lg>ol>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 1.3333333em
        }

        .prose-lg :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .8888889em;
            margin-bottom: .8888889em
        }

        .prose-lg :where(dl):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em;
            margin-bottom: 1.3333333em
        }

        .prose-lg :where(dt):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em
        }

        .prose-lg :where(dd):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .6666667em;
            padding-inline-start: 1.5555556em
        }

        .prose-lg :where(hr):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 3.1111111em;
            margin-bottom: 3.1111111em
        }

        .prose-lg :where(hr+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-lg :where(h2+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-lg :where(h3+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-lg :where(h4+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-lg :where(table):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .8888889em;
            line-height: 1.5
        }

        .prose-lg :where(thead th):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-end: .75em;
            padding-bottom: .75em;
            padding-inline-start: .75em
        }

        .prose-lg :where(thead th:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: 0
        }

        .prose-lg :where(thead th:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-end: 0
        }

        .prose-lg :where(tbody td, tfoot td):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-top: .75em;
            padding-inline-end: .75em;
            padding-bottom: .75em;
            padding-inline-start: .75em
        }

        .prose-lg :where(tbody td:first-child, tfoot td:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: 0
        }

        .prose-lg :where(tbody td:last-child, tfoot td:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-end: 0
        }

        .prose-lg :where(figure):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.7777778em;
            margin-bottom: 1.7777778em
        }

        .prose-lg :where(figure>*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0;
            margin-bottom: 0
        }

        .prose-lg :where(figcaption):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .8888889em;
            line-height: 1.5;
            margin-top: 1em
        }

        .prose-lg :where(.prose-lg>:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-lg :where(.prose-lg>:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 0
        }

        .pointer-events-none {
            pointer-events: none
        }

        .visible {
            visibility: visible
        }

        .collapse {
            visibility: collapse
        }

        .static {
            position: static
        }

        .fixed {
            position: fixed
        }

        .absolute {
            position: absolute
        }

        .relative {
            position: relative
        }

        .inset-0 {
            top: 0;
            right: 0;
            bottom: 0;
            left: 0
        }

        .-right-1 {
            right: -.25rem
        }

        .-top-1 {
            top: -.25rem
        }

        .bottom-0 {
            bottom: 0
        }

        .left-0 {
            left: 0
        }

        .left-4 {
            left: 1rem
        }

        .right-0 {
            right: 0
        }

        .right-4 {
            right: 1rem
        }

        .top-16 {
            top: 4rem
        }

        .top-4 {
            top: 1rem
        }

        .z-10 {
            z-index: 10
        }

        .z-20 {
            z-index: 20
        }

        .z-40 {
            z-index: 40
        }

        .z-50 {
            z-index: 50
        }

        .z-\[60\] {
            z-index: 60
        }

        .col-span-full {
            grid-column: 1 / -1
        }

        .mx-1 {
            margin-left: .25rem;
            margin-right: .25rem
        }

        .mx-4 {
            margin-left: 1rem;
            margin-right: 1rem
        }

        .mx-auto {
            margin-left: auto;
            margin-right: auto
        }

        .mb-1 {
            margin-bottom: .25rem
        }

        .mb-12 {
            margin-bottom: 3rem
        }

        .mb-16 {
            margin-bottom: 4rem
        }

        .mb-2 {
            margin-bottom: .5rem
        }

        .mb-3 {
            margin-bottom: .75rem
        }

        .mb-4 {
            margin-bottom: 1rem
        }

        .mb-6 {
            margin-bottom: 1.5rem
        }

        .mb-8 {
            margin-bottom: 2rem
        }

        .mb-\[1px\] {
            margin-bottom: 1px
        }

        .ml-2 {
            margin-left: .5rem
        }

        .ml-auto {
            margin-left: auto
        }

        .mr-2 {
            margin-right: .5rem
        }

        .mr-3 {
            margin-right: .75rem
        }

        .mt-1 {
            margin-top: .25rem
        }

        .mt-16 {
            margin-top: 4rem
        }

        .mt-2 {
            margin-top: .5rem
        }

        .mt-20 {
            margin-top: 5rem
        }

        .mt-3 {
            margin-top: .75rem
        }

        .mt-4 {
            margin-top: 1rem
        }

        .mt-8 {
            margin-top: 2rem
        }

        .mt-auto {
            margin-top: auto
        }

        .line-clamp-2 {
            overflow: hidden;
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 2
        }

        .line-clamp-3 {
            overflow: hidden;
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 3
        }

        .block {
            display: block
        }

        .inline-block {
            display: inline-block
        }

        .inline {
            display: inline
        }

        .flex {
            display: flex
        }

        .inline-flex {
            display: inline-flex
        }

        .grid {
            display: grid
        }

        .contents {
            display: contents
        }

        .hidden {
            display: none
        }

        .aspect-\[16\/10\] {
            aspect-ratio: 16/10
        }

        .aspect-\[4\/3\] {
            aspect-ratio: 4/3
        }

        .aspect-video {
            aspect-ratio: 16 / 9
        }

        .h-10 {
            height: 2.5rem
        }

        .h-12 {
            height: 3rem
        }

        .h-16 {
            height: 4rem
        }

        .h-3 {
            height: .75rem
        }

        .h-4 {
            height: 1rem
        }

        .h-5 {
            height: 1.25rem
        }

        .h-6 {
            height: 1.5rem
        }

        .h-8 {
            height: 2rem
        }

        .h-\[50vh\] {
            height: 50vh
        }

        .h-\[calc\(100vh-350px\)\] {
            height: calc(100vh - 350px)
        }

        .h-\[calc\(100vh-64px\)\] {
            height: calc(100vh - 64px)
        }

        .h-full {
            height: 100%
        }

        .max-h-\[80vh\] {
            max-height: 80vh
        }

        .max-h-\[90vh\] {
            max-height: 90vh
        }

        .min-h-32 {
            min-height: 8rem
        }

        .min-h-\[400px\] {
            min-height: 400px
        }

        .min-h-\[60px\] {
            min-height: 60px
        }

        .min-h-screen {
            min-height: 100vh
        }

        .w-1\/2 {
            width: 50%
        }

        .w-1\/4 {
            width: 25%
        }

        .w-10 {
            width: 2.5rem
        }

        .w-12 {
            width: 3rem
        }

        .w-16 {
            width: 4rem
        }

        .w-3 {
            width: .75rem
        }

        .w-3\/4 {
            width: 75%
        }

        .w-4 {
            width: 1rem
        }

        .w-48 {
            width: 12rem
        }

        .w-5 {
            width: 1.25rem
        }

        .w-6 {
            width: 1.5rem
        }

        .w-64 {
            width: 16rem
        }

        .w-8 {
            width: 2rem
        }

        .w-full {
            width: 100%
        }

        .w-px {
            width: 1px
        }

        .min-w-0 {
            min-width: 0px
        }

        .min-w-\[150px\] {
            min-width: 150px
        }

        .min-w-\[60px\] {
            min-width: 60px
        }

        .max-w-2xl {
            max-width: 42rem
        }

        .max-w-3xl {
            max-width: 48rem
        }

        .max-w-4xl {
            max-width: 56rem
        }

        .max-w-6xl {
            max-width: 72rem
        }

        .max-w-lg {
            max-width: 32rem
        }

        .max-w-sm {
            max-width: 24rem
        }

        .max-w-xs {
            max-width: 20rem
        }

        .flex-1 {
            flex: 1 1 0%
        }

        .flex-shrink-0 {
            flex-shrink: 0
        }

        .-translate-x-2 {
            --tw-translate-x: -.5rem;
            transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
        }

        .rotate-180 {
            --tw-rotate: 180deg;
            transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
        }

        @keyframes pulse {
            50% {
                opacity: .5
            }
        }

        .animate-pulse {
            animation: pulse 2s cubic-bezier(.4, 0, .6, 1) infinite
        }

        @keyframes spin {
            to {
                transform: rotate(360deg)
            }
        }

        .animate-spin {
            animation: spin 1s linear infinite
        }

        .cursor-not-allowed {
            cursor: not-allowed
        }

        .cursor-pointer {
            cursor: pointer
        }

        .resize-none {
            resize: none
        }

        .list-inside {
            list-style-position: inside
        }

        .list-disc {
            list-style-type: disc
        }

        .appearance-none {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none
        }

        .grid-cols-1 {
            grid-template-columns: repeat(1, minmax(0, 1fr))
        }

        .flex-col {
            flex-direction: column
        }

        .flex-wrap {
            flex-wrap: wrap
        }

        .items-end {
            align-items: flex-end
        }

        .items-center {
            align-items: center
        }

        .justify-end {
            justify-content: flex-end
        }

        .justify-center {
            justify-content: center
        }

        .justify-between {
            justify-content: space-between
        }

        .gap-1 {
            gap: .25rem
        }

        .gap-2 {
            gap: .5rem
        }

        .gap-3 {
            gap: .75rem
        }

        .gap-4 {
            gap: 1rem
        }

        .gap-8 {
            gap: 2rem
        }

        .space-x-1>:not([hidden])~:not([hidden]) {
            --tw-space-x-reverse: 0;
            margin-right: calc(.25rem * var(--tw-space-x-reverse));
            margin-left: calc(.25rem * calc(1 - var(--tw-space-x-reverse)))
        }

        .space-x-2>:not([hidden])~:not([hidden]) {
            --tw-space-x-reverse: 0;
            margin-right: calc(.5rem * var(--tw-space-x-reverse));
            margin-left: calc(.5rem * calc(1 - var(--tw-space-x-reverse)))
        }

        .space-x-4>:not([hidden])~:not([hidden]) {
            --tw-space-x-reverse: 0;
            margin-right: calc(1rem * var(--tw-space-x-reverse));
            margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)))
        }

        .space-x-6>:not([hidden])~:not([hidden]) {
            --tw-space-x-reverse: 0;
            margin-right: calc(1.5rem * var(--tw-space-x-reverse));
            margin-left: calc(1.5rem * calc(1 - var(--tw-space-x-reverse)))
        }

        .space-y-1>:not([hidden])~:not([hidden]) {
            --tw-space-y-reverse: 0;
            margin-top: calc(.25rem * calc(1 - var(--tw-space-y-reverse)));
            margin-bottom: calc(.25rem * var(--tw-space-y-reverse))
        }

        .space-y-2>:not([hidden])~:not([hidden]) {
            --tw-space-y-reverse: 0;
            margin-top: calc(.5rem * calc(1 - var(--tw-space-y-reverse)));
            margin-bottom: calc(.5rem * var(--tw-space-y-reverse))
        }

        .space-y-3>:not([hidden])~:not([hidden]) {
            --tw-space-y-reverse: 0;
            margin-top: calc(.75rem * calc(1 - var(--tw-space-y-reverse)));
            margin-bottom: calc(.75rem * var(--tw-space-y-reverse))
        }

        .space-y-4>:not([hidden])~:not([hidden]) {
            --tw-space-y-reverse: 0;
            margin-top: calc(1rem * calc(1 - var(--tw-space-y-reverse)));
            margin-bottom: calc(1rem * var(--tw-space-y-reverse))
        }

        .space-y-6>:not([hidden])~:not([hidden]) {
            --tw-space-y-reverse: 0;
            margin-top: calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));
            margin-bottom: calc(1.5rem * var(--tw-space-y-reverse))
        }

        .overflow-auto {
            overflow: auto
        }

        .overflow-hidden {
            overflow: hidden
        }

        .overflow-y-auto {
            overflow-y: auto
        }

        .truncate {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap
        }

        .whitespace-pre-wrap {
            white-space: pre-wrap
        }

        .break-words {
            overflow-wrap: break-word
        }

        .rounded {
            border-radius: 0
        }

        .rounded-full {
            border-radius: 9999px
        }

        .rounded-lg {
            border-radius: 8px
        }

        .rounded-sm {
            border-radius: 2px
        }

        .rounded-l {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0
        }

        .rounded-r {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0
        }

        .rounded-t {
            border-top-left-radius: 0;
            border-top-right-radius: 0
        }

        .border {
            border-width: 1px
        }

        .border-2 {
            border-width: 2px
        }

        .border-4 {
            border-width: 4px
        }

        .border-y {
            border-top-width: 1px;
            border-bottom-width: 1px
        }

        .border-b {
            border-bottom-width: 1px
        }

        .border-b-2 {
            border-bottom-width: 2px
        }

        .border-r {
            border-right-width: 1px
        }

        .border-t {
            border-top-width: 1px
        }

        .border-dashed {
            border-style: dashed
        }

        .border-none {
            border-style: none
        }

        .border-accent {
            --tw-border-opacity: 1;
            border-color: rgb(15 118 110 / var(--tw-border-opacity, 1))
        }

        .border-blue-400 {
            --tw-border-opacity: 1;
            border-color: rgb(96 165 250 / var(--tw-border-opacity, 1))
        }

        .border-blue-500 {
            --tw-border-opacity: 1;
            border-color: rgb(59 130 246 / var(--tw-border-opacity, 1))
        }

        .border-gray-100 {
            --tw-border-opacity: 1;
            border-color: rgb(243 244 246 / var(--tw-border-opacity, 1))
        }

        .border-gray-200 {
            --tw-border-opacity: 1;
            border-color: rgb(229 231 235 / var(--tw-border-opacity, 1))
        }

        .border-gray-300 {
            --tw-border-opacity: 1;
            border-color: rgb(209 213 219 / var(--tw-border-opacity, 1))
        }

        .border-primary {
            --tw-border-opacity: 1;
            border-color: rgb(17 24 39 / var(--tw-border-opacity, 1))
        }

        .border-red-300 {
            --tw-border-opacity: 1;
            border-color: rgb(252 165 165 / var(--tw-border-opacity, 1))
        }

        .border-yellow-300 {
            --tw-border-opacity: 1;
            border-color: rgb(253 224 71 / var(--tw-border-opacity, 1))
        }

        .border-t-transparent {
            border-top-color: transparent
        }

        .bg-accent\/30 {
            background-color: #0f766e4d
        }

        .bg-accent\/80 {
            background-color: #0f766ecc
        }

        .bg-background-light {
            --tw-bg-opacity: 1;
            background-color: rgb(250 250 250 / var(--tw-bg-opacity, 1))
        }

        .bg-black {
            --tw-bg-opacity: 1;
            background-color: rgb(0 0 0 / var(--tw-bg-opacity, 1))
        }

        .bg-black\/50 {
            background-color: #00000080
        }

        .bg-black\/70 {
            background-color: #000000b3
        }

        .bg-blue-100 {
            --tw-bg-opacity: 1;
            background-color: rgb(219 234 254 / var(--tw-bg-opacity, 1))
        }

        .bg-blue-50 {
            --tw-bg-opacity: 1;
            background-color: rgb(239 246 255 / var(--tw-bg-opacity, 1))
        }

        .bg-blue-500 {
            --tw-bg-opacity: 1;
            background-color: rgb(59 130 246 / var(--tw-bg-opacity, 1))
        }

        .bg-gray-100 {
            --tw-bg-opacity: 1;
            background-color: rgb(243 244 246 / var(--tw-bg-opacity, 1))
        }

        .bg-gray-200 {
            --tw-bg-opacity: 1;
            background-color: rgb(229 231 235 / var(--tw-bg-opacity, 1))
        }

        .bg-gray-300 {
            --tw-bg-opacity: 1;
            background-color: rgb(209 213 219 / var(--tw-bg-opacity, 1))
        }

        .bg-gray-50 {
            --tw-bg-opacity: 1;
            background-color: rgb(249 250 251 / var(--tw-bg-opacity, 1))
        }

        .bg-gray-900 {
            --tw-bg-opacity: 1;
            background-color: rgb(17 24 39 / var(--tw-bg-opacity, 1))
        }

        .bg-green-100 {
            --tw-bg-opacity: 1;
            background-color: rgb(220 252 231 / var(--tw-bg-opacity, 1))
        }

        .bg-green-500 {
            --tw-bg-opacity: 1;
            background-color: rgb(34 197 94 / var(--tw-bg-opacity, 1))
        }

        .bg-orange-100 {
            --tw-bg-opacity: 1;
            background-color: rgb(255 237 213 / var(--tw-bg-opacity, 1))
        }

        .bg-orange-400 {
            --tw-bg-opacity: 1;
            background-color: rgb(251 146 60 / var(--tw-bg-opacity, 1))
        }

        .bg-orange-500 {
            --tw-bg-opacity: 1;
            background-color: rgb(249 115 22 / var(--tw-bg-opacity, 1))
        }

        .bg-orange-500\/80 {
            background-color: #f97316cc
        }

        .bg-primary {
            --tw-bg-opacity: 1;
            background-color: rgb(17 24 39 / var(--tw-bg-opacity, 1))
        }

        .bg-red-500 {
            --tw-bg-opacity: 1;
            background-color: rgb(239 68 68 / var(--tw-bg-opacity, 1))
        }

        .bg-red-600 {
            --tw-bg-opacity: 1;
            background-color: rgb(220 38 38 / var(--tw-bg-opacity, 1))
        }

        .bg-surface-light {
            --tw-bg-opacity: 1;
            background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1))
        }

        .bg-transparent {
            background-color: transparent
        }

        .bg-white {
            --tw-bg-opacity: 1;
            background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1))
        }

        .bg-yellow-300 {
            --tw-bg-opacity: 1;
            background-color: rgb(253 224 71 / var(--tw-bg-opacity, 1))
        }

        .bg-yellow-50 {
            --tw-bg-opacity: 1;
            background-color: rgb(254 252 232 / var(--tw-bg-opacity, 1))
        }

        .bg-yellow-600\/90 {
            background-color: #ca8a04e6
        }

        .bg-\[url\(\'data\:image\/svg\+xml\;charset\=US-ASCII\,\%3Csvg\%20xmlns\%3D\%22http\%3A\%2F\%2Fwww\.w3\.org\%2F2000\%2Fsvg\%22\%20width\%3D\%22292\.4\%22\%20height\%3D\%22292\.4\%22\%3E\%3Cpath\%20fill\%3D\%22\%239CA3AF\%22\%20d\%3D\%22M287\%2069\.4a17\.6\%2017\.6\%200\%200\%200-13-5\.4H18\.4c-5\%200-9\.3\%201\.8-12\.9\%205\.4A17\.6\%2017\.6\%200\%200\%200\%200\%2082\.2c0\%205\%201\.8\%209\.3\%205\.4\%2012\.9l128\%20127\.9c3\.6\%203\.6\%207\.8\%205\.4\%2012\.8\%205\.4s9\.2-1\.8\%2012\.8-5\.4L287\%2095c3\.5-3\.5\%205\.4-7\.8\%205\.4-12\.8\%200-5-1\.9-9\.2-5\.5-12\.8z\%22\%2F\%3E\%3C\%2Fsvg\%3E\'\)\] {
            background-image: url(data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%239CA3AF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E)
        }

        .bg-gradient-to-t {
            background-image: linear-gradient(to top, var(--tw-gradient-stops))
        }

        .from-background-light {
            --tw-gradient-from: #FAFAFA var(--tw-gradient-from-position);
            --tw-gradient-to: rgb(250 250 250 / 0) var(--tw-gradient-to-position);
            --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)
        }

        .via-transparent {
            --tw-gradient-to: rgb(0 0 0 / 0) var(--tw-gradient-to-position);
            --tw-gradient-stops: var(--tw-gradient-from), transparent var(--tw-gradient-via-position), var(--tw-gradient-to)
        }

        .to-transparent {
            --tw-gradient-to: transparent var(--tw-gradient-to-position)
        }

        .bg-\[length\:0\.7em\] {
            background-size: .7em
        }

        .bg-\[right_0_center\] {
            background-position: right 0 center
        }

        .bg-no-repeat {
            background-repeat: no-repeat
        }

        .object-cover {
            -o-object-fit: cover;
            object-fit: cover
        }

        .p-0 {
            padding: 0
        }

        .p-0\.5 {
            padding: .125rem
        }

        .p-2 {
            padding: .5rem
        }

        .p-3 {
            padding: .75rem
        }

        .p-4 {
            padding: 1rem
        }

        .p-6 {
            padding: 1.5rem
        }

        .p-8 {
            padding: 2rem
        }

        .px-1 {
            padding-left: .25rem;
            padding-right: .25rem
        }

        .px-2 {
            padding-left: .5rem;
            padding-right: .5rem
        }

        .px-3 {
            padding-left: .75rem;
            padding-right: .75rem
        }

        .px-4 {
            padding-left: 1rem;
            padding-right: 1rem
        }

        .py-1 {
            padding-top: .25rem;
            padding-bottom: .25rem
        }

        .py-1\.5 {
            padding-top: .375rem;
            padding-bottom: .375rem
        }

        .py-10 {
            padding-top: 2.5rem;
            padding-bottom: 2.5rem
        }

        .py-12 {
            padding-top: 3rem;
            padding-bottom: 3rem
        }

        .py-16 {
            padding-top: 4rem;
            padding-bottom: 4rem
        }

        .py-2 {
            padding-top: .5rem;
            padding-bottom: .5rem
        }

        .py-3 {
            padding-top: .75rem;
            padding-bottom: .75rem
        }

        .py-4 {
            padding-top: 1rem;
            padding-bottom: 1rem
        }

        .pb-1 {
            padding-bottom: .25rem
        }

        .pr-6 {
            padding-right: 1.5rem
        }

        .pt-10 {
            padding-top: 2.5rem
        }

        .pt-3 {
            padding-top: .75rem
        }

        .pt-8 {
            padding-top: 2rem
        }

        .text-left {
            text-align: left
        }

        .text-center {
            text-align: center
        }

        .font-display {
            font-family: ChiayiCity, Times New Roman, serif
        }

        .font-mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace
        }

        .text-2xl {
            font-size: 1.5rem;
            line-height: 2rem
        }

        .text-3xl {
            font-size: 1.875rem;
            line-height: 2.25rem
        }

        .text-4xl {
            font-size: 2.25rem;
            line-height: 2.5rem
        }

        .text-\[10px\] {
            font-size: 10px
        }

        .text-base {
            font-size: 1rem;
            line-height: 1.5rem
        }

        .text-lg {
            font-size: 1.125rem;
            line-height: 1.75rem
        }

        .text-sm {
            font-size: .875rem;
            line-height: 1.25rem
        }

        .text-xl {
            font-size: 1.25rem;
            line-height: 1.75rem
        }

        .text-xs {
            font-size: .75rem;
            line-height: 1rem
        }

        .font-bold {
            font-weight: 700
        }

        .font-medium {
            font-weight: 500
        }

        .uppercase {
            text-transform: uppercase
        }

        .italic {
            font-style: italic
        }

        .leading-tight {
            line-height: 1.25
        }

        .tracking-\[0\.2em\] {
            letter-spacing: .2em
        }

        .tracking-wider {
            letter-spacing: .05em
        }

        .text-accent {
            --tw-text-opacity: 1;
            color: rgb(15 118 110 / var(--tw-text-opacity, 1))
        }

        .text-blue-500 {
            --tw-text-opacity: 1;
            color: rgb(59 130 246 / var(--tw-text-opacity, 1))
        }

        .text-blue-600 {
            --tw-text-opacity: 1;
            color: rgb(37 99 235 / var(--tw-text-opacity, 1))
        }

        .text-blue-700 {
            --tw-text-opacity: 1;
            color: rgb(29 78 216 / var(--tw-text-opacity, 1))
        }

        .text-gray-300 {
            --tw-text-opacity: 1;
            color: rgb(209 213 219 / var(--tw-text-opacity, 1))
        }

        .text-gray-500 {
            --tw-text-opacity: 1;
            color: rgb(107 114 128 / var(--tw-text-opacity, 1))
        }

        .text-green-600 {
            --tw-text-opacity: 1;
            color: rgb(22 163 74 / var(--tw-text-opacity, 1))
        }

        .text-green-700 {
            --tw-text-opacity: 1;
            color: rgb(21 128 61 / var(--tw-text-opacity, 1))
        }

        .text-muted-light {
            --tw-text-opacity: 1;
            color: rgb(107 114 128 / var(--tw-text-opacity, 1))
        }

        .text-orange-500 {
            --tw-text-opacity: 1;
            color: rgb(249 115 22 / var(--tw-text-opacity, 1))
        }

        .text-orange-700 {
            --tw-text-opacity: 1;
            color: rgb(194 65 12 / var(--tw-text-opacity, 1))
        }

        .text-red-500 {
            --tw-text-opacity: 1;
            color: rgb(239 68 68 / var(--tw-text-opacity, 1))
        }

        .text-red-600 {
            --tw-text-opacity: 1;
            color: rgb(220 38 38 / var(--tw-text-opacity, 1))
        }

        .text-text-light {
            --tw-text-opacity: 1;
            color: rgb(31 41 55 / var(--tw-text-opacity, 1))
        }

        .text-transparent {
            color: transparent
        }

        .text-white {
            --tw-text-opacity: 1;
            color: rgb(255 255 255 / var(--tw-text-opacity, 1))
        }

        .text-white\/80 {
            color: #fffc
        }

        .text-white\/90 {
            color: #ffffffe6
        }

        .text-yellow-600 {
            --tw-text-opacity: 1;
            color: rgb(202 138 4 / var(--tw-text-opacity, 1))
        }

        .text-yellow-700 {
            --tw-text-opacity: 1;
            color: rgb(161 98 7 / var(--tw-text-opacity, 1))
        }

        .opacity-0 {
            opacity: 0
        }

        .opacity-30 {
            opacity: .3
        }

        .opacity-50 {
            opacity: .5
        }

        .opacity-70 {
            opacity: .7
        }

        .opacity-80 {
            opacity: .8
        }

        .opacity-90 {
            opacity: .9
        }

        .shadow-lg {
            --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / .1), 0 4px 6px -4px rgb(0 0 0 / .1);
            --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);
            box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
        }

        .shadow-sm {
            --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / .05);
            --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);
            box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
        }

        .shadow-xl {
            --tw-shadow: 0 20px 25px -5px rgb(0 0 0 / .1), 0 8px 10px -6px rgb(0 0 0 / .1);
            --tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);
            box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
        }

        .outline-none {
            outline: 2px solid transparent;
            outline-offset: 2px
        }

        .ring-1 {
            --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
            --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);
            box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)
        }

        .ring-white\/20 {
            --tw-ring-color: rgb(255 255 255 / .2)
        }

        .blur {
            --tw-blur: blur(8px);
            filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)
        }

        .filter {
            filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)
        }

        .backdrop-blur-sm {
            --tw-backdrop-blur: blur(4px);
            -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);
            backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)
        }

        .transition {
            transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .15s
        }

        .transition-all {
            transition-property: all;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .15s
        }

        .transition-colors {
            transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .15s
        }

        .transition-opacity {
            transition-property: opacity;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .15s
        }

        .transition-transform {
            transition-property: transform;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .15s
        }

        .delay-100 {
            transition-delay: .1s
        }

        .delay-200 {
            transition-delay: .2s
        }

        .duration-200 {
            transition-duration: .2s
        }

        .duration-300 {
            transition-duration: .3s
        }

        .duration-700 {
            transition-duration: .7s
        }

        .ease-out {
            transition-timing-function: cubic-bezier(0, 0, .2, 1)
        }

        .\[filter\:drop-shadow\(-2px_0_0_\#00e5ff\)_drop-shadow\(2px_0_0_\#ff0055\)\] {
            filter: drop-shadow(-2px 0 0 #00e5ff) drop-shadow(2px 0 0 #ff0055)
        }

        ::-webkit-scrollbar {
            width: 8px
        }

        ::-webkit-scrollbar-track {
            background: transparent
        }

        ::-webkit-scrollbar-thumb {
            background-color: #d1d5db;
            border-radius: 20px
        }

        .dark ::-webkit-scrollbar-thumb {
            background-color: #374151
        }

        .prose {
            max-width: 70ch
        }

        .prose p {
            margin-bottom: 2em;
            line-height: var(--prose-body-line-height, 2);
            font-weight: 400;
            font-size: calc(1.125rem * var(--text-scale));
            color: inherit
        }

        .prose h2 {
            font-family: ChiayiCity, Times New Roman, serif;
            font-size: calc(2.25rem * var(--text-scale));
            margin-top: 3em;
            margin-bottom: 1em;
            line-height: 1.25;
            font-weight: 400;
            letter-spacing: -.02em
        }

        .prose h3 {
            font-family: ChiayiCity, Times New Roman, serif;
            font-size: calc(1.75rem * var(--text-scale));
            margin-top: 2.5em;
            margin-bottom: .8em;
            line-height: 1.3;
            font-weight: 400;
            letter-spacing: -.01em
        }

        .prose blockquote {
            border-left: 4px solid var(--tw-prose-quote-borders, #0F766E);
            padding-left: 1.5rem;
            font-style: italic;
            margin: 2.5rem 0;
            color: #4b5563;
            font-size: calc(1.25rem * var(--text-scale));
            line-height: var(--prose-blockquote-line-height, 1.8);
            font-family: ChiayiCity, Times New Roman, serif
        }

        .dark .prose blockquote {
            border-color: #0f766e;
            color: #d1d5db
        }

        .prose ul,
        .prose ol {
            padding-left: 1.75rem;
            margin-bottom: 2em
        }

        .prose ul {
            list-style-type: disc
        }

        .prose ol {
            list-style-type: decimal
        }

        .prose li {
            margin-bottom: .75em;
            line-height: var(--prose-list-line-height, 1.8);
            font-size: calc(1.0625rem * var(--text-scale))
        }

        .prose code {
            font-size: .85em;
            padding: .25em .4em;
            background-color: #f1f5f9;
            border-radius: 4px;
            font-family: Menlo, Monaco, Courier New, monospace;
            color: #0f766e;
            font-weight: 500
        }

        .dark .prose code {
            background-color: #2d333b;
            color: #5eead4
        }

        .prose pre {
            margin: 2em 0;
            padding: 1.25rem;
            overflow-x: auto;
            border-radius: 4px
        }

        .prose a {
            color: inherit;
            text-decoration: underline;
            text-decoration-thickness: 1px;
            text-underline-offset: 3px;
            transition: opacity .2s
        }

        .prose a:hover {
            opacity: .7
        }

        .no-scrollbar::-webkit-scrollbar {
            display: none
        }

        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none
        }

        .dark\:prose-invert:is(.dark *) {
            --tw-prose-body: var(--tw-prose-invert-body);
            --tw-prose-headings: var(--tw-prose-invert-headings);
            --tw-prose-lead: var(--tw-prose-invert-lead);
            --tw-prose-links: var(--tw-prose-invert-links);
            --tw-prose-bold: var(--tw-prose-invert-bold);
            --tw-prose-counters: var(--tw-prose-invert-counters);
            --tw-prose-bullets: var(--tw-prose-invert-bullets);
            --tw-prose-hr: var(--tw-prose-invert-hr);
            --tw-prose-quotes: var(--tw-prose-invert-quotes);
            --tw-prose-quote-borders: var(--tw-prose-invert-quote-borders);
            --tw-prose-captions: var(--tw-prose-invert-captions);
            --tw-prose-kbd: var(--tw-prose-invert-kbd);
            --tw-prose-kbd-shadows: var(--tw-prose-invert-kbd-shadows);
            --tw-prose-code: var(--tw-prose-invert-code);
            --tw-prose-pre-code: var(--tw-prose-invert-pre-code);
            --tw-prose-pre-bg: var(--tw-prose-invert-pre-bg);
            --tw-prose-th-borders: var(--tw-prose-invert-th-borders);
            --tw-prose-td-borders: var(--tw-prose-invert-td-borders)
        }

        @media (min-width: 768px) {
            .md\:prose-xl {
                font-size: 1.25rem;
                line-height: 1.8
            }

            .md\:prose-xl :where(p):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em;
                margin-bottom: 1.2em
            }

            .md\:prose-xl :where([class~=lead]):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: 1.2em;
                line-height: 1.5;
                margin-top: 1em;
                margin-bottom: 1em
            }

            .md\:prose-xl :where(blockquote):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.6em;
                margin-bottom: 1.6em;
                padding-inline-start: 1.0666667em
            }

            .md\:prose-xl :where(h1):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: 2.8em;
                margin-top: 0;
                margin-bottom: .8571429em;
                line-height: 1
            }

            .md\:prose-xl :where(h2):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: 1.8em;
                margin-top: 1.5555556em;
                margin-bottom: .8888889em;
                line-height: 1.1111111
            }

            .md\:prose-xl :where(h3):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: 1.5em;
                margin-top: 1.6em;
                margin-bottom: .6666667em;
                line-height: 1.3333333
            }

            .md\:prose-xl :where(h4):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.8em;
                margin-bottom: .6em;
                line-height: 1.6
            }

            .md\:prose-xl :where(img):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 2em;
                margin-bottom: 2em
            }

            .md\:prose-xl :where(picture):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 2em;
                margin-bottom: 2em
            }

            .md\:prose-xl :where(picture>img):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0;
                margin-bottom: 0
            }

            .md\:prose-xl :where(video):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 2em;
                margin-bottom: 2em
            }

            .md\:prose-xl :where(kbd):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .9em;
                border-radius: .3125rem;
                padding-top: .25em;
                padding-inline-end: .4em;
                padding-bottom: .25em;
                padding-inline-start: .4em
            }

            .md\:prose-xl :where(code):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .9em
            }

            .md\:prose-xl :where(h2 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .8611111em
            }

            .md\:prose-xl :where(h3 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .9em
            }

            .md\:prose-xl :where(pre):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .9em;
                line-height: 1.7777778;
                margin-top: 2em;
                margin-bottom: 2em;
                border-radius: .5rem;
                padding-top: 1.1111111em;
                padding-inline-end: 1.3333333em;
                padding-bottom: 1.1111111em;
                padding-inline-start: 1.3333333em
            }

            .md\:prose-xl :where(ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em;
                margin-bottom: 1.2em;
                padding-inline-start: 1.6em
            }

            .md\:prose-xl :where(ul):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em;
                margin-bottom: 1.2em;
                padding-inline-start: 1.6em
            }

            .md\:prose-xl :where(li):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: .6em;
                margin-bottom: .6em
            }

            .md\:prose-xl :where(ol>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-start: .4em
            }

            .md\:prose-xl :where(ul>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-start: .4em
            }

            .md\:prose-xl :where(.md\:prose-xl>ul>li p):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: .8em;
                margin-bottom: .8em
            }

            .md\:prose-xl :where(.md\:prose-xl>ul>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em
            }

            .md\:prose-xl :where(.md\:prose-xl>ul>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-bottom: 1.2em
            }

            .md\:prose-xl :where(.md\:prose-xl>ol>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em
            }

            .md\:prose-xl :where(.md\:prose-xl>ol>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-bottom: 1.2em
            }

            .md\:prose-xl :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: .8em;
                margin-bottom: .8em
            }

            .md\:prose-xl :where(dl):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em;
                margin-bottom: 1.2em
            }

            .md\:prose-xl :where(dt):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em
            }

            .md\:prose-xl :where(dd):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: .6em;
                padding-inline-start: 1.6em
            }

            .md\:prose-xl :where(hr):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 2.8em;
                margin-bottom: 2.8em
            }

            .md\:prose-xl :where(hr+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0
            }

            .md\:prose-xl :where(h2+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0
            }

            .md\:prose-xl :where(h3+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0
            }

            .md\:prose-xl :where(h4+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0
            }

            .md\:prose-xl :where(table):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .9em;
                line-height: 1.5555556
            }

            .md\:prose-xl :where(thead th):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-end: .6666667em;
                padding-bottom: .8888889em;
                padding-inline-start: .6666667em
            }

            .md\:prose-xl :where(thead th:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-start: 0
            }

            .md\:prose-xl :where(thead th:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-end: 0
            }

            .md\:prose-xl :where(tbody td, tfoot td):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-top: .8888889em;
                padding-inline-end: .6666667em;
                padding-bottom: .8888889em;
                padding-inline-start: .6666667em
            }

            .md\:prose-xl :where(tbody td:first-child, tfoot td:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-start: 0
            }

            .md\:prose-xl :where(tbody td:last-child, tfoot td:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-end: 0
            }

            .md\:prose-xl :where(figure):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 2em;
                margin-bottom: 2em
            }

            .md\:prose-xl :where(figure>*):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0;
                margin-bottom: 0
            }

            .md\:prose-xl :where(figcaption):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .9em;
                line-height: 1.5555556;
                margin-top: 1em
            }

            .md\:prose-xl :where(.md\:prose-xl>:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0
            }

            .md\:prose-xl :where(.md\:prose-xl>:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-bottom: 0
            }
        }

        .hover\:border-accent:hover {
            --tw-border-opacity: 1;
            border-color: rgb(15 118 110 / var(--tw-border-opacity, 1))
        }

        .hover\:bg-blue-100:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(219 234 254 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-blue-50:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(239 246 255 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-blue-600:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(37 99 235 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-gray-100:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(243 244 246 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-gray-200:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(229 231 235 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-gray-50:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(249 250 251 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-gray-800:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(31 41 55 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-green-600:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(22 163 74 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-orange-600:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(234 88 12 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-red-100:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(254 226 226 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-red-50:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(254 242 242 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-red-600:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(220 38 38 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-red-700:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(185 28 28 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-white:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1))
        }

        .hover\:text-accent:hover {
            --tw-text-opacity: 1;
            color: rgb(15 118 110 / var(--tw-text-opacity, 1))
        }

        .hover\:text-gray-800:hover {
            --tw-text-opacity: 1;
            color: rgb(31 41 55 / var(--tw-text-opacity, 1))
        }

        .hover\:text-gray-900:hover {
            --tw-text-opacity: 1;
            color: rgb(17 24 39 / var(--tw-text-opacity, 1))
        }

        .hover\:text-red-700:hover {
            --tw-text-opacity: 1;
            color: rgb(185 28 28 / var(--tw-text-opacity, 1))
        }

        .hover\:text-text-light:hover {
            --tw-text-opacity: 1;
            color: rgb(31 41 55 / var(--tw-text-opacity, 1))
        }

        .hover\:opacity-70:hover {
            opacity: .7
        }

        .hover\:opacity-80:hover {
            opacity: .8
        }

        .focus\:border-gray-400:focus {
            --tw-border-opacity: 1;
            border-color: rgb(156 163 175 / var(--tw-border-opacity, 1))
        }

        .focus\:outline-none:focus {
            outline: 2px solid transparent;
            outline-offset: 2px
        }

        .focus\:ring-0:focus {
            --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
            --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);
            box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)
        }

        .focus\:ring-2:focus {
            --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
            --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
            box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)
        }

        .focus\:ring-black:focus {
            --tw-ring-opacity: 1;
            --tw-ring-color: rgb(0 0 0 / var(--tw-ring-opacity, 1))
        }

        .disabled\:cursor-not-allowed:disabled {
            cursor: not-allowed
        }

        .disabled\:opacity-30:disabled {
            opacity: .3
        }

        .disabled\:opacity-50:disabled {
            opacity: .5
        }

        .group:hover .group-hover\:translate-x-0 {
            --tw-translate-x: 0px;
            transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
        }

        .group:hover .group-hover\:translate-y-\[-2px\] {
            --tw-translate-y: -2px;
            transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
        }

        .group:hover .group-hover\:scale-105 {
            --tw-scale-x: 1.05;
            --tw-scale-y: 1.05;
            transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
        }

        .group:hover .group-hover\:text-accent {
            --tw-text-opacity: 1;
            color: rgb(15 118 110 / var(--tw-text-opacity, 1))
        }

        .group:hover .group-hover\:opacity-100 {
            opacity: 1
        }

        .group:hover .group-hover\:shadow-md {
            --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / .1), 0 2px 4px -2px rgb(0 0 0 / .1);
            --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);
            box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
        }

        .dark\:border-gray-600:is(.dark *) {
            --tw-border-opacity: 1;
            border-color: rgb(75 85 99 / var(--tw-border-opacity, 1))
        }

        .dark\:border-gray-700:is(.dark *) {
            --tw-border-opacity: 1;
            border-color: rgb(55 65 81 / var(--tw-border-opacity, 1))
        }

        .dark\:border-gray-800:is(.dark *) {
            --tw-border-opacity: 1;
            border-color: rgb(31 41 55 / var(--tw-border-opacity, 1))
        }

        .dark\:border-yellow-700:is(.dark *) {
            --tw-border-opacity: 1;
            border-color: rgb(161 98 7 / var(--tw-border-opacity, 1))
        }

        .dark\:bg-background-dark:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(15 17 21 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-blue-900\/20:is(.dark *) {
            background-color: #1e3a8a33
        }

        .dark\:bg-blue-900\/40:is(.dark *) {
            background-color: #1e3a8a66
        }

        .dark\:bg-gray-600:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(75 85 99 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-gray-700:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(55 65 81 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-gray-800:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(31 41 55 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-gray-800\/30:is(.dark *) {
            background-color: #1f29374d
        }

        .dark\:bg-gray-800\/50:is(.dark *) {
            background-color: #1f293780
        }

        .dark\:bg-gray-900:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(17 24 39 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-green-900:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(20 83 45 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-orange-900:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(124 45 18 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-surface-dark:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(24 27 33 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-white:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-yellow-900\/20:is(.dark *) {
            background-color: #713f1233
        }

        .dark\:from-background-dark:is(.dark *) {
            --tw-gradient-from: #0f1115 var(--tw-gradient-from-position);
            --tw-gradient-to: rgb(15 17 21 / 0) var(--tw-gradient-to-position);
            --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)
        }

        .dark\:text-black:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(0 0 0 / var(--tw-text-opacity, 1))
        }

        .dark\:text-blue-300:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(147 197 253 / var(--tw-text-opacity, 1))
        }

        .dark\:text-gray-400:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(156 163 175 / var(--tw-text-opacity, 1))
        }

        .dark\:text-green-300:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(134 239 172 / var(--tw-text-opacity, 1))
        }

        .dark\:text-muted-dark:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(156 163 175 / var(--tw-text-opacity, 1))
        }

        .dark\:text-orange-300:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(253 186 116 / var(--tw-text-opacity, 1))
        }

        .dark\:text-text-dark:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(243 244 246 / var(--tw-text-opacity, 1))
        }

        .dark\:text-yellow-300:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(253 224 71 / var(--tw-text-opacity, 1))
        }

        .dark\:text-yellow-400:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(250 204 21 / var(--tw-text-opacity, 1))
        }

        .dark\:text-yellow-500:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(234 179 8 / var(--tw-text-opacity, 1))
        }

        .dark\:\[filter\:drop-shadow\(-2px_0_0_rgba\(0\,229\,255\,0\.5\)\)_drop-shadow\(2px_0_0_rgba\(255\,0\,85\,0\.5\)\)_drop-shadow\(0_0_5px_rgba\(0\,229\,255\,0\.15\)\)\]:is(.dark *) {
            filter: drop-shadow(-2px 0 0 rgba(0, 229, 255, .5)) drop-shadow(2px 0 0 rgba(255, 0, 85, .5)) drop-shadow(0 0 5px rgba(0, 229, 255, .15))
        }

        .dark\:hover\:bg-blue-900\/20:hover:is(.dark *) {
            background-color: #1e3a8a33
        }

        .dark\:hover\:bg-blue-900\/30:hover:is(.dark *) {
            background-color: #1e3a8a4d
        }

        .dark\:hover\:bg-gray-700:hover:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(55 65 81 / var(--tw-bg-opacity, 1))
        }

        .dark\:hover\:bg-gray-800:hover:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(31 41 55 / var(--tw-bg-opacity, 1))
        }

        .dark\:hover\:bg-red-900:hover:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(127 29 29 / var(--tw-bg-opacity, 1))
        }

        .dark\:hover\:bg-red-900\/30:hover:is(.dark *) {
            background-color: #7f1d1d4d
        }

        .dark\:hover\:text-accent:hover:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(15 118 110 / var(--tw-text-opacity, 1))
        }

        .dark\:hover\:text-gray-200:hover:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(229 231 235 / var(--tw-text-opacity, 1))
        }

        .dark\:hover\:text-text-dark:hover:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(243 244 246 / var(--tw-text-opacity, 1))
        }

        .dark\:hover\:text-white:hover:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(255 255 255 / var(--tw-text-opacity, 1))
        }

        .dark\:focus\:ring-white:focus:is(.dark *) {
            --tw-ring-opacity: 1;
            --tw-ring-color: rgb(255 255 255 / var(--tw-ring-opacity, 1))
        }

        @media (min-width: 640px) {
            .sm\:flex {
                display: flex
            }

            .sm\:px-6 {
                padding-left: 1.5rem;
                padding-right: 1.5rem
            }
        }

        @media (min-width: 768px) {
            .md\:static {
                position: static
            }

            .md\:z-auto {
                z-index: auto
            }

            .md\:mb-0 {
                margin-bottom: 0
            }

            .md\:inline {
                display: inline
            }

            .md\:flex {
                display: flex
            }

            .md\:grid {
                display: grid
            }

            .md\:hidden {
                display: none
            }

            .md\:aspect-auto {
                aspect-ratio: auto
            }

            .md\:h-\[60vh\] {
                height: 60vh
            }

            .md\:h-full {
                height: 100%
            }

            .md\:max-h-\[calc\(100vh-64px\)\] {
                max-height: calc(100vh - 64px)
            }

            .md\:grid-cols-2 {
                grid-template-columns: repeat(2, minmax(0, 1fr))
            }

            .md\:gap-8 {
                gap: 2rem
            }

            .md\:space-x-2>:not([hidden])~:not([hidden]) {
                --tw-space-x-reverse: 0;
                margin-right: calc(.5rem * var(--tw-space-x-reverse));
                margin-left: calc(.5rem * calc(1 - var(--tw-space-x-reverse)))
            }

            .md\:p-12 {
                padding: 3rem
            }

            .md\:px-4 {
                padding-left: 1rem;
                padding-right: 1rem
            }

            .md\:py-4 {
                padding-top: 1rem;
                padding-bottom: 1rem
            }

            .md\:text-4xl {
                font-size: 2.25rem;
                line-height: 2.5rem
            }

            .md\:text-6xl {
                font-size: 3.75rem;
                line-height: 1
            }

            .md\:text-base {
                font-size: 1rem;
                line-height: 1.5rem
            }
        }

        @media (min-width: 1024px) {
            .lg\:grid-cols-3 {
                grid-template-columns: repeat(3, minmax(0, 1fr))
            }

            .lg\:px-8 {
                padding-left: 2rem;
                padding-right: 2rem
            }

            .lg\:text-7xl {
                font-size: 4.5rem;
                line-height: 1
            }
        }
    </style>
</head>

<body>
    <!-- Loading skeleton - replaced by React when app loads -->
    <div id="root">
        <div class="skeleton-loader">
            <nav class="skeleton-nav">
                <div class="skeleton-logo"></div>
            </nav>
            <main class="skeleton-content">
                <div class="skeleton-title"></div>
                <div class="skeleton-grid">
                    <div class="skeleton-card">
                        <div class="skeleton-image"></div>
                        <div class="skeleton-text">
                            <div class="skeleton-line"></div>
                            <div class="skeleton-line"></div>
                        </div>
                    </div>
                    <div class="skeleton-card">
                        <div class="skeleton-image"></div>
                        <div class="skeleton-text">
                            <div class="skeleton-line"></div>
                            <div class="skeleton-line"></div>
                        </div>
                    </div>
                    <div class="skeleton-card">
                        <div class="skeleton-image"></div>
                        <div class="skeleton-text">
                            <div class="skeleton-line"></div>
                            <div class="skeleton-line"></div>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>

</body>

</html>